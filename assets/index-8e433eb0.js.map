{"version":3,"file":"index-8e433eb0.js","sources":["../../src/core/EventEmitter.ts","../../src/core/World.ts","../../src/core/System.ts","../../src/components/TransformComponent.ts","../../src/components/VisualComponent.ts","../../src/components/IsometricMovementComponent.ts","../../src/components/GridPositionComponent.ts","../../src/services/GridService.ts","../../src/components/ParticleComponent.ts","../../src/systems/MovementSystem.ts","../../src/systems/InputSystem.ts","../../src/systems/GridRenderSystem.ts","../../src/core/BaseEntity.ts","../../src/components/TreeComponent.ts","../../src/components/ZIndexComponent.ts","../../src/components/PlayerComponent.ts","../../src/services/GridOccupancyService.ts","../../src/systems/TreeSystem.ts","../../src/systems/ZIndexSystem.ts","../../src/components/CoinComponent.ts","../../src/components/CoinCounterComponent.ts","../../src/components/SpeedBoostComponent.ts","../../src/systems/CoinSystem.ts","../../src/components/UIComponent.ts","../../src/systems/UIRenderSystem.ts","../../src/systems/CoinCounterSystem.ts","../../src/systems/ParticleSystem.ts","../../src/systems/SpeedBoostSystem.ts","../../src/systems/VignetteSystem.ts","../../src/core/Game.ts","../../src/di/container.ts","../../src/index.ts"],"sourcesContent":["type EventCallback = (...args: any[]) => void;\n\nexport class EventEmitter {\n  private events: Map<string, EventCallback[]> = new Map();\n\n  on(event: string, callback: EventCallback): void {\n    if (!this.events.has(event)) {\n      this.events.set(event, []);\n    }\n    this.events.get(event)!.push(callback);\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const callbacks = this.events.get(event);\n    if (callbacks) {\n      callbacks.forEach(callback => callback(...args));\n    }\n  }\n\n  off(event: string, callback: EventCallback): void {\n    const callbacks = this.events.get(event);\n    if (callbacks) {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1) {\n        callbacks.splice(index, 1);\n      }\n      if (callbacks.length === 0) {\n        this.events.delete(event);\n      }\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { Entity } from './Component';\nimport { BaseSystem } from './System';\nimport { EventEmitter } from './EventEmitter';\nimport { Container } from 'inversify';\n\nexport enum GameState {\n  Playing = 'Playing',\n  GameOver = 'GameOver',\n  Starting = 'Starting'\n}\n\n@injectable()\nexport class World extends EventEmitter {\n  private systems: BaseSystem[] = [];\n  private entities: Set<Entity> = new Set();\n  private currentState: GameState = GameState.Starting;\n  private _container: Container;\n\n  constructor(container: Container) {\n    super();\n    this._container = container;\n  }\n\n  public addSystem(system: BaseSystem): void {\n    this.systems.push(system);\n    system.setWorld(this);\n  }\n\n  public addEntity(entity: Entity): void {\n    this.entities.add(entity);\n  }\n\n  public removeEntity(entity: Entity): void {\n    this.entities.delete(entity);\n  }\n\n  public clearEntities(): void {\n    this.entities.clear();\n  }\n\n  public getEntities(): Entity[] {\n    return Array.from(this.entities);\n  }\n\n  public getSystem<T extends BaseSystem>(systemType: new (...args: any[]) => T): T | undefined {\n    return this.systems.find(system => system instanceof systemType) as T | undefined;\n  }\n\n  public clearSystems(): void {\n    this.systems = [];\n  }\n\n  public cleanup(): void {\n    // Clear all entities\n    this.clearEntities();\n    \n    // Reset all systems\n    for (const system of this.systems) {\n      system.reset();\n    }\n    \n    // Clear systems\n    this.clearSystems();\n    \n    // Reset game state\n    this.currentState = GameState.Starting;\n  }\n\n  public getCurrentState(): GameState {\n    return this.currentState;\n  }\n\n  public setGameState(newState: GameState): void {\n    const oldState = this.currentState;\n    this.currentState = newState;\n    \n    // Emit state change event that systems can listen to\n    this.emit('gameStateChanged', { oldState, newState });\n\n    if (newState === GameState.GameOver) {\n      this.emit('gameOver');\n    } else if (newState === GameState.Starting) {\n      // Transition to Playing state after a short delay\n      setTimeout(() => {\n        this.setGameState(GameState.Playing);\n      }, 100);\n    }\n  }\n\n  public update(deltaTime: number): void {\n    // Only update systems if we're in Playing state\n    if (this.currentState !== GameState.Playing) {\n      return;\n    }\n\n    const entities = Array.from(this.entities);\n    for (const system of this.systems) {\n      system.update(entities, deltaTime);\n    }\n  }\n\n  public get container(): Container {\n    return this._container;\n  }\n} ","import { Entity } from './Component';\nimport { Application } from 'pixi.js';\nimport { World, GameState } from './World';\n\nexport interface System {\n  readonly requiredComponents: symbol[];\n  setApp(app: Application): void;\n  setWorld(world: World): void;\n  update(entities: Entity[], deltaTime: number): void;\n}\n\nexport abstract class BaseSystem implements System {\n  protected app: Application | null = null;\n  protected world: World | null = null;\n\n  abstract readonly requiredComponents: symbol[];\n\n  setApp(app: Application): void {\n    this.app = app;\n  }\n\n  setWorld(world: World): void {\n    this.world = world;\n    // Listen for game state changes\n    world.on('gameStateChanged', ({ oldState, newState }) => {\n      this.onGameStateChanged(oldState, newState);\n    });\n  }\n\n  /**\n   * Called when the game state changes\n   */\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to reset its state\n   */\n  public reset(): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to initialize or re-initialize\n   */\n  public initialize(): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to cleanup its resources\n   */\n  public cleanup(): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to be fully reinitialized\n   */\n  public reinitialize(): void {\n    this.cleanup();\n    this.reset();\n    this.initialize();\n  }\n\n  update(entities: Entity[], deltaTime: number): void {\n    const relevantEntities = entities.filter(entity => \n      this.requiredComponents.every(componentType => entity.hasComponent(componentType))\n    );\n    this.updateRelevantEntities(relevantEntities, deltaTime);\n  }\n\n  protected abstract updateRelevantEntities(entities: Entity[], deltaTime: number): void;\n} ","import { Component, Entity } from '../core/Component';\n\nexport const TransformComponentType = Symbol('TransformComponent');\n\nexport class TransformComponent implements Component {\n  public readonly type = TransformComponentType;\n  public entity: Entity | null = null;\n  \n  constructor(\n    public x: number = 0,\n    public y: number = 0,\n    public rotation: number = 0\n  ) {}\n} ","import { Graphics, Container, Sprite, Texture, Assets } from 'pixi.js';\nimport { Component, Entity } from '../core/Component';\n\nexport const VisualComponentType = Symbol('VisualComponent');\n\nexport class VisualComponent implements Component {\n  public readonly type = VisualComponentType;\n  public entity: Entity | null = null;\n  public container: Container;\n  public sprite: Sprite | null = null;\n  public graphics: Graphics | null = null;\n\n  constructor(options: { radius?: number; color?: number; spritePath?: string } = {}) {\n    this.container = new Container();\n    let YOffset = - 32;\n    \n    if (options.spritePath) {\n      const texture = Assets.get(options.spritePath);\n      this.sprite = new Sprite(texture);\n      this.sprite.anchor.set(0.5);\n      \n      // Set size to 128x128 (doubled from 64x64)\n      const targetSize = 128;\n      const scale = targetSize / Math.max(this.sprite.width, this.sprite.height);\n      this.sprite.scale.set(scale);\n      \n      // Start facing right (for DownRight movement)\n      this.sprite.scale.x = -Math.abs(this.sprite.scale.x);\n      this.sprite.y += YOffset\n      \n      this.container.addChild(this.sprite);\n    } else {\n      this.graphics = new Graphics()\n        .circle(0, 0, options.radius || 5)\n        .fill({ color: options.color || 0xFF0000 });\n      this.container.addChild(this.graphics);\n    }\n  }\n\n  public flipX(): void {\n    if (this.sprite) {\n      this.sprite.scale.x = -this.sprite.scale.x;\n    }\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const IsometricMovementComponentType = Symbol('IsometricMovementComponent');\n\nexport enum Direction {\n  None = 'none',\n  TopRight = 'topRight',\n  TopLeft = 'topLeft',\n  DownRight = 'downRight',\n  DownLeft = 'downLeft'\n}\n\nexport class IsometricMovementComponent implements Component {\n  public readonly type = IsometricMovementComponentType;\n  public entity: Entity | null = null;\n  public currentDirection: Direction = Direction.None;\n  public targetDirection: Direction = Direction.None;\n  public isMoving: boolean = false;\n  public baseSpeed: number = 200;\n  \n  constructor(\n    public speed: number = this.baseSpeed\n  ) {}\n} ","import { Component, Entity } from '../core/Component';\n\nexport const GridPositionComponentType = Symbol('GridPositionComponent');\n\nexport class GridPositionComponent implements Component {\n  public readonly type = GridPositionComponentType;\n  public entity: Entity | null = null;\n  \n  constructor(\n    public gridX: number = 0,\n    public gridY: number = 0,\n    public targetGridX: number = 0,\n    public targetGridY: number = 0,\n    public isMoving: boolean = false\n  ) {\n    this.targetGridX = gridX;\n    this.targetGridY = gridY;\n  }\n\n  public setTargetPosition(x: number, y: number) {\n    this.targetGridX = x;\n    this.targetGridY = y;\n    this.isMoving = true;\n  }\n\n  public reachedTarget(): boolean {\n    return this.gridX === this.targetGridX && this.gridY === this.targetGridY;\n  }\n} ","import { injectable } from 'inversify';\nimport { Direction } from '../components/IsometricMovementComponent';\n\n@injectable()\nexport class GridService {\n    private readonly TILE_WIDTH = 128;\n    private readonly TILE_HEIGHT = 64;\n\n    /**\n     * Converts grid coordinates to world (screen) coordinates\n     */\n    gridToWorld(gridX: number, gridY: number): { x: number, y: number } {\n        const worldX = (gridX - gridY) * (this.TILE_WIDTH / 2);\n        const worldY = (gridX + gridY) * (this.TILE_HEIGHT / 2);\n        return { x: worldX, y: worldY };\n    }\n\n    /**\n     * Converts world coordinates to grid coordinates\n     */\n    worldToGrid(worldX: number, worldY: number): { x: number, y: number } {\n        // Using the inverse of the isometric projection\n        const gridX = (worldX / this.TILE_WIDTH + worldY / this.TILE_HEIGHT);\n        const gridY = (worldY / this.TILE_HEIGHT - worldX / this.TILE_WIDTH);\n        return { \n            x: Math.round(gridX), \n            y: Math.round(gridY) \n        };\n    }\n\n    /**\n     * Get the dimensions of a tile\n     */\n    getTileDimensions(): { width: number, height: number } {\n        return {\n            width: this.TILE_WIDTH,\n            height: this.TILE_HEIGHT\n        };\n    }\n\n    /**\n     * Get the next grid position based on direction\n     */\n    getNextGridPosition(currentX: number, currentY: number, direction: Direction): { x: number, y: number } {\n        switch (direction) {\n            case Direction.DownRight:\n                return { x: currentX + 1, y: currentY };\n            case Direction.DownLeft:\n                return { x: currentX, y: currentY + 1 };\n            case Direction.TopRight:\n                return { x: currentX, y: currentY - 1 };\n            case Direction.TopLeft:\n                return { x: currentX - 1, y: currentY };\n            default:\n                return { x: currentX, y: currentY };\n        }\n    }\n\n    /**\n     * Check if a grid position is valid\n     */\n    isValidGridPosition(x: number, y: number): boolean {\n        // Add any grid boundary checks here if needed\n        return true;\n    }\n} ","import { Component } from '../core/Component';\nimport { Entity } from '../core/Component';\n\nexport const ParticleComponentType = Symbol('ParticleComponent');\n\nexport interface ParticleData {\n  color: number;\n  size: number;\n  lifetime: number;\n  alpha: number;\n  velocityX: number;\n  velocityY: number;\n}\n\nexport class ParticleComponent implements Component {\n  public readonly type = ParticleComponentType;\n  public particles: ParticleData[] = [];\n  public isActive: boolean = false;\n  public lastDirection: { x: number, y: number } = { x: 0, y: 0 };\n  public entity: Entity | null = null;\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { IsometricMovementComponent, IsometricMovementComponentType, Direction } from '../components/IsometricMovementComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { GridService } from '../services/GridService';\nimport { Container } from 'pixi.js';\nimport { Application } from 'pixi.js';\nimport { ParticleComponent, ParticleComponentType } from '../components/ParticleComponent';\n\n@injectable()\nexport class MovementSystem extends BaseSystem {\n  public worldContainer: Container | null = null;\n\n  readonly requiredComponents = [\n    TransformComponentType,\n    VisualComponentType,\n    IsometricMovementComponentType,\n    GridPositionComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService\n  ) {\n    super();\n  }\n\n  public setApp(app: Application): void {\n    super.setApp(app);\n    if (app) {\n      this.initializeWorldContainer();\n    }\n  }\n\n  private initializeWorldContainer(): void {\n    if (!this.app) return;\n    \n    // Create a world container that will be moved around\n    this.worldContainer = new Container();\n    this.app.stage.addChild(this.worldContainer);\n    this.worldContainer.position.set(0, 0);\n  }\n\n  public cleanup(): void {\n    if (this.worldContainer && this.app) {\n      this.app.stage.removeChild(this.worldContainer);\n      this.worldContainer.destroy();\n      this.worldContainer = null;\n    }\n  }\n\n  public reinitialize(): void {\n    this.cleanup();\n    this.initializeWorldContainer();\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.worldContainer || !this.app) return;\n\n    for (const entity of entities) {\n      const transform = entity.getComponent<TransformComponent>(TransformComponentType);\n      const movement = entity.getComponent<IsometricMovementComponent>(IsometricMovementComponentType);\n      const gridPos = entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n      const visual = entity.getComponent<VisualComponent>(VisualComponentType);\n      const particleComponent = entity.getComponent<ParticleComponent>(ParticleComponentType);\n      \n      if (transform && movement && gridPos && visual) {\n        // Only set new target position if we're not already moving\n        if (!gridPos.isMoving && movement.targetDirection !== Direction.None) {\n          const nextPosition = this.gridService.getNextGridPosition(\n            gridPos.gridX,\n            gridPos.gridY,\n            movement.targetDirection\n          );\n\n          gridPos.setTargetPosition(nextPosition.x, nextPosition.y);\n          movement.currentDirection = movement.targetDirection;\n          movement.isMoving = true;\n          gridPos.isMoving = true;\n\n          // Update particle direction when starting movement\n          if (particleComponent) {\n            const direction = this.getDirectionVector(movement.targetDirection);\n            particleComponent.lastDirection = direction;\n            particleComponent.isActive = true;\n          }\n        }\n\n        if (gridPos.isMoving) {\n          // Calculate current and target positions in world space\n          const targetWorldPos = this.gridService.gridToWorld(gridPos.targetGridX, gridPos.targetGridY);\n          \n          // Calculate direction and distance to target\n          const dx = targetWorldPos.x - transform.x;\n          const dy = targetWorldPos.y - transform.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n\n          if (distance < 1) {\n            // Reached target grid position\n            transform.x = targetWorldPos.x;\n            transform.y = targetWorldPos.y;\n            gridPos.gridX = gridPos.targetGridX;\n            gridPos.gridY = gridPos.targetGridY;\n            gridPos.isMoving = false;\n            movement.isMoving = false;\n            movement.currentDirection = Direction.None;\n\n            // Stop particles when movement ends\n            if (particleComponent) {\n              particleComponent.isActive = false;\n            }\n          } else {\n            // Move towards target using the movement component's speed\n            const moveDistance = movement.speed * deltaTime;\n            const ratio = Math.min(moveDistance / distance, 1);\n\n            transform.x += dx * ratio;\n            transform.y += dy * ratio;\n          }\n\n          // Update visual position\n          visual.container.position.set(transform.x, transform.y);\n\n          // Center camera on character immediately without smoothing\n          if (this.worldContainer && this.app) {\n            // Calculate the position that will center the character on screen\n            const screenCenterX = 0;\n            const screenCenterY = 0;\n            \n            // Move the world container to center the character\n            this.worldContainer.position.x = screenCenterX - transform.x;\n            this.worldContainer.position.y = screenCenterY - transform.y;\n          }\n        } else {\n          // Even when not moving, ensure the character is centered\n          if (this.worldContainer && this.app) {\n            const screenCenterX = 0;\n            const screenCenterY = 0;\n            \n            this.worldContainer.position.x = screenCenterX - transform.x;\n            this.worldContainer.position.y = screenCenterY - transform.y;\n          }\n        }\n      }\n    }\n  }\n\n  private getDirectionVector(direction: Direction): { x: number, y: number } {\n    switch (direction) {\n      case Direction.TopRight:\n        return { x: 1, y: -1 };\n      case Direction.TopLeft:\n        return { x: -1, y: -1 };\n      case Direction.DownRight:\n        return { x: 1, y: 1 };\n      case Direction.DownLeft:\n        return { x: -1, y: 1 };\n      default:\n        return { x: 0, y: 0 };\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { IsometricMovementComponent, IsometricMovementComponentType, Direction } from '../components/IsometricMovementComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { Application } from 'pixi.js';\n\n@injectable()\nexport class InputSystem extends BaseSystem {\n  private queuedDirectionChange = false;\n  private isMovingDownRight = true; // Start with down-right direction\n  private needsFlip = false; // Track if we need to flip the sprite\n\n  readonly requiredComponents = [\n    IsometricMovementComponentType,\n    VisualComponentType,\n    GridPositionComponentType\n  ];\n\n  public reset(): void {\n    // Reset input state\n    this.queuedDirectionChange = false;\n    this.isMovingDownRight = true; // Reset to initial direction (down-right)\n    this.needsFlip = false;\n  }\n\n  setApp(app: Application): void {\n    super.setApp(app);\n    if (app.canvas) {\n      app.canvas.addEventListener('click', () => this.handleTap());\n      app.canvas.addEventListener('touchstart', () => this.handleTap());\n    }\n  }\n\n  private handleTap() {\n    // Only accept new input if we're not already processing a direction change\n    if (!this.queuedDirectionChange) {\n      this.queuedDirectionChange = true;\n      this.needsFlip = true;\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.queuedDirectionChange && !this.needsFlip) return;\n\n    for (const entity of entities) {\n      const movement = entity.getComponent<IsometricMovementComponent>(IsometricMovementComponentType);\n      const gridPos = entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n      const visual = entity.getComponent<VisualComponent>(VisualComponentType);\n      \n      if (movement && gridPos && visual) {\n        // Handle sprite flipping immediately on input\n        if (this.needsFlip) {\n          visual.flipX();\n          this.needsFlip = false;\n        }\n\n        // Handle movement direction change when reaching tile center\n        if (this.queuedDirectionChange && !gridPos.isMoving) {\n          this.isMovingDownRight = !this.isMovingDownRight;\n          movement.targetDirection = this.isMovingDownRight ? Direction.DownRight : Direction.DownLeft;\n          this.queuedDirectionChange = false;\n        }\n      }\n    }\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { Application, Graphics, Container } from 'pixi.js';\nimport { GridService } from '../services/GridService';\nimport { TransformComponentType } from '../components/TransformComponent';\nimport { World, GameState } from '../core/World';\nimport { MovementSystem } from '../systems/MovementSystem';\n\ninterface GridTile {\n  graphics: Graphics;\n  isInUse: boolean;\n  gridX: number;\n  gridY: number;\n}\n\n@injectable()\nexport class GridRenderSystem extends BaseSystem {\n  private gridContainer: Container;\n  private tilePool: GridTile[] = [];\n  private activeTiles: Map<string, GridTile> = new Map();\n  private readonly VISIBLE_RADIUS = 12;\n  private readonly POOL_SIZE = 600;\n  private lastCenterX = 0;\n  private lastCenterY = 0;\n  private isInitialized = false;\n\n  readonly requiredComponents = [\n    TransformComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService\n  ) {\n    super();\n    this.gridContainer = new Container();\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.GameOver) {\n      // Stop processing updates (handled by World)\n    } else if (newState === GameState.Starting) {\n      this.initialize();\n    }\n  }\n\n  public initialize(): void {\n    if (!this.world || !this.app?.stage) return;\n\n    this.initializeTilePool();\n    \n    // Center the grid container on screen\n    this.gridContainer.position.set(0, 0);\n    // Add to world container instead of stage\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (movementSystem && movementSystem.worldContainer) {\n      movementSystem.worldContainer.addChildAt(this.gridContainer, 0);\n    }\n    this.tilePool.forEach(tile => this.gridContainer.addChild(tile.graphics));\n    \n    // Show initial grid\n    this.updateVisibleTiles(0, 0);\n    this.isInitialized = true;\n  }\n\n  public reset(): void {\n    // Return all tiles to the pool\n    for (const [key, tile] of this.activeTiles) {\n      this.recycleTile(tile);\n    }\n\n    // Clear active tiles map\n    this.activeTiles.clear();\n\n    // Reset the visible area tracking\n    this.lastCenterX = 0;\n    this.lastCenterY = 0;\n  }\n\n  private initializeTilePool(): void {\n    for (let i = 0; i < this.POOL_SIZE; i++) {\n      const graphics = new Graphics();\n      this.createTileGraphics(graphics);\n      graphics.visible = false;\n      \n      this.tilePool.push({\n        graphics,\n        isInUse: false,\n        gridX: 0,\n        gridY: 0\n      });\n    }\n  }\n\n  private createTileGraphics(graphics: Graphics): void {\n    const { width, height } = this.gridService.getTileDimensions();\n    graphics.clear();\n    \n    // Draw filled shape\n    graphics\n      .setFillStyle({\n        color: 0xffffff,\n        alpha: 1\n      })\n      .moveTo(0, -height/2)\n      .lineTo(width/2, 0)\n      .lineTo(0, height/2)\n      .lineTo(-width/2, 0)\n      .lineTo(0, -height/2)\n      .fill();\n\n    // Draw outline\n    graphics\n      .setStrokeStyle({\n        width: 1,\n        color: 0xCCCCCC,\n        alpha: 1\n      })\n      .moveTo(0, -height/2)\n      .lineTo(width/2, 0)\n      .lineTo(0, height/2)\n      .lineTo(-width/2, 0)\n      .lineTo(0, -height/2)\n      .stroke();\n  }\n\n  private getTileKey(x: number, y: number): string {\n    return `${x},${y}`;\n  }\n\n  private getFreeTile(): GridTile | null {\n    return this.tilePool.find(tile => !tile.isInUse) || null;\n  }\n\n  private placeTile(gridX: number, gridY: number, centerX: number, centerY: number): void {\n    if (!this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    const key = this.getTileKey(gridX, gridY);\n    if (this.activeTiles.has(key)) return;\n\n    const tile = this.getFreeTile();\n    if (!tile) return;\n\n    // Use GridService for consistent world position calculation\n    const worldPos = this.gridService.worldToGrid(centerX, centerY);\n    \n    this.createTileGraphics(tile.graphics);\n    const tileWorldPos = this.gridService.gridToWorld(gridX, gridY);\n    tile.graphics.position.set(tileWorldPos.x, tileWorldPos.y);\n    tile.graphics.visible = true;\n    tile.isInUse = true;\n    tile.gridX = gridX;\n    tile.gridY = gridY;\n    \n    this.activeTiles.set(key, tile);\n\n    // Emit an event for tile creation that TreeSystem can listen to\n    if (this.world) {\n      this.world.emit('tileCreated', { gridX, gridY });\n    }\n  }\n\n  private recycleTile(tile: GridTile): void {\n    const key = this.getTileKey(tile.gridX, tile.gridY);\n    tile.graphics.visible = false;\n    tile.isInUse = false;\n    this.activeTiles.delete(key);\n  }\n\n  private updateVisibleTiles(centerX: number, centerY: number): void {\n    if (!this.app || !this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      // If the world container isn't ready yet, just return\n      return;\n    }\n\n    // Use the world container's position to determine the center\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n    \n    // Calculate the center in world coordinates\n    const centerWorldX = -worldContainerPos.x;\n    const centerWorldY = -worldContainerPos.y;\n\n    const worldPos = this.gridService.worldToGrid(centerWorldX, centerWorldY);\n    const gridCenterX = Math.floor(worldPos.x);\n    const gridCenterY = Math.floor(worldPos.y);\n\n    // Calculate visible area bounds\n    const minX = gridCenterX - this.VISIBLE_RADIUS;\n    const maxX = gridCenterX + this.VISIBLE_RADIUS;\n    const minY = gridCenterY - this.VISIBLE_RADIUS;\n    const maxY = gridCenterY + this.VISIBLE_RADIUS;\n\n    // Calculate which tiles should be visible\n    const neededTiles = new Set<string>();\n    \n    // Use symmetric bounds for tile placement\n    for (let gridX = minX; gridX <= maxX; gridX++) {\n      for (let gridY = minY; gridY <= maxY; gridY++) {\n        // Calculate Manhattan distance to center to create a more circular visible area\n        const distance = Math.abs(gridX - gridCenterX) + Math.abs(gridY - gridCenterY);\n        if (distance <= this.VISIBLE_RADIUS * 1.5) {\n          const key = this.getTileKey(gridX, gridY);\n          neededTiles.add(key);\n\n          // Place new tiles if needed\n          if (!this.activeTiles.has(key)) {\n            this.placeTile(gridX, gridY, centerWorldX, centerWorldY);\n          }\n        }\n      }\n    }\n\n    // Recycle tiles that are no longer visible\n    for (const [key, tile] of this.activeTiles) {\n      if (!neededTiles.has(key)) {\n        this.recycleTile(tile);\n      }\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage || !this.isInitialized) return;\n    if (!this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      // If the world container isn't ready yet, just return\n      return;\n    }\n\n    // Use the world container's position\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n\n    this.updateVisibleTiles(worldContainerPos.x, worldContainerPos.y);\n  }\n}","import { Component, Entity } from './Component';\n\nexport class BaseEntity implements Entity {\n  private static nextId = 0;\n  public readonly id: number;\n  public components: Map<symbol, Component>;\n\n  constructor() {\n    this.id = BaseEntity.nextId++;\n    this.components = new Map();\n  }\n\n  public addComponent(component: Component): void {\n    this.components.set(component.type, component);\n    component.entity = this;\n  }\n\n  public removeComponent(componentType: symbol): void {\n    const component = this.components.get(componentType);\n    if (component) {\n      component.entity = null;\n      this.components.delete(componentType);\n    }\n  }\n\n  public getComponent<T extends Component>(componentType: symbol): T | undefined {\n    return this.components.get(componentType) as T;\n  }\n\n  public hasComponent(componentType: symbol): boolean {\n    return this.components.has(componentType);\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const TreeComponentType = Symbol('TreeComponent');\n\nexport class TreeComponent implements Component {\n  readonly type = TreeComponentType;\n  entity: Entity | null = null;\n\n  constructor() {}\n} ","import { Component, Entity } from '../core/Component';\nimport { VisualComponent } from './VisualComponent';\nimport { GridPositionComponent } from './GridPositionComponent';\n\nexport const ZIndexComponentType = Symbol('ZIndexComponent');\n\nexport class ZIndexComponent implements Component {\n  public readonly type = ZIndexComponentType;\n  public entity: Entity | null = null;\n  \n  // Base Z-index for different types of entities\n  // This allows us to group entities and ensure certain types are always above others\n  public baseZ: number;\n\n  // UI z-index constants\n  static readonly UI = {\n    VIGNETTE: 1000,\n    COIN_COUNTER: 2000\n  };\n\n  constructor(baseZ: number = 0) {\n    this.baseZ = baseZ;\n  }\n\n  // Calculate final Z-index based on grid position\n  // Objects lower on the screen (higher Y) should appear in front\n  public calculateZ(gridPos: GridPositionComponent): number {\n    // Use Y position as main factor, higher Y means higher Z-index (appears in front)\n    // Use X position as secondary factor to maintain consistent ordering for objects on same Y\n    return this.baseZ + (gridPos.gridY * 1000) + gridPos.gridX;\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const PlayerComponentType = Symbol('PlayerComponent');\n\nexport class PlayerComponent implements Component {\n  public readonly type = PlayerComponentType;\n  public entity: Entity | null = null;\n\n  constructor() {}\n} ","import { injectable } from 'inversify';\n\nexport enum OccupancyType {\n  Tree = 'tree',\n  Coin = 'coin',\n  Character = 'character'\n}\n\n@injectable()\nexport class GridOccupancyService {\n  private occupiedCells: Map<string, Set<OccupancyType>> = new Map();\n\n  private getKey(x: number, y: number): string {\n    return `${x},${y}`;\n  }\n\n  public isOccupied(x: number, y: number, type?: OccupancyType): boolean {\n    const key = this.getKey(x, y);\n    const cell = this.occupiedCells.get(key);\n    \n    if (!cell) return false;\n    if (!type) return cell.size > 0;\n    return cell.has(type);\n  }\n\n  public occupy(x: number, y: number, type: OccupancyType): void {\n    const key = this.getKey(x, y);\n    if (!this.occupiedCells.has(key)) {\n      this.occupiedCells.set(key, new Set());\n    }\n    const cell = this.occupiedCells.get(key)!;\n    if (cell.has(type)) {\n      return;\n    }\n    cell.add(type);\n  }\n\n  public free(x: number, y: number, type: OccupancyType): void {\n    const key = this.getKey(x, y);\n    const cell = this.occupiedCells.get(key);\n    if (cell) {\n      if (!cell.has(type)) {\n        return;\n      }\n      cell.delete(type);\n      if (cell.size === 0) {\n        this.occupiedCells.delete(key);\n      }\n    } else {\n      console.warn(`[GridOccupancyService] Attempting to free non-existent cell at ${x},${y} with type ${type}`);\n    }\n  }\n\n  public reset(): void {\n    this.occupiedCells.clear();\n  }\n\n  public getOccupancyTypes(x: number, y: number): Set<OccupancyType> | undefined {\n    const key = this.getKey(x, y);\n    return this.occupiedCells.get(key);\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { BaseEntity } from '../core/BaseEntity';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { TreeComponent, TreeComponentType } from '../components/TreeComponent';\nimport { ZIndexComponent, ZIndexComponentType } from '../components/ZIndexComponent';\nimport { PlayerComponent, PlayerComponentType } from '../components/PlayerComponent';\nimport { GridService } from '../services/GridService';\nimport { GridOccupancyService, OccupancyType } from '../services/GridOccupancyService';\nimport { World, GameState } from '../core/World';\nimport { Application } from 'pixi.js';\nimport { MovementSystem } from '../systems/MovementSystem';\n\n// Z-index base values for different entity types\nconst Z_INDEX = {\n  TREE: 100\n};\n\ninterface PooledTree {\n  entity: Entity;\n  isInUse: boolean;\n  gridX: number;\n  gridY: number;\n}\n\n@injectable()\nexport class TreeSystem extends BaseSystem {\n  private readonly TREE_DENSITY = 0.05; // 5% chance of a tree on each tile\n  private readonly VISIBLE_RADIUS = 12; // Match GridRenderSystem's visible radius\n  private readonly POOL_SIZE = 100; // Maximum number of trees that can exist at once\n  \n  private treePool: PooledTree[] = [];\n  private activeTreePositions: Map<string, PooledTree> = new Map();\n  private pendingTileEvents: { gridX: number, gridY: number }[] = [];\n  private isInitialized = false;\n\n  readonly requiredComponents = [\n    GridPositionComponentType,\n    TreeComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService,\n    @inject(GridOccupancyService) private gridOccupancyService: GridOccupancyService\n  ) {\n    super();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n    // Listen for tile creation events\n    this.world.on('tileCreated', (data: { gridX: number, gridY: number }) => {\n      if (!this.isInitialized) {\n        this.pendingTileEvents.push(data);\n      } else {\n        this.trySpawnTreeAt(data.gridX, data.gridY);\n      }\n    });\n\n    // Initialize tree pool if app is already set\n    if (this.app) {\n      const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n      if (movementSystem?.worldContainer) {\n        this.initializeTreePool();\n      }\n    }\n  }\n\n  public setApp(app: Application): void {\n    this.app = app;\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.GameOver) {\n      this.reset();\n    } else if (newState === GameState.Starting) {\n      this.initialize();\n    }\n  }\n\n  public initialize(): void {\n    if (!this.world || !this.app?.stage) {\n      return;\n    }\n  }\n\n  public reset(): void {\n    // First remove all active trees from the stage and grid\n    for (const [key, tree] of this.activeTreePositions.entries()) {\n      const visual = tree.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual && visual.container.parent) {\n        visual.container.parent.removeChild(visual.container);\n      }\n      if (this.world) {\n        this.world.removeEntity(tree.entity);\n      }\n      this.gridOccupancyService.free(tree.gridX, tree.gridY, OccupancyType.Tree);\n    }\n\n    // Clear active positions map\n    this.activeTreePositions.clear();\n\n    // Clean up the pool\n    for (const tree of this.treePool) {\n      if (this.world) {\n        this.world.removeEntity(tree.entity);\n      }\n    }\n    this.treePool = [];\n    this.isInitialized = false;\n\n    // Reinitialize the pool\n    if (this.app && this.world) {\n      const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n      if (movementSystem?.worldContainer) {\n        this.initializeTreePool();\n      }\n    }\n  }\n\n  private initializeTreePool(): void {\n    if (!this.world || !this.app?.stage) return;\n    \n    // Get the movement system first\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      console.warn('[TreeSystem] Movement system not ready, delaying pool initialization');\n      return;\n    }\n    \n    for (let i = 0; i < this.POOL_SIZE; i++) {\n      const tree = new BaseEntity();\n      const transform = new TransformComponent(0, 0);\n      const gridPos = new GridPositionComponent(0, 0);\n      const visual = new VisualComponent({\n        spritePath: '/tree.png',\n      });\n      const treeComponent = new TreeComponent();\n      const zIndex = new ZIndexComponent(Z_INDEX.TREE);\n\n      tree.addComponent(transform);\n      tree.addComponent(gridPos);\n      tree.addComponent(visual);\n      tree.addComponent(treeComponent);\n      tree.addComponent(zIndex);\n\n      this.world.addEntity(tree);\n      \n      // Add to world container\n      movementSystem.worldContainer.addChild(visual.container);\n      visual.container.visible = false;\n\n      this.treePool.push({\n        entity: tree,\n        isInUse: false,\n        gridX: 0,\n        gridY: 0\n      });\n    }\n    \n    // Mark as initialized and process any pending tile events\n    this.isInitialized = true;\n    this.processPendingTileEvents();\n  }\n\n  private processPendingTileEvents(): void {\n    if (!this.isInitialized) return;\n    \n    // Process all pending tile events\n    for (const event of this.pendingTileEvents) {\n      this.trySpawnTreeAt(event.gridX, event.gridY);\n    }\n    this.pendingTileEvents = [];\n  }\n\n  private removeTree(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    const tree = this.activeTreePositions.get(key);\n    \n    if (tree) {\n      const visual = tree.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual) {\n        visual.container.visible = false;\n      }\n      \n      // Mark the tree as not in use in the pool\n      tree.isInUse = false;\n      tree.gridX = 0;\n      tree.gridY = 0;\n      \n      this.gridOccupancyService.free(gridX, gridY, OccupancyType.Tree);\n      this.activeTreePositions.delete(key);\n    }\n  }\n\n  public spawnTree(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    if (this.activeTreePositions.has(key)) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    // Find an unused tree from the pool\n    const unusedTreeIndex = this.treePool.findIndex(tree => !tree.isInUse);\n    if (unusedTreeIndex === -1) {\n      console.warn('[TreeSystem] Tree pool exhausted. Active trees:', this.activeTreePositions.size);\n      return;\n    }\n\n    const unusedTree = this.treePool[unusedTreeIndex];\n    const worldPos = this.gridService.gridToWorld(gridX, gridY);\n    \n    // Update the tree's components\n    const transform = unusedTree.entity.getComponent<TransformComponent>(TransformComponentType);\n    const gridPos = unusedTree.entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n    const visual = unusedTree.entity.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (!transform || !gridPos || !visual) {\n      console.warn('[TreeSystem] Missing required components for tree');\n      return;\n    }\n\n    // Get the movement system and world container\n    const movementSystem = this.world?.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      console.warn('[TreeSystem] Movement system or world container not ready');\n      return;\n    }\n\n    // Update transform and position\n    transform.x = worldPos.x;\n    transform.y = worldPos.y;\n    gridPos.gridX = gridX;\n    gridPos.gridY = gridY;\n    visual.container.visible = true;\n    visual.container.position.set(transform.x, transform.y);\n\n    // Ensure the visual container is in the world container\n    if (!visual.container.parent) {\n      movementSystem.worldContainer.addChild(visual.container);\n    }\n\n    // Mark the tree as in use in the pool\n    unusedTree.isInUse = true;\n    unusedTree.gridX = gridX;\n    unusedTree.gridY = gridY;\n    \n    this.activeTreePositions.set(key, unusedTree);\n    this.gridOccupancyService.occupy(gridX, gridY, OccupancyType.Tree);\n  }\n\n  public trySpawnTreeAt(gridX: number, gridY: number): void {\n    if (!this.world) return;\n    if (this.world.getCurrentState() !== GameState.Playing) return;\n\n    const distanceFromStart = Math.abs(gridX) + Math.abs(gridY);\n    \n    if (distanceFromStart < 20) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    const roll = Math.random();\n    if (roll < this.TREE_DENSITY) {\n      this.spawnTree(gridX, gridY);\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage || this.world?.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      return;\n    }\n\n    // Update positions of all trees\n    for (const tree of this.activeTreePositions.values()) {\n      this.updateTreePosition(tree.entity);\n    }\n\n    // Check for collisions with players\n    const players = this.world?.getEntities().filter(entity => \n      entity.hasComponent(PlayerComponentType) &&\n      entity.hasComponent(GridPositionComponentType)\n    );\n\n    if (players) {\n      for (const player of players) {\n        const playerGridPos = player.getComponent<GridPositionComponent>(GridPositionComponentType);\n        if (playerGridPos) {\n          // First check grid occupancy service\n          if (this.gridOccupancyService.isOccupied(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Tree)) {\n            // Verify against active trees to ensure the tree still exists\n            const key = `${playerGridPos.gridX},${playerGridPos.gridY}`;\n            if (this.activeTreePositions.has(key)) {\n              this.world?.setGameState(GameState.GameOver);\n              return;\n            } else {\n              // If we found an occupancy but no active tree, clean up the occupancy\n              this.gridOccupancyService.free(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Tree);\n            }\n          }\n        }\n      }\n    }\n\n    // Clean up trees that are too far from the center\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n\n    const centerWorldX = -worldContainerPos.x;\n    const centerWorldY = -worldContainerPos.y;\n\n    const worldPos = this.gridService.worldToGrid(centerWorldX, centerWorldY);\n    const gridCenterX = Math.floor(worldPos.x);\n    const gridCenterY = Math.floor(worldPos.y);\n\n    // Remove trees that are too far from view\n    for (const [key, tree] of this.activeTreePositions.entries()) {\n      const gridPos = tree.entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n      if (gridPos) {\n        const distance = Math.abs(gridPos.gridX - gridCenterX) + Math.abs(gridPos.gridY - gridCenterY);\n        if (distance > this.VISIBLE_RADIUS * 1.5) {\n          this.removeTree(gridPos.gridX, gridPos.gridY);\n        }\n      }\n    }\n  }\n\n  private updateTreePosition(tree: Entity): void {\n    const transform = tree.getComponent<TransformComponent>(TransformComponentType);\n    const visual = tree.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (transform && visual) {\n      visual.container.position.set(transform.x, transform.y);\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { ZIndexComponent, ZIndexComponentType } from '../components/ZIndexComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\n\n@injectable()\nexport class ZIndexSystem extends BaseSystem {\n  readonly requiredComponents = [\n    ZIndexComponentType,\n    GridPositionComponentType,\n    VisualComponentType\n  ];\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage) return;\n\n    // Sort entities by their Z-index\n    const sortedEntities = [...entities].sort((a, b) => {\n      const aZIndex = this.getEntityZIndex(a);\n      const bZIndex = this.getEntityZIndex(b);\n      return aZIndex - bZIndex;\n    });\n\n    // Update display object z-index (which is determined by the order in the container's children array)\n    sortedEntities.forEach(entity => {\n      const visual = entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual?.container) {\n        // Remove and re-add to update position in children array\n        const parent = visual.container.parent;\n        if (parent) {\n          parent.removeChild(visual.container);\n          parent.addChild(visual.container);\n        }\n      }\n    });\n  }\n\n  private getEntityZIndex(entity: Entity): number {\n    const zIndex = entity.getComponent<ZIndexComponent>(ZIndexComponentType);\n    const gridPos = entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n    \n    if (!zIndex || !gridPos) return 0;\n    return zIndex.calculateZ(gridPos);\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const CoinComponentType = Symbol('CoinComponent');\n\nexport class CoinComponent implements Component {\n  public readonly type = CoinComponentType;\n  public entity: Entity | null = null;\n} ","import { Component } from '../core/Component';\nimport { Entity } from '../core/Component';\n\nexport const CoinCounterComponentType = Symbol('CoinCounterComponent');\n\nexport class CoinCounterComponent implements Component {\n  public readonly type = CoinCounterComponentType;\n  public entity: Entity | null = null;\n  private count: number = 0;\n  private highscore: number = 0;\n\n  constructor() {\n    // Load highscore from localStorage\n    const savedHighscore = localStorage.getItem('coinHighscore');\n    if (savedHighscore) {\n      this.highscore = parseInt(savedHighscore, 10);\n    }\n  }\n\n  public increment(): void {\n    this.count++;\n    // Update highscore if current count is higher\n    if (this.count > this.highscore) {\n      this.highscore = this.count;\n      localStorage.setItem('coinHighscore', this.highscore.toString());\n    }\n  }\n\n  public getCount(): number {\n    return this.count;\n  }\n\n  public getHighscore(): number {\n    return this.highscore;\n  }\n\n  public reset(): void {\n    this.count = 0;\n  }\n} ","import { Component } from '../core/Component';\n\nexport const SpeedBoostComponentType = Symbol('SpeedBoostComponent');\n\nexport class SpeedBoostComponent implements Component {\n  readonly type = SpeedBoostComponentType;\n  entity: Component['entity'] = null;\n  private speedMultiplier: number = 1.0;\n  private readonly BOOST_PER_COIN = 0.1; // 10% speed increase per coin\n  private readonly MAX_MULTIPLIER = Infinity; // Maximum 2x speed\n\n  public addBoost(): void {\n    this.speedMultiplier = Math.min(this.speedMultiplier + this.BOOST_PER_COIN, this.MAX_MULTIPLIER);\n  }\n\n  public getSpeedMultiplier(): number {\n    return this.speedMultiplier;\n  }\n\n  public reset(): void {\n    this.speedMultiplier = 1.0;\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { BaseEntity } from '../core/BaseEntity';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { CoinComponent, CoinComponentType } from '../components/CoinComponent';\nimport { ZIndexComponent, ZIndexComponentType } from '../components/ZIndexComponent';\nimport { PlayerComponentType } from '../components/PlayerComponent';\nimport { GridService } from '../services/GridService';\nimport { GridOccupancyService, OccupancyType } from '../services/GridOccupancyService';\nimport { World, GameState } from '../core/World';\nimport { MovementSystem } from '../systems/MovementSystem';\nimport { CoinCounterComponent, CoinCounterComponentType } from '../components/CoinCounterComponent';\nimport { SpeedBoostComponent, SpeedBoostComponentType } from '../components/SpeedBoostComponent';\nimport { Application } from 'pixi.js';\n\nconst Z_INDEX = {\n  COIN: 50 // Between tiles and trees\n};\n\ninterface PooledCoin {\n  entity: Entity;\n  isInUse: boolean;\n  gridX: number;\n  gridY: number;\n}\n\n@injectable()\nexport class CoinSystem extends BaseSystem {\n  private readonly COIN_DENSITY = 0.01; // 1% chance of a coin on each tile\n  private readonly VISIBLE_RADIUS = 12; // Match GridRenderSystem's visible radius\n  private readonly POOL_SIZE = 50; // Maximum number of coins that can exist at once\n  \n  private coinPool: PooledCoin[] = [];\n  private activeCoinPositions: Map<string, PooledCoin> = new Map();\n\n  readonly requiredComponents = [\n    GridPositionComponentType,\n    CoinComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService,\n    @inject(GridOccupancyService) private gridOccupancyService: GridOccupancyService\n  ) {\n    super();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n    // Listen for tile creation events\n    this.world.on('tileCreated', (data: { gridX: number, gridY: number }) => {\n      this.trySpawnCoinAt(data.gridX, data.gridY);\n    });\n\n    // Initialize coin pool if app is already set\n    if (this.app) {\n      this.initializeCoinPool();\n    }\n  }\n\n  public setApp(app: Application): void {\n    this.app = app;\n  }\n\n  private initializeCoinPool(): void {\n    if (!this.world || !this.app?.stage) return;\n    \n    for (let i = 0; i < this.POOL_SIZE; i++) {\n      const coin = new BaseEntity();\n      const transform = new TransformComponent(0, 0);\n      const gridPos = new GridPositionComponent(0, 0);\n      const visual = new VisualComponent({\n        spritePath: '/coin.png',\n      });\n      const coinComponent = new CoinComponent();\n      const zIndex = new ZIndexComponent(Z_INDEX.COIN);\n\n      coin.addComponent(transform);\n      coin.addComponent(gridPos);\n      coin.addComponent(visual);\n      coin.addComponent(coinComponent);\n      coin.addComponent(zIndex);\n\n      this.world.addEntity(coin);\n      // Add to world container instead of stage\n      const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n      if (movementSystem && movementSystem.worldContainer) {\n        movementSystem.worldContainer.addChild(visual.container);\n      }\n      visual.container.visible = false;\n\n      this.coinPool.push({\n        entity: coin,\n        isInUse: false,\n        gridX: 0,\n        gridY: 0\n      });\n    }\n  }\n\n  private removeCoin(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    const coin = this.activeCoinPositions.get(key);\n    \n    if (coin) {\n      const visual = coin.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual) {\n        visual.container.visible = false;\n      }\n      \n      // Mark the coin as not in use in the pool\n      coin.isInUse = false;\n      coin.gridX = 0;\n      coin.gridY = 0;\n      \n      this.gridOccupancyService.free(gridX, gridY, OccupancyType.Coin);\n      this.activeCoinPositions.delete(key);\n    }\n  }\n\n  public spawnCoin(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    if (this.activeCoinPositions.has(key)) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    // Find an unused coin from the pool\n    const unusedCoinIndex = this.coinPool.findIndex(coin => !coin.isInUse);\n    if (unusedCoinIndex === -1) {\n      console.warn('[CoinSystem] Coin pool exhausted. Active coins:', this.activeCoinPositions.size);\n      return;\n    }\n\n    const unusedCoin = this.coinPool[unusedCoinIndex];\n    const worldPos = this.gridService.gridToWorld(gridX, gridY);\n    \n    // Update the coin's components\n    const transform = unusedCoin.entity.getComponent<TransformComponent>(TransformComponentType);\n    const gridPos = unusedCoin.entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n    const visual = unusedCoin.entity.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (!transform || !gridPos || !visual) {\n      console.warn('[CoinSystem] Missing required components for coin');\n      return;\n    }\n\n    // Get the movement system and world container\n    const movementSystem = this.world?.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      console.warn('[CoinSystem] Movement system or world container not ready');\n      return;\n    }\n\n    // Update transform and position\n    transform.x = worldPos.x;\n    transform.y = worldPos.y;\n    gridPos.gridX = gridX;\n    gridPos.gridY = gridY;\n    visual.container.visible = true;\n    visual.container.position.set(transform.x, transform.y);\n\n    // Ensure the visual container is in the world container\n    if (!visual.container.parent) {\n      movementSystem.worldContainer.addChild(visual.container);\n    }\n\n    // Mark the coin as in use in the pool\n    unusedCoin.isInUse = true;\n    unusedCoin.gridX = gridX;\n    unusedCoin.gridY = gridY;\n    \n    this.activeCoinPositions.set(key, unusedCoin);\n    this.gridOccupancyService.occupy(gridX, gridY, OccupancyType.Coin);\n  }\n\n  public trySpawnCoinAt(gridX: number, gridY: number): void {\n    if (!this.world) return;\n    if (this.world.getCurrentState() !== GameState.Playing) return;\n\n    const distanceFromStart = Math.abs(gridX) + Math.abs(gridY);\n    \n    if (distanceFromStart < 20) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    const roll = Math.random();\n    if (roll < this.COIN_DENSITY) {\n      this.spawnCoin(gridX, gridY);\n    }\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.GameOver) {\n      this.reset();\n    } else if (newState === GameState.Starting) {\n      this.initialize();\n    }\n  }\n\n  public initialize(): void {\n    if (!this.world || !this.app?.stage) {\n      return;\n    }\n  }\n\n  public reset(): void {\n    // First remove all active coins from the stage and grid\n    for (const [key, coin] of this.activeCoinPositions.entries()) {\n      const visual = coin.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual && visual.container.parent) {\n        visual.container.parent.removeChild(visual.container);\n      }\n      if (this.world) {\n        this.world.removeEntity(coin.entity);\n      }\n      this.gridOccupancyService.free(coin.gridX, coin.gridY, OccupancyType.Coin);\n    }\n\n    // Clear active positions map\n    this.activeCoinPositions.clear();\n\n    // Clean up the pool\n    for (const coin of this.coinPool) {\n      if (this.world) {\n        this.world.removeEntity(coin.entity);\n      }\n    }\n    this.coinPool = [];\n\n    // Reinitialize the pool\n    if (this.app && this.world) {\n      this.initializeCoinPool();\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage || !this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      return;\n    }\n\n    // Update positions of all coins\n    for (const coin of this.activeCoinPositions.values()) {\n      this.updateCoinPosition(coin.entity);\n    }\n\n    // Check for collisions with players\n    const players = this.world.getEntities().filter(entity => \n      entity.hasComponent(PlayerComponentType) &&\n      entity.hasComponent(GridPositionComponentType)\n    );\n\n    for (const player of players) {\n      const playerGridPos = player.getComponent<GridPositionComponent>(GridPositionComponentType);\n      if (playerGridPos) {\n        // First check grid occupancy service\n        if (this.gridOccupancyService.isOccupied(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Coin)) {\n          // Verify against active coins to ensure the coin still exists\n          const key = `${playerGridPos.gridX},${playerGridPos.gridY}`;\n          if (this.activeCoinPositions.has(key)) {\n            const coin = this.activeCoinPositions.get(key);\n            if (coin) {\n              this.handleCoinCollection(coin.entity);\n              this.removeCoin(playerGridPos.gridX, playerGridPos.gridY);\n            }\n          } else {\n            // If we found an occupancy but no active coin, clean up the occupancy\n            this.gridOccupancyService.free(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Coin);\n          }\n        }\n      }\n    }\n\n    // Clean up coins that are too far from the center\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n\n    const centerWorldX = -worldContainerPos.x;\n    const centerWorldY = -worldContainerPos.y;\n\n    const worldPos = this.gridService.worldToGrid(centerWorldX, centerWorldY);\n    const gridCenterX = Math.floor(worldPos.x);\n    const gridCenterY = Math.floor(worldPos.y);\n\n    // Remove coins that are too far from view\n    for (const [key, coin] of this.activeCoinPositions.entries()) {\n      const distance = Math.abs(coin.gridX - gridCenterX) + Math.abs(coin.gridY - gridCenterY);\n      if (distance > this.VISIBLE_RADIUS * 1.5) {\n        this.removeCoin(coin.gridX, coin.gridY);\n      }\n    }\n  }\n\n  private updateCoinPosition(coin: Entity): void {\n    const transform = coin.getComponent<TransformComponent>(TransformComponentType);\n    const visual = coin.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (transform && visual) {\n      visual.container.position.set(transform.x, transform.y);\n    }\n  }\n\n  private handleCoinCollection(coinEntity: Entity): void {\n    // Find the coin counter entity\n    const entities = this.world?.getEntities() || [];\n    const counterEntity = entities.find(entity => entity.hasComponent(CoinCounterComponentType));\n    \n    if (counterEntity) {\n      const counter = counterEntity.getComponent<CoinCounterComponent>(CoinCounterComponentType);\n      if (counter) {\n        counter.increment();\n      }\n    }\n\n    // Add speed boost to the player\n    const player = entities.find(entity => entity.hasComponent(PlayerComponentType));\n    if (player) {\n      const speedBoost = player.getComponent<SpeedBoostComponent>(SpeedBoostComponentType);\n      if (speedBoost) {\n        speedBoost.addBoost();\n      }\n    }\n\n    // Remove the coin from the pool and world\n    const poolItem = this.coinPool.find(item => item.entity === coinEntity);\n    if (poolItem) {\n      poolItem.isInUse = false;\n      const visual = coinEntity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual) {\n        visual.container.visible = false;\n      }\n    }\n  }\n} ","import { Component } from '../core/Component';\nimport { Container, Text, TextStyle, TextStyleAlign } from 'pixi.js';\nimport { Entity } from '../core/Component';\n\nexport const UIComponentType = Symbol('UIComponent');\n\nexport interface UIConfig {\n  text?: string;\n  x?: number;\n  y?: number;\n  style?: Partial<TextStyle>;\n  align?: TextStyleAlign;\n}\n\nexport class UIComponent implements Component {\n  public readonly type = UIComponentType;\n  public container: Container;\n  public text: Text;\n  public entity: Entity | null = null;\n\n  constructor(config: UIConfig = {}) {\n    this.container = new Container();\n    \n    // Create text with default style\n    const style: Partial<TextStyle> = {\n      fontFamily: 'Arial',\n      fontSize: 24,\n      fill: 0xFFFFFF,\n      stroke: {\n        color: 0x000000,\n        width: 4\n      },\n      align: 'center',\n      ...config.style\n    };\n\n    // Use new Text constructor syntax for PixiJS v8\n    this.text = new Text({\n      text: config.text || '',\n      style\n    });\n    this.container.addChild(this.text);\n\n    // Set position if provided\n    if (config.x !== undefined) this.container.x = config.x;\n    if (config.y !== undefined) this.container.y = config.y;\n\n    // Center the text within its container\n    this.text.anchor.set(0.5);\n  }\n\n  public setText(text: string): void {\n    this.text.text = text;\n  }\n\n  public setPosition(x: number, y: number): void {\n    this.container.x = x;\n    this.container.y = y;\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { UIComponent, UIComponentType } from '../components/UIComponent';\nimport { Application, Container } from 'pixi.js';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\n\n@injectable()\nexport class UIRenderSystem extends BaseSystem {\n  private uiContainer: Container;\n  readonly requiredComponents = [UIComponentType];\n\n  constructor() {\n    super();\n    this.uiContainer = new Container();\n    // Set a very high z-index to ensure UI is always on top\n    this.uiContainer.zIndex = 10000;\n  }\n\n  public setApp(app: Application): void {\n    super.setApp(app);\n    if (app) {\n      app.stage.addChild(this.uiContainer);\n    }\n  }\n\n  public cleanup(): void {\n    if (this.uiContainer && this.app) {\n      this.app.stage.removeChild(this.uiContainer);\n      this.uiContainer.destroy();\n      this.uiContainer = new Container();\n      this.uiContainer.zIndex = 10000;\n    }\n  }\n\n  public reinitialize(): void {\n    this.cleanup();\n    if (this.app) {\n      this.app.stage.addChild(this.uiContainer);\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app) return;\n\n    for (const entity of entities) {\n      const ui = entity.getComponent<UIComponent>(UIComponentType);\n      if (ui && !this.uiContainer.children.includes(ui.container)) {\n        this.uiContainer.addChild(ui.container);\n      }\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { CoinCounterComponent, CoinCounterComponentType } from '../components/CoinCounterComponent';\nimport { UIComponent, UIComponentType } from '../components/UIComponent';\nimport { GameState } from '../core/World';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\n\n@injectable()\nexport class CoinCounterSystem extends BaseSystem {\n  readonly requiredComponents = [CoinCounterComponentType, UIComponentType];\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    for (const entity of entities) {\n      const counter = entity.getComponent<CoinCounterComponent>(CoinCounterComponentType);\n      const ui = entity.getComponent<UIComponent>(UIComponentType);\n      \n      if (counter && ui) {\n        const newText = `Coins: ${counter.getCount()} (High: ${counter.getHighscore()})`;\n        if (ui.text.text !== newText) {\n          ui.setText(newText);\n        }\n        // Ensure proper z-index\n        ui.container.zIndex = ZIndexComponent.UI.COIN_COUNTER;\n      }\n    }\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.Starting) {\n      // Reset counter when game restarts\n      const entities = this.world?.getEntities() || [];\n      for (const entity of entities) {\n        const counter = entity.getComponent<CoinCounterComponent>(CoinCounterComponentType);\n        if (counter) {\n          counter.reset();\n          // Force UI update after reset\n          const ui = entity.getComponent<UIComponent>(UIComponentType);\n          if (ui) {\n            ui.setText(`Coins: ${counter.getCount()} (High: ${counter.getHighscore()})`);\n            // Ensure proper z-index\n            ui.container.zIndex = ZIndexComponent.UI.COIN_COUNTER;\n          }\n        }\n      }\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { ParticleComponent, ParticleComponentType, ParticleData } from '../components/ParticleComponent';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { World, GameState } from '../core/World';\nimport { Application, Graphics } from 'pixi.js';\nimport { MovementSystem } from './MovementSystem';\n\n@injectable()\nexport class ParticleSystem extends BaseSystem {\n  private readonly PARTICLE_LIFETIME = 1; // seconds\n  private readonly PARTICLE_SPAWN_RATE = 0.05; // seconds - more frequent spawning\n  private readonly PARTICLE_SIZE = 4; // Increased size\n  private readonly PARTICLE_COLOR = 0x777777;\n  private readonly PARTICLE_ALPHA = 0.5; // Increased alpha\n  private readonly PARTICLE_INITIAL_SPEED = 300; // Increased initial speed\n  private readonly PARTICLE_DRAG = 0.98; // Reduced drag for longer trails\n\n  private particleContainer: Graphics | null = null;\n  private timeSinceLastSpawn: number = 0;\n\n  readonly requiredComponents = [\n    ParticleComponentType,\n    TransformComponentType,\n    VisualComponentType\n  ];\n\n  constructor() {\n    super();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n  }\n\n  public setApp(app: Application): void {\n    super.setApp(app);\n    this.initializeParticleContainer();\n  }\n\n  private initializeParticleContainer(): void {\n    if (!this.app?.stage) return;\n    \n    // Clean up existing container if it exists\n    if (this.particleContainer) {\n      this.particleContainer.destroy();\n      this.particleContainer = null;\n    }\n\n    // Create new container\n    this.particleContainer = new Graphics();\n    \n    // Add to world container instead of stage\n    const movementSystem = this.world?.getSystem<MovementSystem>(MovementSystem);\n    if (movementSystem?.worldContainer) {\n      movementSystem.worldContainer.addChild(this.particleContainer);\n    }\n  }\n\n  public cleanup(): void {\n    if (this.particleContainer) {\n      this.particleContainer.destroy();\n      this.particleContainer = null;\n    }\n  }\n\n  public reinitialize(): void {\n    this.cleanup();\n    this.initializeParticleContainer();\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app || !this.particleContainer) return;\n\n    // Clear previous frame's particles\n    this.particleContainer.clear();\n\n    for (const entity of entities) {\n      const particleComponent = entity.getComponent<ParticleComponent>(ParticleComponentType);\n      if (particleComponent) {\n        const transform = entity.getComponent<TransformComponent>(TransformComponentType);\n        if (transform && particleComponent.isActive) {\n          // Spawn new particles\n          this.timeSinceLastSpawn += deltaTime;\n          if (this.timeSinceLastSpawn >= this.PARTICLE_SPAWN_RATE) {\n            this.spawnParticles(particleComponent, transform);\n            this.timeSinceLastSpawn = 0;\n          }\n        }\n        this.updateParticles(particleComponent, deltaTime);\n      }\n    }\n  }\n\n  private updateParticles(particleComponent: ParticleComponent, deltaTime: number): void {\n    const transform = particleComponent.entity?.getComponent<TransformComponent>(TransformComponentType);\n    if (!transform || !this.particleContainer) return;\n\n    // Update and draw each particle\n    for (let i = particleComponent.particles.length - 1; i >= 0; i--) {\n      const particle = particleComponent.particles[i];\n      particle.lifetime -= deltaTime;\n\n      if (particle.lifetime <= 0) {\n        particleComponent.particles.splice(i, 1);\n        continue;\n      }\n\n      // Update position\n      const progress = 1 - (particle.lifetime / this.PARTICLE_LIFETIME);\n      const alpha = this.PARTICLE_ALPHA * (1 - progress);\n      const size = particle.size * (1 - progress);\n      \n      // Calculate world position\n      const worldX = transform.x + particle.velocityX * progress;\n      const worldY = transform.y + particle.velocityY * progress;\n      \n      // Draw particle using new v8 API\n      this.particleContainer\n        .circle(worldX, worldY, size)\n        .fill({ color: particle.color, alpha: alpha });\n    }\n  }\n\n  private spawnParticles(particleComponent: ParticleComponent, transform: TransformComponent): void {\n    // Spawn particles in the opposite direction of movement\n    const direction = particleComponent.lastDirection;\n    const angle = Math.atan2(direction.y, direction.x);\n    \n    // Spawn 2-3 particles\n    const count = Math.floor(Math.random() * 2) + 2;\n    \n    for (let i = 0; i < count; i++) {\n      const spread = (Math.random() - 0.5) * Math.PI / 4; // Random spread\n      const particleAngle = angle + Math.PI + spread;\n      \n      const particle: ParticleData = {\n        color: this.PARTICLE_COLOR,\n        size: this.PARTICLE_SIZE,\n        lifetime: this.PARTICLE_LIFETIME,\n        alpha: this.PARTICLE_ALPHA,\n        velocityX: Math.cos(particleAngle) * this.PARTICLE_INITIAL_SPEED,\n        velocityY: Math.sin(particleAngle) * this.PARTICLE_INITIAL_SPEED\n      };\n      \n      particleComponent.particles.push(particle);\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { SpeedBoostComponent, SpeedBoostComponentType } from '../components/SpeedBoostComponent';\nimport { IsometricMovementComponent, IsometricMovementComponentType } from '../components/IsometricMovementComponent';\nimport { World, GameState } from '../core/World';\n\n@injectable()\nexport class SpeedBoostSystem extends BaseSystem {\n  readonly requiredComponents = [\n    SpeedBoostComponentType,\n    IsometricMovementComponentType\n  ];\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    for (const entity of entities) {\n      const speedBoost = entity.getComponent<SpeedBoostComponent>(SpeedBoostComponentType);\n      const movement = entity.getComponent<IsometricMovementComponent>(IsometricMovementComponentType);\n      \n      if (speedBoost && movement) {\n        // Apply the speed multiplier to the movement speed\n        movement.speed = movement.baseSpeed * speedBoost.getSpeedMultiplier();\n      }\n    }\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.Starting) {\n      // Reset speed boosts when game restarts\n      const entities = this.world?.getEntities() || [];\n      for (const entity of entities) {\n        const speedBoost = entity.getComponent<SpeedBoostComponent>(SpeedBoostComponentType);\n        if (speedBoost) {\n          speedBoost.reset();\n        }\n      }\n    }\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Application, Sprite, Assets } from 'pixi.js';\nimport { GridService } from '../services/GridService';\nimport { World, GameState } from '../core/World';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\n\n@injectable()\nexport class VignetteSystem extends BaseSystem {\n  private vignetteSprite: Sprite | null = null;\n  readonly requiredComponents: symbol[] = []; // No required components for this system\n\n  constructor(\n    @inject(GridService) private gridService: GridService\n  ) {\n    super();\n  }\n\n  public setApp(app: Application): void {\n    this.app = app;\n    this.initializeVignette();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.Starting || newState === GameState.Playing) {\n      this.initializeVignette();\n      this.updateVignetteScale();\n    }\n  }\n\n  private initializeVignette(): void {\n    if (!this.app || !this.world) {\n      console.log('[VignetteSystem] Waiting for app and world to be ready');\n      return;\n    }\n\n    console.log('[VignetteSystem] Initializing vignette');\n    \n    // Remove old vignette if it exists\n    if (this.vignetteSprite && this.vignetteSprite.parent) {\n      this.vignetteSprite.parent.removeChild(this.vignetteSprite);\n    }\n    \n    // Create vignette sprite\n    const texture = Assets.get('/vignette3.png');\n    this.vignetteSprite = new Sprite(texture);\n    \n    // Center the sprite\n    this.vignetteSprite.anchor.set(0.5);\n    \n    // Set z-index\n    this.vignetteSprite.zIndex = ZIndexComponent.UI.VIGNETTE;\n    \n    // Make it invisible until properly scaled\n    this.vignetteSprite.visible = false;\n    \n    // Add to stage\n    this.app.stage.addChild(this.vignetteSprite);\n    console.log('[VignetteSystem] Added vignette to stage');\n  }\n\n  private updateVignetteScale(): void {\n    if (!this.app || !this.vignetteSprite || !this.world) return;\n\n    // Calculate visible area based on grid dimensions\n    const { width: tileWidth, height: tileHeight } = this.gridService.getTileDimensions();\n    const visibleRadius = 10; // Match GridRenderSystem's visible radius\n    \n    // Calculate the actual visible area in world coordinates\n    const visibleWidth = tileWidth * visibleRadius * 2;\n    const visibleHeight = tileHeight * visibleRadius * 2;\n    \n    // Scale to match the visible grid area exactly\n    const scale = Math.max(visibleWidth, visibleHeight) / 512;\n    \n    this.vignetteSprite.scale.set(scale);\n    this.vignetteSprite.visible = true;\n  }\n\n  protected updateRelevantEntities(entities: any[], deltaTime: number): void {\n    // Update scale whenever we have a vignette and the world is ready\n    if (this.vignetteSprite && this.world && this.app && this.gridService) {\n      this.updateVignetteScale();\n    }\n  }\n} ","import { Application, Assets } from 'pixi.js';\nimport { injectable, inject } from 'inversify';\nimport { World, GameState } from './World';\nimport { MovementSystem } from '../systems/MovementSystem';\nimport { InputSystem } from '../systems/InputSystem';\nimport { GridRenderSystem } from '../systems/GridRenderSystem';\nimport { TreeSystem } from '../systems/TreeSystem';\nimport { ZIndexSystem } from '../systems/ZIndexSystem';\nimport { CoinSystem } from '../systems/CoinSystem';\nimport { BaseEntity } from './BaseEntity';\nimport { TransformComponent } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { IsometricMovementComponent, Direction } from '../components/IsometricMovementComponent';\nimport { GridPositionComponent } from '../components/GridPositionComponent';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\nimport { PlayerComponent } from '../components/PlayerComponent';\nimport { GridOccupancyService } from '../services/GridOccupancyService';\nimport { UIRenderSystem } from '../systems/UIRenderSystem';\nimport { CoinCounterSystem } from '../systems/CoinCounterSystem';\nimport { UIComponent, UIComponentType } from '../components/UIComponent';\nimport { CoinCounterComponent } from '../components/CoinCounterComponent';\nimport { ParticleSystem } from '../systems/ParticleSystem';\nimport { ParticleComponent } from '../components/ParticleComponent';\nimport { SpeedBoostComponent } from '../components/SpeedBoostComponent';\nimport { SpeedBoostSystem } from '../systems/SpeedBoostSystem';\nimport { VignetteSystem } from '../systems/VignetteSystem';\n\n// Z-index base values for different entity types\nconst Z_INDEX = {\n  TILE: 0,\n  TREE: 100,\n  CHARACTER: 200\n};\n\n@injectable()\nexport class Game {\n  private app!: Application;\n  private world: World;\n  private lastTime: number;\n  private readonly TILE_WIDTH = 128;\n  private readonly TILE_HEIGHT = 64;\n  private character: BaseEntity | null = null;\n  private gridOccupancyService: GridOccupancyService | null = null;\n  private coinCounter: BaseEntity | null = null;\n\n  constructor(\n    @inject(World) worldFactory: () => World,\n    @inject(MovementSystem) private movementSystem: MovementSystem,\n    @inject(InputSystem) private inputSystem: InputSystem,\n    @inject(GridRenderSystem) private gridRenderSystem: GridRenderSystem,\n    @inject(TreeSystem) private treeSystem: TreeSystem,\n    @inject(ZIndexSystem) private zIndexSystem: ZIndexSystem,\n    @inject(CoinSystem) private coinSystem: CoinSystem,\n    @inject(UIRenderSystem) private uiRenderSystem: UIRenderSystem,\n    @inject(CoinCounterSystem) private coinCounterSystem: CoinCounterSystem,\n    @inject(ParticleSystem) private particleSystem: ParticleSystem,\n    @inject(SpeedBoostSystem) private speedBoostSystem: SpeedBoostSystem,\n    @inject(VignetteSystem) private vignetteSystem: VignetteSystem\n  ) {\n    this.world = worldFactory();\n    this.world.addSystem(gridRenderSystem);\n    this.world.addSystem(movementSystem);\n    this.world.addSystem(inputSystem);\n    this.world.addSystem(treeSystem);\n    this.world.addSystem(zIndexSystem);\n    this.world.addSystem(coinSystem);\n    this.world.addSystem(uiRenderSystem);\n    this.world.addSystem(coinCounterSystem);\n    this.world.addSystem(particleSystem);\n    this.world.addSystem(speedBoostSystem);\n    this.world.addSystem(vignetteSystem);\n    this.lastTime = performance.now();\n    this.gameLoop = this.gameLoop.bind(this);\n\n    // Listen for game over event\n    this.world.on('gameOver', () => {\n      setTimeout(() => {\n        this.restart();\n      }, 1000);\n    });\n\n    // Listen for character creation events\n    this.world.on('createCharacter', () => {\n      this.createCharacter();\n    });\n  }\n\n  private async initializeSystems(): Promise<void> {\n    // Get fresh instances of all systems from the container\n    const container = this.world.container;\n    this.movementSystem = container.get<MovementSystem>(MovementSystem);\n    this.inputSystem = container.get<InputSystem>(InputSystem);\n    this.gridRenderSystem = container.get<GridRenderSystem>(GridRenderSystem);\n    this.treeSystem = container.get<TreeSystem>(TreeSystem);\n    this.zIndexSystem = container.get<ZIndexSystem>(ZIndexSystem);\n    this.coinSystem = container.get<CoinSystem>(CoinSystem);\n    this.uiRenderSystem = container.get<UIRenderSystem>(UIRenderSystem);\n    this.coinCounterSystem = container.get<CoinCounterSystem>(CoinCounterSystem);\n    this.particleSystem = container.get<ParticleSystem>(ParticleSystem);\n    this.speedBoostSystem = container.get<SpeedBoostSystem>(SpeedBoostSystem);\n    this.vignetteSystem = container.get<VignetteSystem>(VignetteSystem);\n\n    // Get a new world instance using the factory\n    const worldFactory = container.get<() => World>(World);\n    this.world = worldFactory();\n\n    // Set up app references first\n    this.movementSystem.setApp(this.app);\n    this.inputSystem.setApp(this.app);\n    this.gridRenderSystem.setApp(this.app);\n    this.treeSystem.setApp(this.app);\n    this.zIndexSystem.setApp(this.app);\n    this.coinSystem.setApp(this.app);\n    this.uiRenderSystem.setApp(this.app);\n    this.particleSystem.setApp(this.app);\n    this.speedBoostSystem.setApp(this.app);\n    this.vignetteSystem.setApp(this.app);\n\n    // Then set up the world references\n    this.treeSystem.setWorld(this.world);\n    this.coinSystem.setWorld(this.world);\n    this.coinCounterSystem.setWorld(this.world);\n    this.particleSystem.setWorld(this.world);\n    this.speedBoostSystem.setWorld(this.world);\n    this.vignetteSystem.setWorld(this.world);\n\n    // Finally add systems to the world\n    this.world.addSystem(this.gridRenderSystem);\n    this.world.addSystem(this.movementSystem);\n    this.world.addSystem(this.inputSystem);\n    this.world.addSystem(this.treeSystem);\n    this.world.addSystem(this.zIndexSystem);\n    this.world.addSystem(this.coinSystem);\n    this.world.addSystem(this.uiRenderSystem);\n    this.world.addSystem(this.coinCounterSystem);\n    this.world.addSystem(this.particleSystem);\n    this.world.addSystem(this.speedBoostSystem);\n    this.world.addSystem(this.vignetteSystem);\n\n    // Reinitialize all systems\n    this.movementSystem.reinitialize();\n    this.inputSystem.reinitialize();\n    this.gridRenderSystem.reinitialize();\n    this.treeSystem.reinitialize();\n    this.zIndexSystem.reinitialize();\n    this.coinSystem.reinitialize();\n    this.uiRenderSystem.reinitialize();\n    this.coinCounterSystem.reinitialize();\n    this.particleSystem.reinitialize();\n    this.speedBoostSystem.reinitialize();\n    this.vignetteSystem.reinitialize();\n\n    // Set up event listeners\n    this.world.on('gameOver', () => {\n      setTimeout(() => {\n        this.restart();\n      }, 1000);\n    });\n\n    // Create initial entities\n    this.createCharacter();\n    this.createCoinCounter();\n\n    // Start the game\n    this.world.setGameState(GameState.Starting);\n  }\n\n  public async start(): Promise<void> {\n    // Clean up any existing app instance\n    if (this.app) {\n      this.app.destroy(true);\n    }\n\n    // Calculate target resolution (720p)\n    const targetWidth = 1280;\n    const targetHeight = 720;\n\n    // Calculate scale to fit the window while maintaining aspect ratio\n    const scale = Math.min(\n      window.innerWidth / targetWidth,\n      window.innerHeight / targetHeight\n    );\n\n    // Calculate actual dimensions\n    const width = Math.floor(targetWidth * scale);\n    const height = Math.floor(targetHeight * scale);\n\n    this.app = new Application();\n    await this.app.init({\n      width,\n      height,\n      backgroundColor: 0xffffff, // Sky blue background\n      resolution: Math.min(window.devicePixelRatio || 1, 2), // Cap resolution at 2x\n      autoDensity: true, // Enable auto density for crisp rendering\n      resizeTo: window, // Make canvas resize to window\n    });\n\n    // Remove any existing canvas\n    const existingCanvas = document.querySelector('canvas');\n    if (existingCanvas) {\n      existingCanvas.remove();\n    }\n\n    document.body.appendChild(this.app.canvas);\n\n    // Load assets first\n    await Assets.load([\n      '/character.png',\n      '/tree.png',\n      '/coin.png',\n      '/vignette.png',\n      '/vignette2.png',\n      '/vignette3.png'\n    ]);\n\n    // Reset stage position to center\n    this.app.stage.position.set(\n      this.app.screen.width / 2,\n      this.app.screen.height / 2\n    );\n\n    // Initialize systems and start the game\n    await this.initializeSystems();\n\n    // Start the game loop\n    this.app.ticker.add(this.gameLoop);\n\n    // Add window resize handler\n    window.addEventListener('resize', () => {\n      const newScale = Math.min(\n        window.innerWidth / targetWidth,\n        window.innerHeight / targetHeight\n      );\n      const newWidth = Math.floor(targetWidth * newScale);\n      const newHeight = Math.floor(targetHeight * newScale);\n      \n      this.app.renderer.resize(newWidth, newHeight);\n      this.app.stage.position.set(\n        this.app.screen.width / 2,\n        this.app.screen.height / 2\n      );\n    });\n  }\n\n  private async createCharacter(): Promise<void> {\n    // Remove old character if it exists\n    if (this.character) {\n      const visual = this.character.getComponent<VisualComponent>(VisualComponentType);\n      if (visual && visual.container.parent) {\n        visual.container.parent.removeChild(visual.container);\n      }\n      this.world.removeEntity(this.character);\n    }\n\n    // Create new character\n    this.character = new BaseEntity();\n    \n    // Calculate initial world position from grid position (0,0)\n    const initialGridPos = { x: 0, y: 0 };\n    const worldPos = this.gridToWorld(initialGridPos.x, initialGridPos.y);\n    const gridPos = new GridPositionComponent(initialGridPos.x, initialGridPos.y);\n\n    // Set transform to the world position\n    const transform = new TransformComponent(worldPos.x, worldPos.y);\n    const visual = new VisualComponent({ spritePath: '/character.png' });\n    const movement = new IsometricMovementComponent(150);\n    movement.targetDirection = Direction.DownRight; // Start moving down-right\n    const zIndex = new ZIndexComponent(Z_INDEX.CHARACTER);\n    const player = new PlayerComponent();\n    const particle = new ParticleComponent();\n    const speedBoost = new SpeedBoostComponent();\n\n    this.character.addComponent(gridPos);\n    this.character.addComponent(transform);\n    this.character.addComponent(visual);\n    this.character.addComponent(movement);\n    this.character.addComponent(zIndex);\n    this.character.addComponent(player);\n    this.character.addComponent(particle);\n    this.character.addComponent(speedBoost);\n    this.world.addEntity(this.character);\n\n    // Add the visual to the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (movementSystem && movementSystem.worldContainer) {\n      movementSystem.worldContainer.addChild(visual.container);\n    }\n    \n    // Set the visual position to match the transform\n    visual.container.position.set(worldPos.x, worldPos.y);\n  }\n\n  private createCoinCounter(): void {\n    // Remove old counter if it exists\n    if (this.coinCounter) {\n      const ui = this.coinCounter.getComponent<UIComponent>(UIComponentType);\n      if (ui && ui.container.parent) {\n        ui.container.parent.removeChild(ui.container);\n      }\n      this.world.removeEntity(this.coinCounter);\n    }\n\n    // Create new counter\n    this.coinCounter = new BaseEntity();\n    \n    const counter = new CoinCounterComponent();\n    const ui = new UIComponent({\n      text: 'Coins: 0',\n      style: {\n        fontSize: 32,\n        fill: 0xFFD700, // Gold color\n        stroke: {\n          color: 0x000000,\n          width: 4\n        }\n      }\n    });\n\n    this.coinCounter.addComponent(counter);\n    this.coinCounter.addComponent(ui);\n    this.world.addEntity(this.coinCounter);\n\n    // Position at top center of screen, accounting for centered stage\n    if (this.app) {\n      // Since stage is centered at (0,0), we need to position relative to that\n      ui.setPosition(0, -this.app.screen.height / 2 + 40);\n    }\n  }\n\n  private gridToWorld(gridX: number, gridY: number): { x: number, y: number } {\n    const isoX = (gridX - gridY) * (this.TILE_WIDTH / 2);\n    const isoY = (gridX + gridY) * (this.TILE_HEIGHT / 2);\n    return { x: isoX, y: isoY };\n  }\n\n  public async restart(): Promise<void> {\n    console.log('[Game] Starting game restart');\n\n    // Cleanup current world\n    this.world.cleanup();\n\n    // Clear the stage\n    while (this.app.stage.children.length > 0) {\n      const child = this.app.stage.children[0];\n      child.destroy();\n      this.app.stage.removeChild(child);\n    }\n\n    // Reset stage position\n    this.app.stage.position.set(\n      this.app.screen.width / 2,\n      this.app.screen.height / 2\n    );\n\n    // Initialize systems and start the game\n    await this.initializeSystems();\n  }\n\n  private gameLoop(): void {\n    const currentTime = performance.now();\n    const deltaTime = (currentTime - this.lastTime) / 1000;\n    this.lastTime = currentTime;\n\n    this.world.update(deltaTime);\n  }\n\n  public get pixiApp(): Application {\n    return this.app;\n  }\n} ","import { Container } from 'inversify';\nimport { World } from '../core/World';\nimport { Game } from '../core/Game';\nimport { MovementSystem } from '../systems/MovementSystem';\nimport { InputSystem } from '../systems/InputSystem';\nimport { GridRenderSystem } from '../systems/GridRenderSystem';\nimport { TreeSystem } from '../systems/TreeSystem';\nimport { ZIndexSystem } from '../systems/ZIndexSystem';\nimport { CoinSystem } from '../systems/CoinSystem';\nimport { GridService } from '../services/GridService';\nimport { GridOccupancyService } from '../services/GridOccupancyService';\nimport { UIRenderSystem } from '../systems/UIRenderSystem';\nimport { CoinCounterSystem } from '../systems/CoinCounterSystem';\nimport { ParticleSystem } from '../systems/ParticleSystem';\nimport { SpeedBoostSystem } from '../systems/SpeedBoostSystem';\nimport { VignetteSystem } from '../systems/VignetteSystem';\n\nexport function createContainer(): Container {\n  const container = new Container();\n\n  // Create a factory function for World that takes the container\n  const worldFactory = (c: Container) => {\n    return new World(c);\n  };\n\n  // Bind World as a factory to ensure fresh instances\n  container.bind<World>(World).toFactory<World>((context) => {\n    return () => worldFactory(container);\n  });\n\n  // Bind Game as a singleton\n  container.bind<Game>(Game).toSelf().inSingletonScope();\n\n  // Bind all systems as singletons\n  container.bind<MovementSystem>(MovementSystem).toSelf().inSingletonScope();\n  container.bind<InputSystem>(InputSystem).toSelf().inSingletonScope();\n  container.bind<GridRenderSystem>(GridRenderSystem).toSelf().inSingletonScope();\n  container.bind<TreeSystem>(TreeSystem).toSelf().inSingletonScope();\n  container.bind<ZIndexSystem>(ZIndexSystem).toSelf().inSingletonScope();\n  container.bind<CoinSystem>(CoinSystem).toSelf().inSingletonScope();\n  container.bind<UIRenderSystem>(UIRenderSystem).toSelf().inSingletonScope();\n  container.bind<CoinCounterSystem>(CoinCounterSystem).toSelf().inSingletonScope();\n  container.bind<ParticleSystem>(ParticleSystem).toSelf().inSingletonScope();\n  container.bind<SpeedBoostSystem>(SpeedBoostSystem).toSelf().inSingletonScope();\n  container.bind<VignetteSystem>(VignetteSystem).toSelf().inSingletonScope();\n\n  // Bind services as singletons\n  container.bind<GridService>(GridService).toSelf().inSingletonScope();\n  container.bind<GridOccupancyService>(GridOccupancyService).toSelf().inSingletonScope();\n\n  return container;\n} ","import 'reflect-metadata';\nimport { createContainer } from './di/container';\nimport { Game } from './core/Game';\n\n// Create container and get the game instance\nconst container = createContainer();\nconst game = container.get<Game>(Game);\n\n// Start the game\ngame.start(); "],"names":["EventEmitter","constructor","__publicField","this","Map","on","event","callback","events","has","set","get","push","emit","args","callbacks","forEach","off","index","indexOf","splice","length","delete","GameState","World","container","Set","_container","addSystem","system","systems","setWorld","addEntity","entity","entities","add","removeEntity","clearEntities","clear","getEntities","Array","from","getSystem","systemType","find","clearSystems","cleanup","reset","currentState","getCurrentState","setGameState","newState","oldState","setTimeout","update","deltaTime","__decorateClass","injectable","BaseSystem","setApp","app","world","onGameStateChanged","initialize","reinitialize","relevantEntities","filter","requiredComponents","every","hasComponent","componentType","updateRelevantEntities","TransformComponentType","Symbol","TransformComponent","x","y","rotation","VisualComponentType","VisualComponent","options","Container","spritePath","texture","Assets","sprite","Sprite","anchor","scale","Math","max","width","height","abs","addChild","graphics","Graphics","circle","radius","fill","color","flipX","IsometricMovementComponentType","Direction","IsometricMovementComponent","speed","baseSpeed","GridPositionComponentType","GridPositionComponent","gridX","gridY","targetGridX","targetGridY","isMoving","setTargetPosition","reachedTarget","GridService","gridToWorld","TILE_WIDTH","TILE_HEIGHT","worldToGrid","worldX","worldY","round","getTileDimensions","getNextGridPosition","currentX","currentY","direction","DownRight","DownLeft","TopRight","TopLeft","isValidGridPosition","ParticleComponentType","ParticleComponent","MovementSystem","gridService","super","initializeWorldContainer","worldContainer","stage","position","removeChild","destroy","transform","getComponent","movement","gridPos","visual","particleComponent","targetDirection","None","nextPosition","currentDirection","getDirectionVector","lastDirection","isActive","targetWorldPos","dx","dy","distance","sqrt","moveDistance","ratio","min","screenCenterX","screenCenterY","InputSystem","arguments","queuedDirectionChange","isMovingDownRight","needsFlip","canvas","addEventListener","handleTap","GridRenderSystem","gridContainer","GameOver","Starting","_a","initializeTilePool","movementSystem","addChildAt","tilePool","tile","updateVisibleTiles","isInitialized","key","activeTiles","recycleTile","lastCenterX","lastCenterY","i","POOL_SIZE","createTileGraphics","visible","isInUse","setFillStyle","alpha","moveTo","lineTo","setStrokeStyle","stroke","getTileKey","getFreeTile","placeTile","centerX","centerY","Playing","tileWorldPos","worldContainerPos","centerWorldX","centerWorldY","worldPos","gridCenterX","floor","gridCenterY","minX","VISIBLE_RADIUS","maxX","minY","maxY","neededTiles","__decorateParam","_BaseEntity","id","nextId","components","addComponent","component","type","removeComponent","BaseEntity","TreeComponentType","TreeComponent","ZIndexComponentType","ZIndexComponent","baseZ","calculateZ","VIGNETTE","COIN_COUNTER","PlayerComponentType","PlayerComponent","OccupancyType","GridOccupancyService","getKey","isOccupied","cell","occupiedCells","size","occupy","free","console","warn","getOccupancyTypes","Z_INDEX","TreeSystem","gridOccupancyService","data","trySpawnTreeAt","pendingTileEvents","initializeTreePool","tree","activeTreePositions","entries","parent","Tree","treePool","treeComponent","zIndex","processPendingTileEvents","removeTree","spawnTree","unusedTreeIndex","findIndex","unusedTree","random","TREE_DENSITY","_b","values","updateTreePosition","players","_c","player","playerGridPos","_d","ZIndexSystem","sort","a","b","getEntityZIndex","CoinComponentType","CoinComponent","CoinCounterComponentType","CoinCounterComponent","savedHighscore","localStorage","getItem","highscore","parseInt","increment","count","setItem","toString","getCount","getHighscore","SpeedBoostComponentType","SpeedBoostComponent","Infinity","addBoost","speedMultiplier","BOOST_PER_COIN","MAX_MULTIPLIER","getSpeedMultiplier","CoinSystem","trySpawnCoinAt","initializeCoinPool","coin","coinComponent","coinPool","removeCoin","activeCoinPositions","Coin","spawnCoin","unusedCoinIndex","unusedCoin","COIN_DENSITY","updateCoinPosition","handleCoinCollection","coinEntity","counterEntity","counter","speedBoost","poolItem","item","UIComponentType","UIComponent","config","style","fontFamily","fontSize","align","text","Text","setText","setPosition","UIRenderSystem","uiContainer","ui","children","includes","CoinCounterSystem","newText","UI","ParticleSystem","initializeParticleContainer","particleContainer","timeSinceLastSpawn","PARTICLE_SPAWN_RATE","spawnParticles","updateParticles","particles","particle","lifetime","progress","PARTICLE_LIFETIME","PARTICLE_ALPHA","velocityX","velocityY","angle","atan2","spread","PI","particleAngle","PARTICLE_COLOR","PARTICLE_SIZE","cos","PARTICLE_INITIAL_SPEED","sin","SpeedBoostSystem","VignetteSystem","initializeVignette","updateVignetteScale","log","vignetteSprite","tileWidth","tileHeight","visibleWidth","visibleHeight","Game","worldFactory","inputSystem","gridRenderSystem","treeSystem","zIndexSystem","coinSystem","uiRenderSystem","coinCounterSystem","particleSystem","speedBoostSystem","vignetteSystem","lastTime","performance","now","gameLoop","bind","restart","createCharacter","initializeSystems","createCoinCounter","start","targetWidth","targetHeight","window","innerWidth","innerHeight","Application","init","backgroundColor","resolution","devicePixelRatio","autoDensity","resizeTo","existingCanvas","document","querySelector","remove","body","appendChild","load","screen","ticker","newScale","newWidth","newHeight","renderer","resize","character","initialGridPos","coinCounter","child","currentTime","pixiApp","toFactory","context","toSelf","inSingletonScope","createContainer"],"mappings":"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"}