{"version":3,"file":"index-84a76f63.js","sources":["../../src/core/EventEmitter.ts","../../src/core/World.ts","../../src/core/System.ts","../../src/components/TransformComponent.ts","../../src/components/VisualComponent.ts","../../src/components/IsometricMovementComponent.ts","../../src/components/GridPositionComponent.ts","../../src/services/GridService.ts","../../src/components/ParticleComponent.ts","../../src/systems/MovementSystem.ts","../../src/systems/InputSystem.ts","../../src/systems/GridRenderSystem.ts","../../src/core/BaseEntity.ts","../../src/components/TreeComponent.ts","../../src/components/ZIndexComponent.ts","../../src/components/PlayerComponent.ts","../../src/services/GridOccupancyService.ts","../../src/systems/TreeSystem.ts","../../src/systems/ZIndexSystem.ts","../../src/components/CoinComponent.ts","../../src/components/CoinCounterComponent.ts","../../src/components/SpeedBoostComponent.ts","../../src/systems/CoinSystem.ts","../../src/components/UIComponent.ts","../../src/systems/UIRenderSystem.ts","../../src/systems/CoinCounterSystem.ts","../../src/systems/ParticleSystem.ts","../../src/systems/SpeedBoostSystem.ts","../../src/systems/VignetteSystem.ts","../../src/core/Game.ts","../../src/di/container.ts","../../src/index.ts"],"sourcesContent":["type EventCallback = (...args: any[]) => void;\n\nexport class EventEmitter {\n  private events: Map<string, EventCallback[]> = new Map();\n\n  on(event: string, callback: EventCallback): void {\n    if (!this.events.has(event)) {\n      this.events.set(event, []);\n    }\n    this.events.get(event)!.push(callback);\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const callbacks = this.events.get(event);\n    if (callbacks) {\n      callbacks.forEach(callback => callback(...args));\n    }\n  }\n\n  off(event: string, callback: EventCallback): void {\n    const callbacks = this.events.get(event);\n    if (callbacks) {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1) {\n        callbacks.splice(index, 1);\n      }\n      if (callbacks.length === 0) {\n        this.events.delete(event);\n      }\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { Entity } from './Component';\nimport { BaseSystem } from './System';\nimport { EventEmitter } from './EventEmitter';\nimport { Container } from 'inversify';\n\nexport enum GameState {\n  Playing = 'Playing',\n  GameOver = 'GameOver',\n  Starting = 'Starting'\n}\n\n@injectable()\nexport class World extends EventEmitter {\n  private systems: BaseSystem[] = [];\n  private entities: Set<Entity> = new Set();\n  private currentState: GameState = GameState.Starting;\n  private _container: Container;\n\n  constructor(container: Container) {\n    super();\n    this._container = container;\n  }\n\n  public addSystem(system: BaseSystem): void {\n    this.systems.push(system);\n    system.setWorld(this);\n  }\n\n  public addEntity(entity: Entity): void {\n    this.entities.add(entity);\n  }\n\n  public removeEntity(entity: Entity): void {\n    this.entities.delete(entity);\n  }\n\n  public clearEntities(): void {\n    this.entities.clear();\n  }\n\n  public getEntities(): Entity[] {\n    return Array.from(this.entities);\n  }\n\n  public getSystem<T extends BaseSystem>(systemType: new (...args: any[]) => T): T | undefined {\n    return this.systems.find(system => system instanceof systemType) as T | undefined;\n  }\n\n  public clearSystems(): void {\n    this.systems = [];\n  }\n\n  public cleanup(): void {\n    // Clear all entities\n    this.clearEntities();\n    \n    // Reset all systems\n    for (const system of this.systems) {\n      system.reset();\n    }\n    \n    // Clear systems\n    this.clearSystems();\n    \n    // Reset game state\n    this.currentState = GameState.Starting;\n  }\n\n  public getCurrentState(): GameState {\n    return this.currentState;\n  }\n\n  public setGameState(newState: GameState): void {\n    const oldState = this.currentState;\n    this.currentState = newState;\n    \n    // Emit state change event that systems can listen to\n    this.emit('gameStateChanged', { oldState, newState });\n\n    if (newState === GameState.GameOver) {\n      this.emit('gameOver');\n    } else if (newState === GameState.Starting) {\n      // Transition to Playing state after a short delay\n      setTimeout(() => {\n        this.setGameState(GameState.Playing);\n      }, 100);\n    }\n  }\n\n  public update(deltaTime: number): void {\n    // Only update systems if we're in Playing state\n    if (this.currentState !== GameState.Playing) {\n      return;\n    }\n\n    const entities = Array.from(this.entities);\n    for (const system of this.systems) {\n      system.update(entities, deltaTime);\n    }\n  }\n\n  public get container(): Container {\n    return this._container;\n  }\n} ","import { Entity } from './Component';\nimport { Application } from 'pixi.js';\nimport { World, GameState } from './World';\n\nexport interface System {\n  readonly requiredComponents: symbol[];\n  setApp(app: Application): void;\n  setWorld(world: World): void;\n  update(entities: Entity[], deltaTime: number): void;\n}\n\nexport abstract class BaseSystem implements System {\n  protected app: Application | null = null;\n  protected world: World | null = null;\n\n  abstract readonly requiredComponents: symbol[];\n\n  setApp(app: Application): void {\n    this.app = app;\n  }\n\n  setWorld(world: World): void {\n    this.world = world;\n    // Listen for game state changes\n    world.on('gameStateChanged', ({ oldState, newState }) => {\n      this.onGameStateChanged(oldState, newState);\n    });\n  }\n\n  /**\n   * Called when the game state changes\n   */\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to reset its state\n   */\n  public reset(): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to initialize or re-initialize\n   */\n  public initialize(): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to cleanup its resources\n   */\n  public cleanup(): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to be fully reinitialized\n   */\n  public reinitialize(): void {\n    this.cleanup();\n    this.reset();\n    this.initialize();\n  }\n\n  update(entities: Entity[], deltaTime: number): void {\n    const relevantEntities = entities.filter(entity => \n      this.requiredComponents.every(componentType => entity.hasComponent(componentType))\n    );\n    this.updateRelevantEntities(relevantEntities, deltaTime);\n  }\n\n  protected abstract updateRelevantEntities(entities: Entity[], deltaTime: number): void;\n} ","import { Component, Entity } from '../core/Component';\n\nexport const TransformComponentType = Symbol('TransformComponent');\n\nexport class TransformComponent implements Component {\n  public readonly type = TransformComponentType;\n  public entity: Entity | null = null;\n  \n  constructor(\n    public x: number = 0,\n    public y: number = 0,\n    public rotation: number = 0\n  ) {}\n} ","import { Graphics, Container, Sprite, Texture, Assets } from 'pixi.js';\nimport { Component, Entity } from '../core/Component';\n\nexport const VisualComponentType = Symbol('VisualComponent');\n\nexport class VisualComponent implements Component {\n  public readonly type = VisualComponentType;\n  public entity: Entity | null = null;\n  public container: Container;\n  public sprite: Sprite | null = null;\n  public graphics: Graphics | null = null;\n\n  constructor(options: { radius?: number; color?: number; spritePath?: string } = {}) {\n    this.container = new Container();\n    let YOffset = - 32;\n    \n    if (options.spritePath) {\n      try {\n        const texture = Assets.get(options.spritePath);\n        this.sprite = new Sprite(texture);\n        this.sprite.anchor.set(0.5);\n        \n        // Set size to 128x128 (doubled from 64x64)\n        const targetSize = 128;\n        const scale = targetSize / Math.max(this.sprite.width, this.sprite.height);\n        this.sprite.scale.set(scale);\n        \n        // Start facing right (for DownRight movement)\n        this.sprite.scale.x = -Math.abs(this.sprite.scale.x);\n        this.sprite.y += YOffset;\n        \n        this.container.addChild(this.sprite);\n      } catch (error) {\n        console.warn(`[VisualComponent] Failed to load sprite: ${options.spritePath}`, error);\n        // Fallback to a red circle if sprite loading fails\n        this.graphics = new Graphics()\n          .circle(0, 0, 5)\n          .fill({ color: 0xFF0000 });\n        this.container.addChild(this.graphics);\n      }\n    } else {\n      this.graphics = new Graphics()\n        .circle(0, 0, options.radius || 5)\n        .fill({ color: options.color || 0xFF0000 });\n      this.container.addChild(this.graphics);\n    }\n  }\n\n  public flipX(): void {\n    if (this.sprite) {\n      this.sprite.scale.x = -this.sprite.scale.x;\n    }\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const IsometricMovementComponentType = Symbol('IsometricMovementComponent');\n\nexport enum Direction {\n  None = 'none',\n  TopRight = 'topRight',\n  TopLeft = 'topLeft',\n  DownRight = 'downRight',\n  DownLeft = 'downLeft'\n}\n\nexport class IsometricMovementComponent implements Component {\n  public readonly type = IsometricMovementComponentType;\n  public entity: Entity | null = null;\n  public currentDirection: Direction = Direction.None;\n  public targetDirection: Direction = Direction.None;\n  public isMoving: boolean = false;\n  public baseSpeed: number = 200;\n  \n  constructor(\n    public speed: number = this.baseSpeed\n  ) {}\n} ","import { Component, Entity } from '../core/Component';\n\nexport const GridPositionComponentType = Symbol('GridPositionComponent');\n\nexport class GridPositionComponent implements Component {\n  public readonly type = GridPositionComponentType;\n  public entity: Entity | null = null;\n  \n  constructor(\n    public gridX: number = 0,\n    public gridY: number = 0,\n    public targetGridX: number = 0,\n    public targetGridY: number = 0,\n    public isMoving: boolean = false\n  ) {\n    this.targetGridX = gridX;\n    this.targetGridY = gridY;\n  }\n\n  public setTargetPosition(x: number, y: number) {\n    this.targetGridX = x;\n    this.targetGridY = y;\n    this.isMoving = true;\n  }\n\n  public reachedTarget(): boolean {\n    return this.gridX === this.targetGridX && this.gridY === this.targetGridY;\n  }\n} ","import { injectable } from 'inversify';\nimport { Direction } from '../components/IsometricMovementComponent';\n\n@injectable()\nexport class GridService {\n    private readonly TILE_WIDTH = 128;\n    private readonly TILE_HEIGHT = 64;\n\n    /**\n     * Converts grid coordinates to world (screen) coordinates\n     */\n    gridToWorld(gridX: number, gridY: number): { x: number, y: number } {\n        const worldX = (gridX - gridY) * (this.TILE_WIDTH / 2);\n        const worldY = (gridX + gridY) * (this.TILE_HEIGHT / 2);\n        return { x: worldX, y: worldY };\n    }\n\n    /**\n     * Converts world coordinates to grid coordinates\n     */\n    worldToGrid(worldX: number, worldY: number): { x: number, y: number } {\n        // Using the inverse of the isometric projection\n        const gridX = (worldX / this.TILE_WIDTH + worldY / this.TILE_HEIGHT);\n        const gridY = (worldY / this.TILE_HEIGHT - worldX / this.TILE_WIDTH);\n        return { \n            x: Math.round(gridX), \n            y: Math.round(gridY) \n        };\n    }\n\n    /**\n     * Get the dimensions of a tile\n     */\n    getTileDimensions(): { width: number, height: number } {\n        return {\n            width: this.TILE_WIDTH,\n            height: this.TILE_HEIGHT\n        };\n    }\n\n    /**\n     * Get the next grid position based on direction\n     */\n    getNextGridPosition(currentX: number, currentY: number, direction: Direction): { x: number, y: number } {\n        switch (direction) {\n            case Direction.DownRight:\n                return { x: currentX + 1, y: currentY };\n            case Direction.DownLeft:\n                return { x: currentX, y: currentY + 1 };\n            case Direction.TopRight:\n                return { x: currentX, y: currentY - 1 };\n            case Direction.TopLeft:\n                return { x: currentX - 1, y: currentY };\n            default:\n                return { x: currentX, y: currentY };\n        }\n    }\n\n    /**\n     * Check if a grid position is valid\n     */\n    isValidGridPosition(x: number, y: number): boolean {\n        // Add any grid boundary checks here if needed\n        return true;\n    }\n} ","import { Component } from '../core/Component';\nimport { Entity } from '../core/Component';\n\nexport const ParticleComponentType = Symbol('ParticleComponent');\n\nexport interface ParticleData {\n  color: number;\n  size: number;\n  lifetime: number;\n  alpha: number;\n  velocityX: number;\n  velocityY: number;\n}\n\nexport class ParticleComponent implements Component {\n  public readonly type = ParticleComponentType;\n  public particles: ParticleData[] = [];\n  public isActive: boolean = false;\n  public lastDirection: { x: number, y: number } = { x: 0, y: 0 };\n  public entity: Entity | null = null;\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { IsometricMovementComponent, IsometricMovementComponentType, Direction } from '../components/IsometricMovementComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { GridService } from '../services/GridService';\nimport { Container } from 'pixi.js';\nimport { Application } from 'pixi.js';\nimport { ParticleComponent, ParticleComponentType } from '../components/ParticleComponent';\n\n@injectable()\nexport class MovementSystem extends BaseSystem {\n  public worldContainer: Container | null = null;\n\n  readonly requiredComponents = [\n    TransformComponentType,\n    VisualComponentType,\n    IsometricMovementComponentType,\n    GridPositionComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService\n  ) {\n    super();\n  }\n\n  public setApp(app: Application): void {\n    super.setApp(app);\n    if (app) {\n      this.initializeWorldContainer();\n    }\n  }\n\n  private initializeWorldContainer(): void {\n    if (!this.app) return;\n    \n    // Create a world container that will be moved around\n    this.worldContainer = new Container();\n    this.app.stage.addChild(this.worldContainer);\n    this.worldContainer.position.set(0, 0);\n  }\n\n  public cleanup(): void {\n    if (this.worldContainer && this.app) {\n      this.app.stage.removeChild(this.worldContainer);\n      this.worldContainer.destroy();\n      this.worldContainer = null;\n    }\n  }\n\n  public reinitialize(): void {\n    this.cleanup();\n    this.initializeWorldContainer();\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.worldContainer || !this.app) return;\n\n    for (const entity of entities) {\n      const transform = entity.getComponent<TransformComponent>(TransformComponentType);\n      const movement = entity.getComponent<IsometricMovementComponent>(IsometricMovementComponentType);\n      const gridPos = entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n      const visual = entity.getComponent<VisualComponent>(VisualComponentType);\n      const particleComponent = entity.getComponent<ParticleComponent>(ParticleComponentType);\n      \n      if (transform && movement && gridPos && visual) {\n        // Only set new target position if we're not already moving\n        if (!gridPos.isMoving && movement.targetDirection !== Direction.None) {\n          const nextPosition = this.gridService.getNextGridPosition(\n            gridPos.gridX,\n            gridPos.gridY,\n            movement.targetDirection\n          );\n\n          gridPos.setTargetPosition(nextPosition.x, nextPosition.y);\n          movement.currentDirection = movement.targetDirection;\n          movement.isMoving = true;\n          gridPos.isMoving = true;\n\n          // Update particle direction when starting movement\n          if (particleComponent) {\n            const direction = this.getDirectionVector(movement.targetDirection);\n            particleComponent.lastDirection = direction;\n            particleComponent.isActive = true;\n          }\n        }\n\n        if (gridPos.isMoving) {\n          // Calculate current and target positions in world space\n          const targetWorldPos = this.gridService.gridToWorld(gridPos.targetGridX, gridPos.targetGridY);\n          \n          // Calculate direction and distance to target\n          const dx = targetWorldPos.x - transform.x;\n          const dy = targetWorldPos.y - transform.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n\n          if (distance < 1) {\n            // Reached target grid position\n            transform.x = targetWorldPos.x;\n            transform.y = targetWorldPos.y;\n            gridPos.gridX = gridPos.targetGridX;\n            gridPos.gridY = gridPos.targetGridY;\n            gridPos.isMoving = false;\n            movement.isMoving = false;\n            movement.currentDirection = Direction.None;\n\n            // Stop particles when movement ends\n            if (particleComponent) {\n              particleComponent.isActive = false;\n            }\n          } else {\n            // Move towards target using the movement component's speed\n            const moveDistance = movement.speed * deltaTime;\n            const ratio = Math.min(moveDistance / distance, 1);\n\n            transform.x += dx * ratio;\n            transform.y += dy * ratio;\n          }\n\n          // Update visual position\n          visual.container.position.set(transform.x, transform.y);\n\n          // Center camera on character immediately without smoothing\n          if (this.worldContainer && this.app) {\n            // Calculate the position that will center the character on screen\n            const screenCenterX = 0;\n            const screenCenterY = 0;\n            \n            // Move the world container to center the character\n            this.worldContainer.position.x = screenCenterX - transform.x;\n            this.worldContainer.position.y = screenCenterY - transform.y;\n          }\n        } else {\n          // Even when not moving, ensure the character is centered\n          if (this.worldContainer && this.app) {\n            const screenCenterX = 0;\n            const screenCenterY = 0;\n            \n            this.worldContainer.position.x = screenCenterX - transform.x;\n            this.worldContainer.position.y = screenCenterY - transform.y;\n          }\n        }\n      }\n    }\n  }\n\n  private getDirectionVector(direction: Direction): { x: number, y: number } {\n    switch (direction) {\n      case Direction.TopRight:\n        return { x: 1, y: -1 };\n      case Direction.TopLeft:\n        return { x: -1, y: -1 };\n      case Direction.DownRight:\n        return { x: 1, y: 1 };\n      case Direction.DownLeft:\n        return { x: -1, y: 1 };\n      default:\n        return { x: 0, y: 0 };\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { IsometricMovementComponent, IsometricMovementComponentType, Direction } from '../components/IsometricMovementComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { Application } from 'pixi.js';\n\n@injectable()\nexport class InputSystem extends BaseSystem {\n  private queuedDirectionChange = false;\n  private isMovingDownRight = true; // Start with down-right direction\n  private needsFlip = false; // Track if we need to flip the sprite\n  private lastTapTime = 0; // Track the last tap time\n  private readonly TAP_DEBOUNCE = 300; // Debounce time in milliseconds\n\n  readonly requiredComponents = [\n    IsometricMovementComponentType,\n    VisualComponentType,\n    GridPositionComponentType\n  ];\n\n  public reset(): void {\n    // Reset input state\n    this.queuedDirectionChange = false;\n    this.isMovingDownRight = true; // Reset to initial direction (down-right)\n    this.needsFlip = false;\n    this.lastTapTime = 0;\n  }\n\n  setApp(app: Application): void {\n    super.setApp(app);\n    if (app.canvas) {\n      app.canvas.addEventListener('click', () => this.handleTap());\n      app.canvas.addEventListener('touchstart', (e) => {\n        e.preventDefault(); // Prevent default touch behavior\n        this.handleTap();\n      });\n    }\n  }\n\n  private handleTap() {\n    const now = Date.now();\n    // Only accept new input if we're not already processing a direction change\n    // and enough time has passed since the last tap\n    if (!this.queuedDirectionChange && (now - this.lastTapTime) > this.TAP_DEBOUNCE) {\n      this.queuedDirectionChange = true;\n      this.needsFlip = true;\n      this.lastTapTime = now;\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.queuedDirectionChange && !this.needsFlip) return;\n\n    for (const entity of entities) {\n      const movement = entity.getComponent<IsometricMovementComponent>(IsometricMovementComponentType);\n      const gridPos = entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n      const visual = entity.getComponent<VisualComponent>(VisualComponentType);\n      \n      if (movement && gridPos && visual) {\n        // Handle sprite flipping immediately on input\n        if (this.needsFlip) {\n          visual.flipX();\n          this.needsFlip = false;\n        }\n\n        // Handle movement direction change when reaching tile center\n        if (this.queuedDirectionChange && !gridPos.isMoving) {\n          this.isMovingDownRight = !this.isMovingDownRight;\n          movement.targetDirection = this.isMovingDownRight ? Direction.DownRight : Direction.DownLeft;\n          this.queuedDirectionChange = false;\n        }\n      }\n    }\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { Application, Graphics, Container } from 'pixi.js';\nimport { GridService } from '../services/GridService';\nimport { TransformComponentType } from '../components/TransformComponent';\nimport { World, GameState } from '../core/World';\nimport { MovementSystem } from '../systems/MovementSystem';\n\ninterface GridTile {\n  graphics: Graphics;\n  isInUse: boolean;\n  gridX: number;\n  gridY: number;\n}\n\n@injectable()\nexport class GridRenderSystem extends BaseSystem {\n  private gridContainer: Container;\n  private tilePool: GridTile[] = [];\n  private activeTiles: Map<string, GridTile> = new Map();\n  private readonly VISIBLE_RADIUS = 12;\n  private readonly POOL_SIZE = 600;\n  private lastCenterX = 0;\n  private lastCenterY = 0;\n  private isInitialized = false;\n\n  readonly requiredComponents = [\n    TransformComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService\n  ) {\n    super();\n    this.gridContainer = new Container();\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.GameOver) {\n      // Stop processing updates (handled by World)\n    } else if (newState === GameState.Starting) {\n      this.initialize();\n    }\n  }\n\n  public initialize(): void {\n    if (!this.world || !this.app?.stage) return;\n\n    this.initializeTilePool();\n    \n    // Center the grid container on screen\n    this.gridContainer.position.set(0, 0);\n    // Add to world container instead of stage\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (movementSystem && movementSystem.worldContainer) {\n      movementSystem.worldContainer.addChildAt(this.gridContainer, 0);\n    }\n    this.tilePool.forEach(tile => this.gridContainer.addChild(tile.graphics));\n    \n    // Show initial grid\n    this.updateVisibleTiles(0, 0);\n    this.isInitialized = true;\n  }\n\n  public reset(): void {\n    // Return all tiles to the pool\n    for (const [key, tile] of this.activeTiles) {\n      this.recycleTile(tile);\n    }\n\n    // Clear active tiles map\n    this.activeTiles.clear();\n\n    // Reset the visible area tracking\n    this.lastCenterX = 0;\n    this.lastCenterY = 0;\n  }\n\n  private initializeTilePool(): void {\n    for (let i = 0; i < this.POOL_SIZE; i++) {\n      const graphics = new Graphics();\n      this.createTileGraphics(graphics);\n      graphics.visible = false;\n      \n      this.tilePool.push({\n        graphics,\n        isInUse: false,\n        gridX: 0,\n        gridY: 0\n      });\n    }\n  }\n\n  private createTileGraphics(graphics: Graphics): void {\n    const { width, height } = this.gridService.getTileDimensions();\n    graphics.clear();\n    \n    // Draw filled shape\n    graphics\n      .setFillStyle({\n        color: 0xffffff,\n        alpha: 1\n      })\n      .moveTo(0, -height/2)\n      .lineTo(width/2, 0)\n      .lineTo(0, height/2)\n      .lineTo(-width/2, 0)\n      .lineTo(0, -height/2)\n      .fill();\n\n    // Draw outline\n    graphics\n      .setStrokeStyle({\n        width: 1,\n        color: 0xCCCCCC,\n        alpha: 1\n      })\n      .moveTo(0, -height/2)\n      .lineTo(width/2, 0)\n      .lineTo(0, height/2)\n      .lineTo(-width/2, 0)\n      .lineTo(0, -height/2)\n      .stroke();\n  }\n\n  private getTileKey(x: number, y: number): string {\n    return `${x},${y}`;\n  }\n\n  private getFreeTile(): GridTile | null {\n    return this.tilePool.find(tile => !tile.isInUse) || null;\n  }\n\n  private placeTile(gridX: number, gridY: number, centerX: number, centerY: number): void {\n    if (!this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    const key = this.getTileKey(gridX, gridY);\n    if (this.activeTiles.has(key)) return;\n\n    const tile = this.getFreeTile();\n    if (!tile) return;\n\n    // Use GridService for consistent world position calculation\n    const worldPos = this.gridService.worldToGrid(centerX, centerY);\n    \n    this.createTileGraphics(tile.graphics);\n    const tileWorldPos = this.gridService.gridToWorld(gridX, gridY);\n    tile.graphics.position.set(tileWorldPos.x, tileWorldPos.y);\n    tile.graphics.visible = true;\n    tile.isInUse = true;\n    tile.gridX = gridX;\n    tile.gridY = gridY;\n    \n    this.activeTiles.set(key, tile);\n\n    // Emit an event for tile creation that TreeSystem can listen to\n    if (this.world) {\n      this.world.emit('tileCreated', { gridX, gridY });\n    }\n  }\n\n  private recycleTile(tile: GridTile): void {\n    const key = this.getTileKey(tile.gridX, tile.gridY);\n    tile.graphics.visible = false;\n    tile.isInUse = false;\n    this.activeTiles.delete(key);\n  }\n\n  private updateVisibleTiles(centerX: number, centerY: number): void {\n    if (!this.app || !this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      // If the world container isn't ready yet, just return\n      return;\n    }\n\n    // Use the world container's position to determine the center\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n    \n    // Calculate the center in world coordinates\n    const centerWorldX = -worldContainerPos.x;\n    const centerWorldY = -worldContainerPos.y;\n\n    const worldPos = this.gridService.worldToGrid(centerWorldX, centerWorldY);\n    const gridCenterX = Math.floor(worldPos.x);\n    const gridCenterY = Math.floor(worldPos.y);\n\n    // Calculate visible area bounds\n    const minX = gridCenterX - this.VISIBLE_RADIUS;\n    const maxX = gridCenterX + this.VISIBLE_RADIUS;\n    const minY = gridCenterY - this.VISIBLE_RADIUS;\n    const maxY = gridCenterY + this.VISIBLE_RADIUS;\n\n    // Calculate which tiles should be visible\n    const neededTiles = new Set<string>();\n    \n    // Use symmetric bounds for tile placement\n    for (let gridX = minX; gridX <= maxX; gridX++) {\n      for (let gridY = minY; gridY <= maxY; gridY++) {\n        // Calculate Manhattan distance to center to create a more circular visible area\n        const distance = Math.abs(gridX - gridCenterX) + Math.abs(gridY - gridCenterY);\n        if (distance <= this.VISIBLE_RADIUS * 1.5) {\n          const key = this.getTileKey(gridX, gridY);\n          neededTiles.add(key);\n\n          // Place new tiles if needed\n          if (!this.activeTiles.has(key)) {\n            this.placeTile(gridX, gridY, centerWorldX, centerWorldY);\n          }\n        }\n      }\n    }\n\n    // Recycle tiles that are no longer visible\n    for (const [key, tile] of this.activeTiles) {\n      if (!neededTiles.has(key)) {\n        this.recycleTile(tile);\n      }\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage || !this.isInitialized) return;\n    if (!this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      // If the world container isn't ready yet, just return\n      return;\n    }\n\n    // Use the world container's position\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n\n    this.updateVisibleTiles(worldContainerPos.x, worldContainerPos.y);\n  }\n}","import { Component, Entity } from './Component';\n\nexport class BaseEntity implements Entity {\n  private static nextId = 0;\n  public readonly id: number;\n  public components: Map<symbol, Component>;\n\n  constructor() {\n    this.id = BaseEntity.nextId++;\n    this.components = new Map();\n  }\n\n  public addComponent(component: Component): void {\n    this.components.set(component.type, component);\n    component.entity = this;\n  }\n\n  public removeComponent(componentType: symbol): void {\n    const component = this.components.get(componentType);\n    if (component) {\n      component.entity = null;\n      this.components.delete(componentType);\n    }\n  }\n\n  public getComponent<T extends Component>(componentType: symbol): T | undefined {\n    return this.components.get(componentType) as T;\n  }\n\n  public hasComponent(componentType: symbol): boolean {\n    return this.components.has(componentType);\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const TreeComponentType = Symbol('TreeComponent');\n\nexport class TreeComponent implements Component {\n  readonly type = TreeComponentType;\n  entity: Entity | null = null;\n\n  constructor() {}\n} ","import { Component, Entity } from '../core/Component';\nimport { VisualComponent } from './VisualComponent';\nimport { GridPositionComponent } from './GridPositionComponent';\n\nexport const ZIndexComponentType = Symbol('ZIndexComponent');\n\nexport class ZIndexComponent implements Component {\n  public readonly type = ZIndexComponentType;\n  public entity: Entity | null = null;\n  \n  // Base Z-index for different types of entities\n  // This allows us to group entities and ensure certain types are always above others\n  public baseZ: number;\n\n  // UI z-index constants\n  static readonly UI = {\n    VIGNETTE: 1000,\n    COIN_COUNTER: 2000\n  };\n\n  constructor(baseZ: number = 0) {\n    this.baseZ = baseZ;\n  }\n\n  // Calculate final Z-index based on grid position\n  // Objects lower on the screen (higher Y) should appear in front\n  public calculateZ(gridPos: GridPositionComponent): number {\n    // Use Y position as main factor, higher Y means higher Z-index (appears in front)\n    // Use X position as secondary factor to maintain consistent ordering for objects on same Y\n    return this.baseZ + (gridPos.gridY * 1000) + gridPos.gridX;\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const PlayerComponentType = Symbol('PlayerComponent');\n\nexport class PlayerComponent implements Component {\n  public readonly type = PlayerComponentType;\n  public entity: Entity | null = null;\n\n  constructor() {}\n} ","import { injectable } from 'inversify';\n\nexport enum OccupancyType {\n  Tree = 'tree',\n  Coin = 'coin',\n  Character = 'character'\n}\n\n@injectable()\nexport class GridOccupancyService {\n  private occupiedCells: Map<string, Set<OccupancyType>> = new Map();\n\n  private getKey(x: number, y: number): string {\n    return `${x},${y}`;\n  }\n\n  public isOccupied(x: number, y: number, type?: OccupancyType): boolean {\n    const key = this.getKey(x, y);\n    const cell = this.occupiedCells.get(key);\n    \n    if (!cell) return false;\n    if (!type) return cell.size > 0;\n    return cell.has(type);\n  }\n\n  public occupy(x: number, y: number, type: OccupancyType): void {\n    const key = this.getKey(x, y);\n    if (!this.occupiedCells.has(key)) {\n      this.occupiedCells.set(key, new Set());\n    }\n    const cell = this.occupiedCells.get(key)!;\n    if (cell.has(type)) {\n      return;\n    }\n    cell.add(type);\n  }\n\n  public free(x: number, y: number, type: OccupancyType): void {\n    const key = this.getKey(x, y);\n    const cell = this.occupiedCells.get(key);\n    if (cell) {\n      if (!cell.has(type)) {\n        return;\n      }\n      cell.delete(type);\n      if (cell.size === 0) {\n        this.occupiedCells.delete(key);\n      }\n    } else {\n      console.warn(`[GridOccupancyService] Attempting to free non-existent cell at ${x},${y} with type ${type}`);\n    }\n  }\n\n  public reset(): void {\n    this.occupiedCells.clear();\n  }\n\n  public getOccupancyTypes(x: number, y: number): Set<OccupancyType> | undefined {\n    const key = this.getKey(x, y);\n    return this.occupiedCells.get(key);\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { BaseEntity } from '../core/BaseEntity';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { TreeComponent, TreeComponentType } from '../components/TreeComponent';\nimport { ZIndexComponent, ZIndexComponentType } from '../components/ZIndexComponent';\nimport { PlayerComponent, PlayerComponentType } from '../components/PlayerComponent';\nimport { GridService } from '../services/GridService';\nimport { GridOccupancyService, OccupancyType } from '../services/GridOccupancyService';\nimport { World, GameState } from '../core/World';\nimport { Application, Assets } from 'pixi.js';\nimport { MovementSystem } from '../systems/MovementSystem';\n\n// Z-index base values for different entity types\nconst Z_INDEX = {\n  TREE: 100\n};\n\ninterface PooledTree {\n  entity: Entity;\n  isInUse: boolean;\n  gridX: number;\n  gridY: number;\n}\n\n@injectable()\nexport class TreeSystem extends BaseSystem {\n  private readonly TREE_DENSITY = 0.05; // 5% chance of a tree on each tile\n  private readonly VISIBLE_RADIUS = 12; // Match GridRenderSystem's visible radius\n  private readonly POOL_SIZE = 100; // Maximum number of trees that can exist at once\n  \n  private treePool: PooledTree[] = [];\n  private activeTreePositions: Map<string, PooledTree> = new Map();\n  private pendingTileEvents: { gridX: number, gridY: number }[] = [];\n  private isInitialized = false;\n\n  readonly requiredComponents = [\n    GridPositionComponentType,\n    TreeComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService,\n    @inject(GridOccupancyService) private gridOccupancyService: GridOccupancyService\n  ) {\n    super();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n    // Listen for tile creation events\n    this.world.on('tileCreated', (data: { gridX: number, gridY: number }) => {\n      if (!this.isInitialized) {\n        this.pendingTileEvents.push(data);\n      } else {\n        this.trySpawnTreeAt(data.gridX, data.gridY);\n      }\n    });\n\n    // Initialize tree pool if app is already set\n    if (this.app) {\n      const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n      if (movementSystem?.worldContainer) {\n        this.initializeTreePool();\n      }\n    }\n  }\n\n  public setApp(app: Application): void {\n    this.app = app;\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.GameOver) {\n      this.reset();\n    } else if (newState === GameState.Starting) {\n      this.initialize();\n    }\n  }\n\n  public initialize(): void {\n    if (!this.world || !this.app?.stage) {\n      return;\n    }\n  }\n\n  public reset(): void {\n    // First remove all active trees from the stage and grid\n    for (const [key, tree] of this.activeTreePositions.entries()) {\n      const visual = tree.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual && visual.container.parent) {\n        visual.container.parent.removeChild(visual.container);\n      }\n      if (this.world) {\n        this.world.removeEntity(tree.entity);\n      }\n      this.gridOccupancyService.free(tree.gridX, tree.gridY, OccupancyType.Tree);\n    }\n\n    // Clear active positions map\n    this.activeTreePositions.clear();\n\n    // Clean up the pool\n    for (const tree of this.treePool) {\n      if (this.world) {\n        this.world.removeEntity(tree.entity);\n      }\n    }\n    this.treePool = [];\n    this.isInitialized = false;\n\n    // Reinitialize the pool\n    if (this.app && this.world) {\n      const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n      if (movementSystem?.worldContainer) {\n        this.initializeTreePool();\n      }\n    }\n  }\n\n  private async initializeTreePool(): Promise<void> {\n    if (!this.world || !this.app?.stage) return;\n    \n    // Get the movement system first\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      console.warn('[TreeSystem] Movement system not ready, delaying pool initialization');\n      return;\n    }\n\n    // Ensure assets are loaded\n    await Assets.load(['tree.png']);\n    \n    for (let i = 0; i < this.POOL_SIZE; i++) {\n      const tree = new BaseEntity();\n      const transform = new TransformComponent(0, 0);\n      const gridPos = new GridPositionComponent(0, 0);\n      const visual = new VisualComponent({\n        spritePath: 'tree.png',\n      });\n      const treeComponent = new TreeComponent();\n      const zIndex = new ZIndexComponent(Z_INDEX.TREE);\n\n      tree.addComponent(transform);\n      tree.addComponent(gridPos);\n      tree.addComponent(visual);\n      tree.addComponent(treeComponent);\n      tree.addComponent(zIndex);\n\n      this.world.addEntity(tree);\n      \n      // Add to world container\n      movementSystem.worldContainer.addChild(visual.container);\n      visual.container.visible = false;\n\n      this.treePool.push({\n        entity: tree,\n        isInUse: false,\n        gridX: 0,\n        gridY: 0\n      });\n    }\n    \n    // Mark as initialized and process any pending tile events\n    this.isInitialized = true;\n    this.processPendingTileEvents();\n  }\n\n  private processPendingTileEvents(): void {\n    if (!this.isInitialized) return;\n    \n    // Process all pending tile events\n    for (const event of this.pendingTileEvents) {\n      this.trySpawnTreeAt(event.gridX, event.gridY);\n    }\n    this.pendingTileEvents = [];\n  }\n\n  private removeTree(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    const tree = this.activeTreePositions.get(key);\n    \n    if (tree) {\n      const visual = tree.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual) {\n        visual.container.visible = false;\n      }\n      \n      // Mark the tree as not in use in the pool\n      tree.isInUse = false;\n      tree.gridX = 0;\n      tree.gridY = 0;\n      \n      this.gridOccupancyService.free(gridX, gridY, OccupancyType.Tree);\n      this.activeTreePositions.delete(key);\n    }\n  }\n\n  public spawnTree(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    if (this.activeTreePositions.has(key)) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    // Find an unused tree from the pool\n    const unusedTreeIndex = this.treePool.findIndex(tree => !tree.isInUse);\n    if (unusedTreeIndex === -1) {\n      console.warn('[TreeSystem] Tree pool exhausted. Active trees:', this.activeTreePositions.size);\n      return;\n    }\n\n    const unusedTree = this.treePool[unusedTreeIndex];\n    const worldPos = this.gridService.gridToWorld(gridX, gridY);\n    \n    // Update the tree's components\n    const transform = unusedTree.entity.getComponent<TransformComponent>(TransformComponentType);\n    const gridPos = unusedTree.entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n    const visual = unusedTree.entity.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (!transform || !gridPos || !visual) {\n      console.warn('[TreeSystem] Missing required components for tree');\n      return;\n    }\n\n    // Get the movement system and world container\n    const movementSystem = this.world?.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      console.warn('[TreeSystem] Movement system or world container not ready');\n      return;\n    }\n\n    // Update transform and position\n    transform.x = worldPos.x;\n    transform.y = worldPos.y;\n    gridPos.gridX = gridX;\n    gridPos.gridY = gridY;\n    visual.container.visible = true;\n    visual.container.position.set(transform.x, transform.y);\n\n    // Ensure the visual container is in the world container\n    if (!visual.container.parent) {\n      movementSystem.worldContainer.addChild(visual.container);\n    }\n\n    // Mark the tree as in use in the pool\n    unusedTree.isInUse = true;\n    unusedTree.gridX = gridX;\n    unusedTree.gridY = gridY;\n    \n    this.activeTreePositions.set(key, unusedTree);\n    this.gridOccupancyService.occupy(gridX, gridY, OccupancyType.Tree);\n  }\n\n  public trySpawnTreeAt(gridX: number, gridY: number): void {\n    if (!this.world) return;\n    if (this.world.getCurrentState() !== GameState.Playing) return;\n\n    const distanceFromStart = Math.abs(gridX) + Math.abs(gridY);\n    \n    if (distanceFromStart < 20) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    const roll = Math.random();\n    if (roll < this.TREE_DENSITY) {\n      this.spawnTree(gridX, gridY);\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage || this.world?.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      return;\n    }\n\n    // Update positions of all trees\n    for (const tree of this.activeTreePositions.values()) {\n      this.updateTreePosition(tree.entity);\n    }\n\n    // Check for collisions with players\n    const players = this.world?.getEntities().filter(entity => \n      entity.hasComponent(PlayerComponentType) &&\n      entity.hasComponent(GridPositionComponentType)\n    );\n\n    if (players) {\n      for (const player of players) {\n        const playerGridPos = player.getComponent<GridPositionComponent>(GridPositionComponentType);\n        if (playerGridPos) {\n          // First check grid occupancy service\n          if (this.gridOccupancyService.isOccupied(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Tree)) {\n            // Verify against active trees to ensure the tree still exists\n            const key = `${playerGridPos.gridX},${playerGridPos.gridY}`;\n            if (this.activeTreePositions.has(key)) {\n              this.world?.setGameState(GameState.GameOver);\n              return;\n            } else {\n              // If we found an occupancy but no active tree, clean up the occupancy\n              this.gridOccupancyService.free(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Tree);\n            }\n          }\n        }\n      }\n    }\n\n    // Clean up trees that are too far from the center\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n\n    const centerWorldX = -worldContainerPos.x;\n    const centerWorldY = -worldContainerPos.y;\n\n    const worldPos = this.gridService.worldToGrid(centerWorldX, centerWorldY);\n    const gridCenterX = Math.floor(worldPos.x);\n    const gridCenterY = Math.floor(worldPos.y);\n\n    // Remove trees that are too far from view\n    for (const [key, tree] of this.activeTreePositions.entries()) {\n      const gridPos = tree.entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n      if (gridPos) {\n        const distance = Math.abs(gridPos.gridX - gridCenterX) + Math.abs(gridPos.gridY - gridCenterY);\n        if (distance > this.VISIBLE_RADIUS * 1.5) {\n          this.removeTree(gridPos.gridX, gridPos.gridY);\n        }\n      }\n    }\n  }\n\n  private updateTreePosition(tree: Entity): void {\n    const transform = tree.getComponent<TransformComponent>(TransformComponentType);\n    const visual = tree.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (transform && visual) {\n      visual.container.position.set(transform.x, transform.y);\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { ZIndexComponent, ZIndexComponentType } from '../components/ZIndexComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\n\n@injectable()\nexport class ZIndexSystem extends BaseSystem {\n  readonly requiredComponents = [\n    ZIndexComponentType,\n    GridPositionComponentType,\n    VisualComponentType\n  ];\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage) return;\n\n    // Sort entities by their Z-index\n    const sortedEntities = [...entities].sort((a, b) => {\n      const aZIndex = this.getEntityZIndex(a);\n      const bZIndex = this.getEntityZIndex(b);\n      return aZIndex - bZIndex;\n    });\n\n    // Update display object z-index (which is determined by the order in the container's children array)\n    sortedEntities.forEach(entity => {\n      const visual = entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual?.container) {\n        // Remove and re-add to update position in children array\n        const parent = visual.container.parent;\n        if (parent) {\n          parent.removeChild(visual.container);\n          parent.addChild(visual.container);\n        }\n      }\n    });\n  }\n\n  private getEntityZIndex(entity: Entity): number {\n    const zIndex = entity.getComponent<ZIndexComponent>(ZIndexComponentType);\n    const gridPos = entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n    \n    if (!zIndex || !gridPos) return 0;\n    return zIndex.calculateZ(gridPos);\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const CoinComponentType = Symbol('CoinComponent');\n\nexport class CoinComponent implements Component {\n  public readonly type = CoinComponentType;\n  public entity: Entity | null = null;\n} ","import { Component } from '../core/Component';\nimport { Entity } from '../core/Component';\n\nexport const CoinCounterComponentType = Symbol('CoinCounterComponent');\n\nexport class CoinCounterComponent implements Component {\n  public readonly type = CoinCounterComponentType;\n  public entity: Entity | null = null;\n  private count: number = 0;\n  private highscore: number = 0;\n\n  constructor() {\n    // Load highscore from localStorage\n    const savedHighscore = localStorage.getItem('coinHighscore');\n    if (savedHighscore) {\n      this.highscore = parseInt(savedHighscore, 10);\n    }\n  }\n\n  public increment(): void {\n    this.count++;\n    // Update highscore if current count is higher\n    if (this.count > this.highscore) {\n      this.highscore = this.count;\n      localStorage.setItem('coinHighscore', this.highscore.toString());\n    }\n  }\n\n  public getCount(): number {\n    return this.count;\n  }\n\n  public getHighscore(): number {\n    return this.highscore;\n  }\n\n  public reset(): void {\n    this.count = 0;\n  }\n} ","import { Component } from '../core/Component';\n\nexport const SpeedBoostComponentType = Symbol('SpeedBoostComponent');\n\nexport class SpeedBoostComponent implements Component {\n  readonly type = SpeedBoostComponentType;\n  entity: Component['entity'] = null;\n  private speedMultiplier: number = 1.0;\n  private readonly BOOST_PER_COIN = 0.1; // 10% speed increase per coin\n  private readonly MAX_MULTIPLIER = Infinity; // Maximum 2x speed\n\n  public addBoost(): void {\n    this.speedMultiplier = Math.min(this.speedMultiplier + this.BOOST_PER_COIN, this.MAX_MULTIPLIER);\n  }\n\n  public getSpeedMultiplier(): number {\n    return this.speedMultiplier;\n  }\n\n  public reset(): void {\n    this.speedMultiplier = 1.0;\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { BaseEntity } from '../core/BaseEntity';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { CoinComponent, CoinComponentType } from '../components/CoinComponent';\nimport { ZIndexComponent, ZIndexComponentType } from '../components/ZIndexComponent';\nimport { PlayerComponentType } from '../components/PlayerComponent';\nimport { GridService } from '../services/GridService';\nimport { GridOccupancyService, OccupancyType } from '../services/GridOccupancyService';\nimport { World, GameState } from '../core/World';\nimport { MovementSystem } from '../systems/MovementSystem';\nimport { CoinCounterComponent, CoinCounterComponentType } from '../components/CoinCounterComponent';\nimport { SpeedBoostComponent, SpeedBoostComponentType } from '../components/SpeedBoostComponent';\nimport { Application } from 'pixi.js';\n\nconst Z_INDEX = {\n  COIN: 50 // Between tiles and trees\n};\n\ninterface PooledCoin {\n  entity: Entity;\n  isInUse: boolean;\n  gridX: number;\n  gridY: number;\n}\n\n@injectable()\nexport class CoinSystem extends BaseSystem {\n  private readonly COIN_DENSITY = 0.01; // 1% chance of a coin on each tile\n  private readonly VISIBLE_RADIUS = 12; // Match GridRenderSystem's visible radius\n  private readonly POOL_SIZE = 50; // Maximum number of coins that can exist at once\n  \n  private coinPool: PooledCoin[] = [];\n  private activeCoinPositions: Map<string, PooledCoin> = new Map();\n\n  readonly requiredComponents = [\n    GridPositionComponentType,\n    CoinComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService,\n    @inject(GridOccupancyService) private gridOccupancyService: GridOccupancyService\n  ) {\n    super();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n    // Listen for tile creation events\n    this.world.on('tileCreated', (data: { gridX: number, gridY: number }) => {\n      this.trySpawnCoinAt(data.gridX, data.gridY);\n    });\n\n    // Initialize coin pool if app is already set\n    if (this.app) {\n      this.initializeCoinPool();\n    }\n  }\n\n  public setApp(app: Application): void {\n    this.app = app;\n  }\n\n  private initializeCoinPool(): void {\n    if (!this.world || !this.app?.stage) return;\n    \n    for (let i = 0; i < this.POOL_SIZE; i++) {\n      const coin = new BaseEntity();\n      const transform = new TransformComponent(0, 0);\n      const gridPos = new GridPositionComponent(0, 0);\n      const visual = new VisualComponent({\n        spritePath: 'coin.png',\n      });\n      const coinComponent = new CoinComponent();\n      const zIndex = new ZIndexComponent(Z_INDEX.COIN);\n\n      coin.addComponent(transform);\n      coin.addComponent(gridPos);\n      coin.addComponent(visual);\n      coin.addComponent(coinComponent);\n      coin.addComponent(zIndex);\n\n      this.world.addEntity(coin);\n      // Add to world container instead of stage\n      const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n      if (movementSystem && movementSystem.worldContainer) {\n        movementSystem.worldContainer.addChild(visual.container);\n      }\n      visual.container.visible = false;\n\n      this.coinPool.push({\n        entity: coin,\n        isInUse: false,\n        gridX: 0,\n        gridY: 0\n      });\n    }\n  }\n\n  private removeCoin(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    const coin = this.activeCoinPositions.get(key);\n    \n    if (coin) {\n      const visual = coin.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual) {\n        visual.container.visible = false;\n      }\n      \n      // Mark the coin as not in use in the pool\n      coin.isInUse = false;\n      coin.gridX = 0;\n      coin.gridY = 0;\n      \n      this.gridOccupancyService.free(gridX, gridY, OccupancyType.Coin);\n      this.activeCoinPositions.delete(key);\n    }\n  }\n\n  public spawnCoin(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    if (this.activeCoinPositions.has(key)) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    // Find an unused coin from the pool\n    const unusedCoinIndex = this.coinPool.findIndex(coin => !coin.isInUse);\n    if (unusedCoinIndex === -1) {\n      console.warn('[CoinSystem] Coin pool exhausted. Active coins:', this.activeCoinPositions.size);\n      return;\n    }\n\n    const unusedCoin = this.coinPool[unusedCoinIndex];\n    const worldPos = this.gridService.gridToWorld(gridX, gridY);\n    \n    // Update the coin's components\n    const transform = unusedCoin.entity.getComponent<TransformComponent>(TransformComponentType);\n    const gridPos = unusedCoin.entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n    const visual = unusedCoin.entity.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (!transform || !gridPos || !visual) {\n      console.warn('[CoinSystem] Missing required components for coin');\n      return;\n    }\n\n    // Get the movement system and world container\n    const movementSystem = this.world?.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      console.warn('[CoinSystem] Movement system or world container not ready');\n      return;\n    }\n\n    // Update transform and position\n    transform.x = worldPos.x;\n    transform.y = worldPos.y;\n    gridPos.gridX = gridX;\n    gridPos.gridY = gridY;\n    visual.container.visible = true;\n    visual.container.position.set(transform.x, transform.y);\n\n    // Ensure the visual container is in the world container\n    if (!visual.container.parent) {\n      movementSystem.worldContainer.addChild(visual.container);\n    }\n\n    // Mark the coin as in use in the pool\n    unusedCoin.isInUse = true;\n    unusedCoin.gridX = gridX;\n    unusedCoin.gridY = gridY;\n    \n    this.activeCoinPositions.set(key, unusedCoin);\n    this.gridOccupancyService.occupy(gridX, gridY, OccupancyType.Coin);\n  }\n\n  public trySpawnCoinAt(gridX: number, gridY: number): void {\n    if (!this.world) return;\n    if (this.world.getCurrentState() !== GameState.Playing) return;\n\n    const distanceFromStart = Math.abs(gridX) + Math.abs(gridY);\n    \n    if (distanceFromStart < 20) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    const roll = Math.random();\n    if (roll < this.COIN_DENSITY) {\n      this.spawnCoin(gridX, gridY);\n    }\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.GameOver) {\n      this.reset();\n    } else if (newState === GameState.Starting) {\n      this.initialize();\n    }\n  }\n\n  public initialize(): void {\n    if (!this.world || !this.app?.stage) {\n      return;\n    }\n  }\n\n  public reset(): void {\n    // First remove all active coins from the stage and grid\n    for (const [key, coin] of this.activeCoinPositions.entries()) {\n      const visual = coin.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual && visual.container.parent) {\n        visual.container.parent.removeChild(visual.container);\n      }\n      if (this.world) {\n        this.world.removeEntity(coin.entity);\n      }\n      this.gridOccupancyService.free(coin.gridX, coin.gridY, OccupancyType.Coin);\n    }\n\n    // Clear active positions map\n    this.activeCoinPositions.clear();\n\n    // Clean up the pool\n    for (const coin of this.coinPool) {\n      if (this.world) {\n        this.world.removeEntity(coin.entity);\n      }\n    }\n    this.coinPool = [];\n\n    // Reinitialize the pool\n    if (this.app && this.world) {\n      this.initializeCoinPool();\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage || !this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      return;\n    }\n\n    // Update positions of all coins\n    for (const coin of this.activeCoinPositions.values()) {\n      this.updateCoinPosition(coin.entity);\n    }\n\n    // Check for collisions with players\n    const players = this.world.getEntities().filter(entity => \n      entity.hasComponent(PlayerComponentType) &&\n      entity.hasComponent(GridPositionComponentType)\n    );\n\n    for (const player of players) {\n      const playerGridPos = player.getComponent<GridPositionComponent>(GridPositionComponentType);\n      if (playerGridPos) {\n        // First check grid occupancy service\n        if (this.gridOccupancyService.isOccupied(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Coin)) {\n          // Verify against active coins to ensure the coin still exists\n          const key = `${playerGridPos.gridX},${playerGridPos.gridY}`;\n          if (this.activeCoinPositions.has(key)) {\n            const coin = this.activeCoinPositions.get(key);\n            if (coin) {\n              this.handleCoinCollection(coin.entity);\n              this.removeCoin(playerGridPos.gridX, playerGridPos.gridY);\n            }\n          } else {\n            // If we found an occupancy but no active coin, clean up the occupancy\n            this.gridOccupancyService.free(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Coin);\n          }\n        }\n      }\n    }\n\n    // Clean up coins that are too far from the center\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n\n    const centerWorldX = -worldContainerPos.x;\n    const centerWorldY = -worldContainerPos.y;\n\n    const worldPos = this.gridService.worldToGrid(centerWorldX, centerWorldY);\n    const gridCenterX = Math.floor(worldPos.x);\n    const gridCenterY = Math.floor(worldPos.y);\n\n    // Remove coins that are too far from view\n    for (const [key, coin] of this.activeCoinPositions.entries()) {\n      const distance = Math.abs(coin.gridX - gridCenterX) + Math.abs(coin.gridY - gridCenterY);\n      if (distance > this.VISIBLE_RADIUS * 1.5) {\n        this.removeCoin(coin.gridX, coin.gridY);\n      }\n    }\n  }\n\n  private updateCoinPosition(coin: Entity): void {\n    const transform = coin.getComponent<TransformComponent>(TransformComponentType);\n    const visual = coin.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (transform && visual) {\n      visual.container.position.set(transform.x, transform.y);\n    }\n  }\n\n  private handleCoinCollection(coinEntity: Entity): void {\n    // Find the coin counter entity\n    const entities = this.world?.getEntities() || [];\n    const counterEntity = entities.find(entity => entity.hasComponent(CoinCounterComponentType));\n    \n    if (counterEntity) {\n      const counter = counterEntity.getComponent<CoinCounterComponent>(CoinCounterComponentType);\n      if (counter) {\n        counter.increment();\n      }\n    }\n\n    // Add speed boost to the player\n    const player = entities.find(entity => entity.hasComponent(PlayerComponentType));\n    if (player) {\n      const speedBoost = player.getComponent<SpeedBoostComponent>(SpeedBoostComponentType);\n      if (speedBoost) {\n        speedBoost.addBoost();\n      }\n    }\n\n    // Remove the coin from the pool and world\n    const poolItem = this.coinPool.find(item => item.entity === coinEntity);\n    if (poolItem) {\n      poolItem.isInUse = false;\n      const visual = coinEntity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual) {\n        visual.container.visible = false;\n      }\n    }\n  }\n} ","import { Component } from '../core/Component';\nimport { Container, Text, TextStyle, TextStyleAlign } from 'pixi.js';\nimport { Entity } from '../core/Component';\n\nexport const UIComponentType = Symbol('UIComponent');\n\nexport interface UIConfig {\n  text?: string;\n  x?: number;\n  y?: number;\n  style?: Partial<TextStyle>;\n  align?: TextStyleAlign;\n}\n\nexport class UIComponent implements Component {\n  public readonly type = UIComponentType;\n  public container: Container;\n  public text: Text;\n  public entity: Entity | null = null;\n\n  constructor(config: UIConfig = {}) {\n    this.container = new Container();\n    \n    // Create text with default style\n    const style: Partial<TextStyle> = {\n      fontFamily: 'Arial',\n      fontSize: 24,\n      fill: 0xFFFFFF,\n      stroke: {\n        color: 0x000000,\n        width: 4\n      },\n      align: 'center',\n      ...config.style\n    };\n\n    // Use new Text constructor syntax for PixiJS v8\n    this.text = new Text({\n      text: config.text || '',\n      style\n    });\n    this.container.addChild(this.text);\n\n    // Set position if provided\n    if (config.x !== undefined) this.container.x = config.x;\n    if (config.y !== undefined) this.container.y = config.y;\n\n    // Center the text within its container\n    this.text.anchor.set(0.5);\n  }\n\n  public setText(text: string): void {\n    this.text.text = text;\n  }\n\n  public setPosition(x: number, y: number): void {\n    this.container.x = x;\n    this.container.y = y;\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { UIComponent, UIComponentType } from '../components/UIComponent';\nimport { Application, Container } from 'pixi.js';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\n\n@injectable()\nexport class UIRenderSystem extends BaseSystem {\n  private uiContainer: Container;\n  readonly requiredComponents = [UIComponentType];\n\n  constructor() {\n    super();\n    this.uiContainer = new Container();\n    // Set a very high z-index to ensure UI is always on top\n    this.uiContainer.zIndex = 10000;\n  }\n\n  public setApp(app: Application): void {\n    super.setApp(app);\n    if (app) {\n      app.stage.addChild(this.uiContainer);\n    }\n  }\n\n  public cleanup(): void {\n    if (this.uiContainer && this.app) {\n      this.app.stage.removeChild(this.uiContainer);\n      this.uiContainer.destroy();\n      this.uiContainer = new Container();\n      this.uiContainer.zIndex = 10000;\n    }\n  }\n\n  public reinitialize(): void {\n    this.cleanup();\n    if (this.app) {\n      this.app.stage.addChild(this.uiContainer);\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app) return;\n\n    for (const entity of entities) {\n      const ui = entity.getComponent<UIComponent>(UIComponentType);\n      if (ui && !this.uiContainer.children.includes(ui.container)) {\n        this.uiContainer.addChild(ui.container);\n      }\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { CoinCounterComponent, CoinCounterComponentType } from '../components/CoinCounterComponent';\nimport { UIComponent, UIComponentType } from '../components/UIComponent';\nimport { GameState } from '../core/World';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\n\n@injectable()\nexport class CoinCounterSystem extends BaseSystem {\n  readonly requiredComponents = [CoinCounterComponentType, UIComponentType];\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    for (const entity of entities) {\n      const counter = entity.getComponent<CoinCounterComponent>(CoinCounterComponentType);\n      const ui = entity.getComponent<UIComponent>(UIComponentType);\n      \n      if (counter && ui) {\n        const newText = `Coins: ${counter.getCount()} (High: ${counter.getHighscore()})`;\n        if (ui.text.text !== newText) {\n          ui.setText(newText);\n        }\n        // Ensure proper z-index\n        ui.container.zIndex = ZIndexComponent.UI.COIN_COUNTER;\n      }\n    }\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.Starting) {\n      // Reset counter when game restarts\n      const entities = this.world?.getEntities() || [];\n      for (const entity of entities) {\n        const counter = entity.getComponent<CoinCounterComponent>(CoinCounterComponentType);\n        if (counter) {\n          counter.reset();\n          // Force UI update after reset\n          const ui = entity.getComponent<UIComponent>(UIComponentType);\n          if (ui) {\n            ui.setText(`Coins: ${counter.getCount()} (High: ${counter.getHighscore()})`);\n            // Ensure proper z-index\n            ui.container.zIndex = ZIndexComponent.UI.COIN_COUNTER;\n          }\n        }\n      }\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { ParticleComponent, ParticleComponentType, ParticleData } from '../components/ParticleComponent';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { World, GameState } from '../core/World';\nimport { Application, Graphics } from 'pixi.js';\nimport { MovementSystem } from './MovementSystem';\n\n@injectable()\nexport class ParticleSystem extends BaseSystem {\n  private readonly PARTICLE_LIFETIME = 1; // seconds\n  private readonly PARTICLE_SPAWN_RATE = 0.05; // seconds - more frequent spawning\n  private readonly PARTICLE_SIZE = 4; // Increased size\n  private readonly PARTICLE_COLOR = 0x777777;\n  private readonly PARTICLE_ALPHA = 0.5; // Increased alpha\n  private readonly PARTICLE_INITIAL_SPEED = 300; // Increased initial speed\n  private readonly PARTICLE_DRAG = 0.98; // Reduced drag for longer trails\n\n  private particleContainer: Graphics | null = null;\n  private timeSinceLastSpawn: number = 0;\n\n  readonly requiredComponents = [\n    ParticleComponentType,\n    TransformComponentType,\n    VisualComponentType\n  ];\n\n  constructor() {\n    super();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n  }\n\n  public setApp(app: Application): void {\n    super.setApp(app);\n    this.initializeParticleContainer();\n  }\n\n  private initializeParticleContainer(): void {\n    if (!this.app?.stage) return;\n    \n    // Clean up existing container if it exists\n    if (this.particleContainer) {\n      this.particleContainer.destroy();\n      this.particleContainer = null;\n    }\n\n    // Create new container\n    this.particleContainer = new Graphics();\n    \n    // Add to world container instead of stage\n    const movementSystem = this.world?.getSystem<MovementSystem>(MovementSystem);\n    if (movementSystem?.worldContainer) {\n      movementSystem.worldContainer.addChild(this.particleContainer);\n    }\n  }\n\n  public cleanup(): void {\n    if (this.particleContainer) {\n      this.particleContainer.destroy();\n      this.particleContainer = null;\n    }\n  }\n\n  public reinitialize(): void {\n    this.cleanup();\n    this.initializeParticleContainer();\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app || !this.particleContainer) return;\n\n    // Clear previous frame's particles\n    this.particleContainer.clear();\n\n    for (const entity of entities) {\n      const particleComponent = entity.getComponent<ParticleComponent>(ParticleComponentType);\n      if (particleComponent) {\n        const transform = entity.getComponent<TransformComponent>(TransformComponentType);\n        if (transform && particleComponent.isActive) {\n          // Spawn new particles\n          this.timeSinceLastSpawn += deltaTime;\n          if (this.timeSinceLastSpawn >= this.PARTICLE_SPAWN_RATE) {\n            this.spawnParticles(particleComponent, transform);\n            this.timeSinceLastSpawn = 0;\n          }\n        }\n        this.updateParticles(particleComponent, deltaTime);\n      }\n    }\n  }\n\n  private updateParticles(particleComponent: ParticleComponent, deltaTime: number): void {\n    const transform = particleComponent.entity?.getComponent<TransformComponent>(TransformComponentType);\n    if (!transform || !this.particleContainer) return;\n\n    // Update and draw each particle\n    for (let i = particleComponent.particles.length - 1; i >= 0; i--) {\n      const particle = particleComponent.particles[i];\n      particle.lifetime -= deltaTime;\n\n      if (particle.lifetime <= 0) {\n        particleComponent.particles.splice(i, 1);\n        continue;\n      }\n\n      // Update position\n      const progress = 1 - (particle.lifetime / this.PARTICLE_LIFETIME);\n      const alpha = this.PARTICLE_ALPHA * (1 - progress);\n      const size = particle.size * (1 - progress);\n      \n      // Calculate world position\n      const worldX = transform.x + particle.velocityX * progress;\n      const worldY = transform.y + particle.velocityY * progress;\n      \n      // Draw particle using new v8 API\n      this.particleContainer\n        .circle(worldX, worldY, size)\n        .fill({ color: particle.color, alpha: alpha });\n    }\n  }\n\n  private spawnParticles(particleComponent: ParticleComponent, transform: TransformComponent): void {\n    // Spawn particles in the opposite direction of movement\n    const direction = particleComponent.lastDirection;\n    const angle = Math.atan2(direction.y, direction.x);\n    \n    // Spawn 2-3 particles\n    const count = Math.floor(Math.random() * 2) + 2;\n    \n    for (let i = 0; i < count; i++) {\n      const spread = (Math.random() - 0.5) * Math.PI / 4; // Random spread\n      const particleAngle = angle + Math.PI + spread;\n      \n      const particle: ParticleData = {\n        color: this.PARTICLE_COLOR,\n        size: this.PARTICLE_SIZE,\n        lifetime: this.PARTICLE_LIFETIME,\n        alpha: this.PARTICLE_ALPHA,\n        velocityX: Math.cos(particleAngle) * this.PARTICLE_INITIAL_SPEED,\n        velocityY: Math.sin(particleAngle) * this.PARTICLE_INITIAL_SPEED\n      };\n      \n      particleComponent.particles.push(particle);\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { SpeedBoostComponent, SpeedBoostComponentType } from '../components/SpeedBoostComponent';\nimport { IsometricMovementComponent, IsometricMovementComponentType } from '../components/IsometricMovementComponent';\nimport { World, GameState } from '../core/World';\n\n@injectable()\nexport class SpeedBoostSystem extends BaseSystem {\n  readonly requiredComponents = [\n    SpeedBoostComponentType,\n    IsometricMovementComponentType\n  ];\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    for (const entity of entities) {\n      const speedBoost = entity.getComponent<SpeedBoostComponent>(SpeedBoostComponentType);\n      const movement = entity.getComponent<IsometricMovementComponent>(IsometricMovementComponentType);\n      \n      if (speedBoost && movement) {\n        // Apply the speed multiplier to the movement speed\n        movement.speed = movement.baseSpeed * speedBoost.getSpeedMultiplier();\n      }\n    }\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.Starting) {\n      // Reset speed boosts when game restarts\n      const entities = this.world?.getEntities() || [];\n      for (const entity of entities) {\n        const speedBoost = entity.getComponent<SpeedBoostComponent>(SpeedBoostComponentType);\n        if (speedBoost) {\n          speedBoost.reset();\n        }\n      }\n    }\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Application, Sprite, Assets } from 'pixi.js';\nimport { GridService } from '../services/GridService';\nimport { World, GameState } from '../core/World';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\n\n@injectable()\nexport class VignetteSystem extends BaseSystem {\n  private vignetteSprite: Sprite | null = null;\n  readonly requiredComponents: symbol[] = []; // No required components for this system\n\n  constructor(\n    @inject(GridService) private gridService: GridService\n  ) {\n    super();\n  }\n\n  public setApp(app: Application): void {\n    this.app = app;\n    this.initializeVignette();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.Starting || newState === GameState.Playing) {\n      this.initializeVignette();\n      this.updateVignetteScale();\n    }\n  }\n\n  private async initializeVignette(): Promise<void> {\n    if (!this.app || !this.world) {\n      console.log('[VignetteSystem] Waiting for app and world to be ready');\n      return;\n    }\n\n    console.log('[VignetteSystem] Initializing vignette');\n    \n    // Remove old vignette if it exists\n    if (this.vignetteSprite && this.vignetteSprite.parent) {\n      this.vignetteSprite.parent.removeChild(this.vignetteSprite);\n    }\n\n    // Ensure assets are loaded\n    await Assets.load(['vignette3.png']);\n    \n    // Create vignette sprite\n    const texture = Assets.get('vignette3.png');\n    this.vignetteSprite = new Sprite(texture);\n    \n    // Center the sprite\n    this.vignetteSprite.anchor.set(0.5);\n    \n    // Set z-index\n    this.vignetteSprite.zIndex = ZIndexComponent.UI.VIGNETTE;\n    \n    // Make it invisible until properly scaled\n    this.vignetteSprite.visible = false;\n    \n    // Add to stage\n    this.app.stage.addChild(this.vignetteSprite);\n    console.log('[VignetteSystem] Added vignette to stage');\n  }\n\n  private updateVignetteScale(): void {\n    if (!this.app || !this.vignetteSprite || !this.world) return;\n\n    // Calculate visible area based on grid dimensions\n    const { width: tileWidth, height: tileHeight } = this.gridService.getTileDimensions();\n    const visibleRadius = 10; // Match GridRenderSystem's visible radius\n    \n    // Calculate the actual visible area in world coordinates\n    const visibleWidth = tileWidth * visibleRadius * 2;\n    const visibleHeight = tileHeight * visibleRadius * 2;\n    \n    // Scale to match the visible grid area exactly\n    const scale = Math.max(visibleWidth, visibleHeight) / 512;\n    \n    this.vignetteSprite.scale.set(scale);\n    this.vignetteSprite.visible = true;\n  }\n\n  protected updateRelevantEntities(entities: any[], deltaTime: number): void {\n    // Update scale whenever we have a vignette and the world is ready\n    if (this.vignetteSprite && this.world && this.app && this.gridService) {\n      this.updateVignetteScale();\n    }\n  }\n} ","import { Application, Assets } from 'pixi.js';\nimport { injectable, inject } from 'inversify';\nimport { World, GameState } from './World';\nimport { MovementSystem } from '../systems/MovementSystem';\nimport { InputSystem } from '../systems/InputSystem';\nimport { GridRenderSystem } from '../systems/GridRenderSystem';\nimport { TreeSystem } from '../systems/TreeSystem';\nimport { ZIndexSystem } from '../systems/ZIndexSystem';\nimport { CoinSystem } from '../systems/CoinSystem';\nimport { BaseEntity } from './BaseEntity';\nimport { TransformComponent } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { IsometricMovementComponent, Direction } from '../components/IsometricMovementComponent';\nimport { GridPositionComponent } from '../components/GridPositionComponent';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\nimport { PlayerComponent } from '../components/PlayerComponent';\nimport { GridOccupancyService } from '../services/GridOccupancyService';\nimport { UIRenderSystem } from '../systems/UIRenderSystem';\nimport { CoinCounterSystem } from '../systems/CoinCounterSystem';\nimport { UIComponent, UIComponentType } from '../components/UIComponent';\nimport { CoinCounterComponent } from '../components/CoinCounterComponent';\nimport { ParticleSystem } from '../systems/ParticleSystem';\nimport { ParticleComponent } from '../components/ParticleComponent';\nimport { SpeedBoostComponent } from '../components/SpeedBoostComponent';\nimport { SpeedBoostSystem } from '../systems/SpeedBoostSystem';\nimport { VignetteSystem } from '../systems/VignetteSystem';\n\n// Z-index base values for different entity types\nconst Z_INDEX = {\n  TILE: 0,\n  TREE: 100,\n  CHARACTER: 200\n};\n\n@injectable()\nexport class Game {\n  private app!: Application;\n  private world: World;\n  private lastTime: number;\n  private readonly TILE_WIDTH = 128;\n  private readonly TILE_HEIGHT = 64;\n  private character: BaseEntity | null = null;\n  private gridOccupancyService: GridOccupancyService | null = null;\n  private coinCounter: BaseEntity | null = null;\n\n  constructor(\n    @inject(World) worldFactory: () => World,\n    @inject(MovementSystem) private movementSystem: MovementSystem,\n    @inject(InputSystem) private inputSystem: InputSystem,\n    @inject(GridRenderSystem) private gridRenderSystem: GridRenderSystem,\n    @inject(TreeSystem) private treeSystem: TreeSystem,\n    @inject(ZIndexSystem) private zIndexSystem: ZIndexSystem,\n    @inject(CoinSystem) private coinSystem: CoinSystem,\n    @inject(UIRenderSystem) private uiRenderSystem: UIRenderSystem,\n    @inject(CoinCounterSystem) private coinCounterSystem: CoinCounterSystem,\n    @inject(ParticleSystem) private particleSystem: ParticleSystem,\n    @inject(SpeedBoostSystem) private speedBoostSystem: SpeedBoostSystem,\n    @inject(VignetteSystem) private vignetteSystem: VignetteSystem\n  ) {\n    this.world = worldFactory();\n    this.world.addSystem(gridRenderSystem);\n    this.world.addSystem(movementSystem);\n    this.world.addSystem(inputSystem);\n    this.world.addSystem(treeSystem);\n    this.world.addSystem(zIndexSystem);\n    this.world.addSystem(coinSystem);\n    this.world.addSystem(uiRenderSystem);\n    this.world.addSystem(coinCounterSystem);\n    this.world.addSystem(particleSystem);\n    this.world.addSystem(speedBoostSystem);\n    this.world.addSystem(vignetteSystem);\n    this.lastTime = performance.now();\n    this.gameLoop = this.gameLoop.bind(this);\n\n    // Listen for game over event\n    this.world.on('gameOver', () => {\n      setTimeout(() => {\n        this.restart();\n      }, 1000);\n    });\n\n    // Listen for character creation events\n    this.world.on('createCharacter', () => {\n      this.createCharacter();\n    });\n  }\n\n  private async initializeSystems(): Promise<void> {\n    // Get fresh instances of all systems from the container\n    const container = this.world.container;\n    this.movementSystem = container.get<MovementSystem>(MovementSystem);\n    this.inputSystem = container.get<InputSystem>(InputSystem);\n    this.gridRenderSystem = container.get<GridRenderSystem>(GridRenderSystem);\n    this.treeSystem = container.get<TreeSystem>(TreeSystem);\n    this.zIndexSystem = container.get<ZIndexSystem>(ZIndexSystem);\n    this.coinSystem = container.get<CoinSystem>(CoinSystem);\n    this.uiRenderSystem = container.get<UIRenderSystem>(UIRenderSystem);\n    this.coinCounterSystem = container.get<CoinCounterSystem>(CoinCounterSystem);\n    this.particleSystem = container.get<ParticleSystem>(ParticleSystem);\n    this.speedBoostSystem = container.get<SpeedBoostSystem>(SpeedBoostSystem);\n    this.vignetteSystem = container.get<VignetteSystem>(VignetteSystem);\n\n    // Get a new world instance using the factory\n    const worldFactory = container.get<() => World>(World);\n    this.world = worldFactory();\n\n    // Set up app references first\n    this.movementSystem.setApp(this.app);\n    this.inputSystem.setApp(this.app);\n    this.gridRenderSystem.setApp(this.app);\n    this.treeSystem.setApp(this.app);\n    this.zIndexSystem.setApp(this.app);\n    this.coinSystem.setApp(this.app);\n    this.uiRenderSystem.setApp(this.app);\n    this.particleSystem.setApp(this.app);\n    this.speedBoostSystem.setApp(this.app);\n    this.vignetteSystem.setApp(this.app);\n\n    // Then set up the world references\n    this.treeSystem.setWorld(this.world);\n    this.coinSystem.setWorld(this.world);\n    this.coinCounterSystem.setWorld(this.world);\n    this.particleSystem.setWorld(this.world);\n    this.speedBoostSystem.setWorld(this.world);\n    this.vignetteSystem.setWorld(this.world);\n\n    // Finally add systems to the world\n    this.world.addSystem(this.gridRenderSystem);\n    this.world.addSystem(this.movementSystem);\n    this.world.addSystem(this.inputSystem);\n    this.world.addSystem(this.treeSystem);\n    this.world.addSystem(this.zIndexSystem);\n    this.world.addSystem(this.coinSystem);\n    this.world.addSystem(this.uiRenderSystem);\n    this.world.addSystem(this.coinCounterSystem);\n    this.world.addSystem(this.particleSystem);\n    this.world.addSystem(this.speedBoostSystem);\n    this.world.addSystem(this.vignetteSystem);\n\n    // Reinitialize all systems\n    this.movementSystem.reinitialize();\n    this.inputSystem.reinitialize();\n    this.gridRenderSystem.reinitialize();\n    this.treeSystem.reinitialize();\n    this.zIndexSystem.reinitialize();\n    this.coinSystem.reinitialize();\n    this.uiRenderSystem.reinitialize();\n    this.coinCounterSystem.reinitialize();\n    this.particleSystem.reinitialize();\n    this.speedBoostSystem.reinitialize();\n    this.vignetteSystem.reinitialize();\n\n    // Set up event listeners\n    this.world.on('gameOver', () => {\n      setTimeout(() => {\n        this.restart();\n      }, 1000);\n    });\n\n    // Create initial entities\n    this.createCharacter();\n    this.createCoinCounter();\n\n    // Start the game\n    this.world.setGameState(GameState.Starting);\n  }\n\n  public async start(): Promise<void> {\n    // Clean up any existing app instance\n    if (this.app) {\n      this.app.destroy(true);\n    }\n\n    // Calculate target resolution (720p)\n    const targetWidth = 1280;\n    const targetHeight = 720;\n\n    // Calculate scale to fit the window while maintaining aspect ratio\n    const scale = Math.min(\n      window.innerWidth / targetWidth,\n      window.innerHeight / targetHeight\n    );\n\n    // Calculate actual dimensions\n    const width = Math.floor(targetWidth * scale);\n    const height = Math.floor(targetHeight * scale);\n\n    this.app = new Application();\n    await this.app.init({\n      width,\n      height,\n      backgroundColor: 0xffffff, // Sky blue background\n      resolution: Math.min(window.devicePixelRatio || 1, 2), // Cap resolution at 2x\n      autoDensity: true, // Enable auto density for crisp rendering\n      resizeTo: window, // Make canvas resize to window\n    });\n\n    // Remove any existing canvas\n    const existingCanvas = document.querySelector('canvas');\n    if (existingCanvas) {\n      existingCanvas.remove();\n    }\n\n    document.body.appendChild(this.app.canvas);\n\n    // Load assets first\n    await Assets.load([\n      'character.png',\n      'tree.png',\n      'coin.png',\n      'vignette.png',\n      'vignette2.png',\n      'vignette3.png'\n    ]);\n    \n    // Reset stage position to center\n    this.app.stage.position.set(\n      this.app.screen.width / 2,\n      this.app.screen.height / 2\n    );\n\n    // Initialize systems and start the game\n    await this.initializeSystems();\n\n    // Start the game loop\n    this.app.ticker.add(this.gameLoop);\n\n    // Add window resize handler\n    window.addEventListener('resize', () => {\n      const newScale = Math.min(\n        window.innerWidth / targetWidth,\n        window.innerHeight / targetHeight\n      );\n      const newWidth = Math.floor(targetWidth * newScale);\n      const newHeight = Math.floor(targetHeight * newScale);\n      \n      this.app.renderer.resize(newWidth, newHeight);\n      this.app.stage.position.set(\n        this.app.screen.width / 2,\n        this.app.screen.height / 2\n      );\n    });\n  }\n\n  private async createCharacter(): Promise<void> {\n    // Remove old character if it exists\n    if (this.character) {\n      const visual = this.character.getComponent<VisualComponent>(VisualComponentType);\n      if (visual && visual.container.parent) {\n        visual.container.parent.removeChild(visual.container);\n      }\n      this.world.removeEntity(this.character);\n    }\n\n    // Create new character\n    this.character = new BaseEntity();\n    \n    // Calculate initial world position from grid position (0,0)\n    const initialGridPos = { x: 0, y: 0 };\n    const worldPos = this.gridToWorld(initialGridPos.x, initialGridPos.y);\n    const gridPos = new GridPositionComponent(initialGridPos.x, initialGridPos.y);\n\n    // Set transform to the world position\n    const transform = new TransformComponent(worldPos.x, worldPos.y);\n    const visual = new VisualComponent({ spritePath: 'character.png' });\n    const movement = new IsometricMovementComponent(150);\n    movement.targetDirection = Direction.DownRight; // Start moving down-right\n    const zIndex = new ZIndexComponent(Z_INDEX.CHARACTER);\n    const player = new PlayerComponent();\n    const particle = new ParticleComponent();\n    const speedBoost = new SpeedBoostComponent();\n\n    this.character.addComponent(gridPos);\n    this.character.addComponent(transform);\n    this.character.addComponent(visual);\n    this.character.addComponent(movement);\n    this.character.addComponent(zIndex);\n    this.character.addComponent(player);\n    this.character.addComponent(particle);\n    this.character.addComponent(speedBoost);\n    this.world.addEntity(this.character);\n\n    // Add the visual to the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (movementSystem && movementSystem.worldContainer) {\n      movementSystem.worldContainer.addChild(visual.container);\n    }\n    \n    // Set the visual position to match the transform\n    visual.container.position.set(worldPos.x, worldPos.y);\n  }\n\n  private createCoinCounter(): void {\n    // Remove old counter if it exists\n    if (this.coinCounter) {\n      const ui = this.coinCounter.getComponent<UIComponent>(UIComponentType);\n      if (ui && ui.container.parent) {\n        ui.container.parent.removeChild(ui.container);\n      }\n      this.world.removeEntity(this.coinCounter);\n    }\n\n    // Create new counter\n    this.coinCounter = new BaseEntity();\n    \n    const counter = new CoinCounterComponent();\n    const ui = new UIComponent({\n      text: 'Coins: 0',\n      style: {\n        fontSize: 32,\n        fill: 0xFFD700, // Gold color\n        stroke: {\n          color: 0x000000,\n          width: 4\n        }\n      }\n    });\n\n    this.coinCounter.addComponent(counter);\n    this.coinCounter.addComponent(ui);\n    this.world.addEntity(this.coinCounter);\n\n    // Position at top center of screen, accounting for centered stage\n    if (this.app) {\n      // Since stage is centered at (0,0), we need to position relative to that\n      ui.setPosition(0, -this.app.screen.height / 2 + 40);\n    }\n  }\n\n  private gridToWorld(gridX: number, gridY: number): { x: number, y: number } {\n    const isoX = (gridX - gridY) * (this.TILE_WIDTH / 2);\n    const isoY = (gridX + gridY) * (this.TILE_HEIGHT / 2);\n    return { x: isoX, y: isoY };\n  }\n\n  public async restart(): Promise<void> {\n    console.log('[Game] Starting game restart');\n\n    // Cleanup current world\n    this.world.cleanup();\n\n    // Clear the stage\n    while (this.app.stage.children.length > 0) {\n      const child = this.app.stage.children[0];\n      child.destroy();\n      this.app.stage.removeChild(child);\n    }\n\n    // Reset stage position\n    this.app.stage.position.set(\n      this.app.screen.width / 2,\n      this.app.screen.height / 2\n    );\n\n    // Initialize systems and start the game\n    await this.initializeSystems();\n  }\n\n  private gameLoop(): void {\n    const currentTime = performance.now();\n    const deltaTime = (currentTime - this.lastTime) / 1000;\n    this.lastTime = currentTime;\n\n    this.world.update(deltaTime);\n  }\n\n  public get pixiApp(): Application {\n    return this.app;\n  }\n} ","import { Container } from 'inversify';\nimport { World } from '../core/World';\nimport { Game } from '../core/Game';\nimport { MovementSystem } from '../systems/MovementSystem';\nimport { InputSystem } from '../systems/InputSystem';\nimport { GridRenderSystem } from '../systems/GridRenderSystem';\nimport { TreeSystem } from '../systems/TreeSystem';\nimport { ZIndexSystem } from '../systems/ZIndexSystem';\nimport { CoinSystem } from '../systems/CoinSystem';\nimport { GridService } from '../services/GridService';\nimport { GridOccupancyService } from '../services/GridOccupancyService';\nimport { UIRenderSystem } from '../systems/UIRenderSystem';\nimport { CoinCounterSystem } from '../systems/CoinCounterSystem';\nimport { ParticleSystem } from '../systems/ParticleSystem';\nimport { SpeedBoostSystem } from '../systems/SpeedBoostSystem';\nimport { VignetteSystem } from '../systems/VignetteSystem';\n\nexport function createContainer(): Container {\n  const container = new Container();\n\n  // Create a factory function for World that takes the container\n  const worldFactory = (c: Container) => {\n    return new World(c);\n  };\n\n  // Bind World as a factory to ensure fresh instances\n  container.bind<World>(World).toFactory<World>((context) => {\n    return () => worldFactory(container);\n  });\n\n  // Bind Game as a singleton\n  container.bind<Game>(Game).toSelf().inSingletonScope();\n\n  // Bind all systems as singletons\n  container.bind<MovementSystem>(MovementSystem).toSelf().inSingletonScope();\n  container.bind<InputSystem>(InputSystem).toSelf().inSingletonScope();\n  container.bind<GridRenderSystem>(GridRenderSystem).toSelf().inSingletonScope();\n  container.bind<TreeSystem>(TreeSystem).toSelf().inSingletonScope();\n  container.bind<ZIndexSystem>(ZIndexSystem).toSelf().inSingletonScope();\n  container.bind<CoinSystem>(CoinSystem).toSelf().inSingletonScope();\n  container.bind<UIRenderSystem>(UIRenderSystem).toSelf().inSingletonScope();\n  container.bind<CoinCounterSystem>(CoinCounterSystem).toSelf().inSingletonScope();\n  container.bind<ParticleSystem>(ParticleSystem).toSelf().inSingletonScope();\n  container.bind<SpeedBoostSystem>(SpeedBoostSystem).toSelf().inSingletonScope();\n  container.bind<VignetteSystem>(VignetteSystem).toSelf().inSingletonScope();\n\n  // Bind services as singletons\n  container.bind<GridService>(GridService).toSelf().inSingletonScope();\n  container.bind<GridOccupancyService>(GridOccupancyService).toSelf().inSingletonScope();\n\n  return container;\n} ","import 'reflect-metadata';\nimport { createContainer } from './di/container';\nimport { Game } from './core/Game';\n\n// Create container and get the game instance\nconst container = createContainer();\nconst game = container.get<Game>(Game);\n\n// Start the game\ngame.start(); "],"names":["EventEmitter","constructor","__publicField","this","Map","on","event","callback","events","has","set","get","push","emit","args","callbacks","forEach","off","index","indexOf","splice","length","delete","GameState","World","container","Set","_container","addSystem","system","systems","setWorld","addEntity","entity","entities","add","removeEntity","clearEntities","clear","getEntities","Array","from","getSystem","systemType","find","clearSystems","cleanup","reset","currentState","getCurrentState","setGameState","newState","oldState","setTimeout","update","deltaTime","__decorateClass","injectable","BaseSystem","setApp","app","world","onGameStateChanged","initialize","reinitialize","relevantEntities","filter","requiredComponents","every","hasComponent","componentType","updateRelevantEntities","TransformComponentType","Symbol","TransformComponent","x","y","rotation","VisualComponentType","VisualComponent","options","Container","spritePath","texture","Assets","sprite","Sprite","anchor","scale","Math","max","width","height","abs","addChild","error","console","warn","graphics","Graphics","circle","fill","color","radius","flipX","IsometricMovementComponentType","Direction","IsometricMovementComponent","speed","baseSpeed","GridPositionComponentType","GridPositionComponent","gridX","gridY","targetGridX","targetGridY","isMoving","setTargetPosition","reachedTarget","GridService","gridToWorld","TILE_WIDTH","TILE_HEIGHT","worldToGrid","worldX","worldY","round","getTileDimensions","getNextGridPosition","currentX","currentY","direction","DownRight","DownLeft","TopRight","TopLeft","isValidGridPosition","ParticleComponentType","ParticleComponent","MovementSystem","gridService","super","initializeWorldContainer","worldContainer","stage","position","removeChild","destroy","transform","getComponent","movement","gridPos","visual","particleComponent","targetDirection","None","nextPosition","currentDirection","getDirectionVector","lastDirection","isActive","targetWorldPos","dx","dy","distance","sqrt","moveDistance","ratio","min","screenCenterX","screenCenterY","InputSystem","arguments","queuedDirectionChange","isMovingDownRight","needsFlip","lastTapTime","canvas","addEventListener","handleTap","e","preventDefault","now","Date","TAP_DEBOUNCE","GridRenderSystem","gridContainer","GameOver","Starting","_a","initializeTilePool","movementSystem","addChildAt","tilePool","tile","updateVisibleTiles","isInitialized","key","activeTiles","recycleTile","lastCenterX","lastCenterY","i","POOL_SIZE","createTileGraphics","visible","isInUse","setFillStyle","alpha","moveTo","lineTo","setStrokeStyle","stroke","getTileKey","getFreeTile","placeTile","centerX","centerY","Playing","tileWorldPos","worldContainerPos","centerWorldX","centerWorldY","worldPos","gridCenterX","floor","gridCenterY","minX","VISIBLE_RADIUS","maxX","minY","maxY","neededTiles","__decorateParam","_BaseEntity","id","nextId","components","addComponent","component","type","removeComponent","BaseEntity","TreeComponentType","TreeComponent","ZIndexComponentType","ZIndexComponent","baseZ","calculateZ","VIGNETTE","COIN_COUNTER","PlayerComponentType","PlayerComponent","OccupancyType","GridOccupancyService","getKey","isOccupied","cell","occupiedCells","size","occupy","free","getOccupancyTypes","Z_INDEX","TreeSystem","gridOccupancyService","data","trySpawnTreeAt","pendingTileEvents","initializeTreePool","tree","activeTreePositions","entries","parent","Tree","treePool","load","treeComponent","zIndex","processPendingTileEvents","removeTree","spawnTree","unusedTreeIndex","findIndex","unusedTree","random","TREE_DENSITY","_b","values","updateTreePosition","players","_c","player","playerGridPos","_d","ZIndexSystem","sort","a","b","getEntityZIndex","CoinComponentType","CoinComponent","CoinCounterComponentType","CoinCounterComponent","savedHighscore","localStorage","getItem","highscore","parseInt","increment","count","setItem","toString","getCount","getHighscore","SpeedBoostComponentType","SpeedBoostComponent","Infinity","addBoost","speedMultiplier","BOOST_PER_COIN","MAX_MULTIPLIER","getSpeedMultiplier","CoinSystem","trySpawnCoinAt","initializeCoinPool","coin","coinComponent","coinPool","removeCoin","activeCoinPositions","Coin","spawnCoin","unusedCoinIndex","unusedCoin","COIN_DENSITY","updateCoinPosition","handleCoinCollection","coinEntity","counterEntity","counter","speedBoost","poolItem","item","UIComponentType","UIComponent","config","style","fontFamily","fontSize","align","text","Text","setText","setPosition","UIRenderSystem","uiContainer","ui","children","includes","CoinCounterSystem","newText","UI","ParticleSystem","initializeParticleContainer","particleContainer","timeSinceLastSpawn","PARTICLE_SPAWN_RATE","spawnParticles","updateParticles","particles","particle","lifetime","progress","PARTICLE_LIFETIME","PARTICLE_ALPHA","velocityX","velocityY","angle","atan2","spread","PI","particleAngle","PARTICLE_COLOR","PARTICLE_SIZE","cos","PARTICLE_INITIAL_SPEED","sin","SpeedBoostSystem","VignetteSystem","initializeVignette","updateVignetteScale","log","vignetteSprite","tileWidth","tileHeight","visibleWidth","visibleHeight","Game","worldFactory","inputSystem","gridRenderSystem","treeSystem","zIndexSystem","coinSystem","uiRenderSystem","coinCounterSystem","particleSystem","speedBoostSystem","vignetteSystem","lastTime","performance","gameLoop","bind","restart","createCharacter","initializeSystems","createCoinCounter","start","targetWidth","targetHeight","window","innerWidth","innerHeight","Application","init","backgroundColor","resolution","devicePixelRatio","autoDensity","resizeTo","existingCanvas","document","querySelector","remove","body","appendChild","screen","ticker","newScale","newWidth","newHeight","renderer","resize","character","initialGridPos","coinCounter","child","currentTime","pixiApp","toFactory","context","toSelf","inSingletonScope","createContainer"],"mappings":"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"}