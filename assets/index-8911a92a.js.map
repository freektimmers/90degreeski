{"version":3,"file":"index-8911a92a.js","sources":["../../src/core/EventEmitter.ts","../../src/core/World.ts","../../src/core/System.ts","../../src/components/TransformComponent.ts","../../src/components/VisualComponent.ts","../../src/components/IsometricMovementComponent.ts","../../src/components/GridPositionComponent.ts","../../src/services/GridService.ts","../../src/components/ParticleComponent.ts","../../src/systems/MovementSystem.ts","../../src/systems/InputSystem.ts","../../src/systems/GridRenderSystem.ts","../../src/core/BaseEntity.ts","../../src/components/TreeComponent.ts","../../src/components/ZIndexComponent.ts","../../src/components/PlayerComponent.ts","../../src/services/GridOccupancyService.ts","../../src/systems/TreeSystem.ts","../../src/systems/ZIndexSystem.ts","../../src/components/CoinComponent.ts","../../src/components/CoinCounterComponent.ts","../../src/components/SpeedBoostComponent.ts","../../src/systems/CoinSystem.ts","../../src/components/UIComponent.ts","../../src/systems/UIRenderSystem.ts","../../src/systems/CoinCounterSystem.ts","../../src/systems/ParticleSystem.ts","../../src/systems/SpeedBoostSystem.ts","../../src/systems/VignetteSystem.ts","../../src/core/Game.ts","../../src/di/container.ts","../../src/index.ts"],"sourcesContent":["type EventCallback = (...args: any[]) => void;\n\nexport class EventEmitter {\n  private events: Map<string, EventCallback[]> = new Map();\n\n  on(event: string, callback: EventCallback): void {\n    if (!this.events.has(event)) {\n      this.events.set(event, []);\n    }\n    this.events.get(event)!.push(callback);\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const callbacks = this.events.get(event);\n    if (callbacks) {\n      callbacks.forEach(callback => callback(...args));\n    }\n  }\n\n  off(event: string, callback: EventCallback): void {\n    const callbacks = this.events.get(event);\n    if (callbacks) {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1) {\n        callbacks.splice(index, 1);\n      }\n      if (callbacks.length === 0) {\n        this.events.delete(event);\n      }\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { Entity } from './Component';\nimport { BaseSystem } from './System';\nimport { EventEmitter } from './EventEmitter';\nimport { Container } from 'inversify';\n\nexport enum GameState {\n  Playing = 'Playing',\n  GameOver = 'GameOver',\n  Starting = 'Starting'\n}\n\n@injectable()\nexport class World extends EventEmitter {\n  private systems: BaseSystem[] = [];\n  private entities: Set<Entity> = new Set();\n  private currentState: GameState = GameState.Starting;\n  private _container: Container;\n\n  constructor(container: Container) {\n    super();\n    this._container = container;\n  }\n\n  public addSystem(system: BaseSystem): void {\n    this.systems.push(system);\n    system.setWorld(this);\n  }\n\n  public addEntity(entity: Entity): void {\n    this.entities.add(entity);\n  }\n\n  public removeEntity(entity: Entity): void {\n    this.entities.delete(entity);\n  }\n\n  public clearEntities(): void {\n    this.entities.clear();\n  }\n\n  public getEntities(): Entity[] {\n    return Array.from(this.entities);\n  }\n\n  public getSystem<T extends BaseSystem>(systemType: new (...args: any[]) => T): T | undefined {\n    return this.systems.find(system => system instanceof systemType) as T | undefined;\n  }\n\n  public clearSystems(): void {\n    this.systems = [];\n  }\n\n  public cleanup(): void {\n    // Clear all entities\n    this.clearEntities();\n    \n    // Reset all systems\n    for (const system of this.systems) {\n      system.reset();\n    }\n    \n    // Clear systems\n    this.clearSystems();\n    \n    // Reset game state\n    this.currentState = GameState.Starting;\n  }\n\n  public getCurrentState(): GameState {\n    return this.currentState;\n  }\n\n  public setGameState(newState: GameState): void {\n    const oldState = this.currentState;\n    this.currentState = newState;\n    \n    // Emit state change event that systems can listen to\n    this.emit('gameStateChanged', { oldState, newState });\n\n    if (newState === GameState.GameOver) {\n      this.emit('gameOver');\n    } else if (newState === GameState.Starting) {\n      // Transition to Playing state after a short delay\n      setTimeout(() => {\n        this.setGameState(GameState.Playing);\n      }, 100);\n    }\n  }\n\n  public update(deltaTime: number): void {\n    // Only update systems if we're in Playing state\n    if (this.currentState !== GameState.Playing) {\n      return;\n    }\n\n    const entities = Array.from(this.entities);\n    for (const system of this.systems) {\n      system.update(entities, deltaTime);\n    }\n  }\n\n  public get container(): Container {\n    return this._container;\n  }\n} ","import { Entity } from './Component';\nimport { Application } from 'pixi.js';\nimport { World, GameState } from './World';\n\nexport interface System {\n  readonly requiredComponents: symbol[];\n  setApp(app: Application): void;\n  setWorld(world: World): void;\n  update(entities: Entity[], deltaTime: number): void;\n}\n\nexport abstract class BaseSystem implements System {\n  protected app: Application | null = null;\n  protected world: World | null = null;\n\n  abstract readonly requiredComponents: symbol[];\n\n  setApp(app: Application): void {\n    this.app = app;\n  }\n\n  setWorld(world: World): void {\n    this.world = world;\n    // Listen for game state changes\n    world.on('gameStateChanged', ({ oldState, newState }) => {\n      this.onGameStateChanged(oldState, newState);\n    });\n  }\n\n  /**\n   * Called when the game state changes\n   */\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to reset its state\n   */\n  public reset(): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to initialize or re-initialize\n   */\n  public initialize(): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to cleanup its resources\n   */\n  public cleanup(): void {\n    // Base implementation does nothing, systems can override\n  }\n\n  /**\n   * Called when the system needs to be fully reinitialized\n   */\n  public reinitialize(): void {\n    this.cleanup();\n    this.reset();\n    this.initialize();\n  }\n\n  update(entities: Entity[], deltaTime: number): void {\n    const relevantEntities = entities.filter(entity => \n      this.requiredComponents.every(componentType => entity.hasComponent(componentType))\n    );\n    this.updateRelevantEntities(relevantEntities, deltaTime);\n  }\n\n  protected abstract updateRelevantEntities(entities: Entity[], deltaTime: number): void;\n} ","import { Component, Entity } from '../core/Component';\n\nexport const TransformComponentType = Symbol('TransformComponent');\n\nexport class TransformComponent implements Component {\n  public readonly type = TransformComponentType;\n  public entity: Entity | null = null;\n  \n  constructor(\n    public x: number = 0,\n    public y: number = 0,\n    public rotation: number = 0\n  ) {}\n} ","import { Graphics, Container, Sprite, Texture, Assets } from 'pixi.js';\nimport { Component, Entity } from '../core/Component';\n\nexport const VisualComponentType = Symbol('VisualComponent');\n\nexport class VisualComponent implements Component {\n  public readonly type = VisualComponentType;\n  public entity: Entity | null = null;\n  public container: Container;\n  public sprite: Sprite | null = null;\n  public graphics: Graphics | null = null;\n\n  constructor(options: { radius?: number; color?: number; spritePath?: string } = {}) {\n    this.container = new Container();\n    let YOffset = - 32;\n    \n    if (options.spritePath) {\n      try {\n        const texture = Assets.get(options.spritePath);\n        this.sprite = new Sprite(texture);\n        this.sprite.anchor.set(0.5);\n        \n        // Set size to 128x128 (doubled from 64x64)\n        const targetSize = 128;\n        const scale = targetSize / Math.max(this.sprite.width, this.sprite.height);\n        this.sprite.scale.set(scale);\n        \n        // Start facing right (for DownRight movement)\n        this.sprite.scale.x = -Math.abs(this.sprite.scale.x);\n        this.sprite.y += YOffset;\n        \n        this.container.addChild(this.sprite);\n      } catch (error) {\n        console.warn(`[VisualComponent] Failed to load sprite: ${options.spritePath}`, error);\n        // Fallback to a red circle if sprite loading fails\n        this.graphics = new Graphics()\n          .circle(0, 0, 5)\n          .fill({ color: 0xFF0000 });\n        this.container.addChild(this.graphics);\n      }\n    } else {\n      this.graphics = new Graphics()\n        .circle(0, 0, options.radius || 5)\n        .fill({ color: options.color || 0xFF0000 });\n      this.container.addChild(this.graphics);\n    }\n  }\n\n  public flipX(): void {\n    if (this.sprite) {\n      this.sprite.scale.x = -this.sprite.scale.x;\n    }\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const IsometricMovementComponentType = Symbol('IsometricMovementComponent');\n\nexport enum Direction {\n  None = 'none',\n  TopRight = 'topRight',\n  TopLeft = 'topLeft',\n  DownRight = 'downRight',\n  DownLeft = 'downLeft'\n}\n\nexport class IsometricMovementComponent implements Component {\n  public readonly type = IsometricMovementComponentType;\n  public entity: Entity | null = null;\n  public currentDirection: Direction = Direction.None;\n  public targetDirection: Direction = Direction.None;\n  public isMoving: boolean = false;\n  public baseSpeed: number = 200;\n  \n  constructor(\n    public speed: number = this.baseSpeed\n  ) {}\n} ","import { Component, Entity } from '../core/Component';\n\nexport const GridPositionComponentType = Symbol('GridPositionComponent');\n\nexport class GridPositionComponent implements Component {\n  public readonly type = GridPositionComponentType;\n  public entity: Entity | null = null;\n  \n  constructor(\n    public gridX: number = 0,\n    public gridY: number = 0,\n    public targetGridX: number = 0,\n    public targetGridY: number = 0,\n    public isMoving: boolean = false\n  ) {\n    this.targetGridX = gridX;\n    this.targetGridY = gridY;\n  }\n\n  public setTargetPosition(x: number, y: number) {\n    this.targetGridX = x;\n    this.targetGridY = y;\n    this.isMoving = true;\n  }\n\n  public reachedTarget(): boolean {\n    return this.gridX === this.targetGridX && this.gridY === this.targetGridY;\n  }\n} ","import { injectable } from 'inversify';\nimport { Direction } from '../components/IsometricMovementComponent';\n\n@injectable()\nexport class GridService {\n    private readonly TILE_WIDTH = 128;\n    private readonly TILE_HEIGHT = 64;\n\n    /**\n     * Converts grid coordinates to world (screen) coordinates\n     */\n    gridToWorld(gridX: number, gridY: number): { x: number, y: number } {\n        const worldX = (gridX - gridY) * (this.TILE_WIDTH / 2);\n        const worldY = (gridX + gridY) * (this.TILE_HEIGHT / 2);\n        return { x: worldX, y: worldY };\n    }\n\n    /**\n     * Converts world coordinates to grid coordinates\n     */\n    worldToGrid(worldX: number, worldY: number): { x: number, y: number } {\n        // Using the inverse of the isometric projection\n        const gridX = (worldX / this.TILE_WIDTH + worldY / this.TILE_HEIGHT);\n        const gridY = (worldY / this.TILE_HEIGHT - worldX / this.TILE_WIDTH);\n        return { \n            x: Math.round(gridX), \n            y: Math.round(gridY) \n        };\n    }\n\n    /**\n     * Get the dimensions of a tile\n     */\n    getTileDimensions(): { width: number, height: number } {\n        return {\n            width: this.TILE_WIDTH,\n            height: this.TILE_HEIGHT\n        };\n    }\n\n    /**\n     * Get the next grid position based on direction\n     */\n    getNextGridPosition(currentX: number, currentY: number, direction: Direction): { x: number, y: number } {\n        switch (direction) {\n            case Direction.DownRight:\n                return { x: currentX + 1, y: currentY };\n            case Direction.DownLeft:\n                return { x: currentX, y: currentY + 1 };\n            case Direction.TopRight:\n                return { x: currentX, y: currentY - 1 };\n            case Direction.TopLeft:\n                return { x: currentX - 1, y: currentY };\n            default:\n                return { x: currentX, y: currentY };\n        }\n    }\n\n    /**\n     * Check if a grid position is valid\n     */\n    isValidGridPosition(x: number, y: number): boolean {\n        // Add any grid boundary checks here if needed\n        return true;\n    }\n} ","import { Component } from '../core/Component';\nimport { Entity } from '../core/Component';\n\nexport const ParticleComponentType = Symbol('ParticleComponent');\n\nexport interface ParticleData {\n  color: number;\n  size: number;\n  lifetime: number;\n  alpha: number;\n  velocityX: number;\n  velocityY: number;\n}\n\nexport class ParticleComponent implements Component {\n  public readonly type = ParticleComponentType;\n  public particles: ParticleData[] = [];\n  public isActive: boolean = false;\n  public lastDirection: { x: number, y: number } = { x: 0, y: 0 };\n  public entity: Entity | null = null;\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { IsometricMovementComponent, IsometricMovementComponentType, Direction } from '../components/IsometricMovementComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { GridService } from '../services/GridService';\nimport { Container } from 'pixi.js';\nimport { Application } from 'pixi.js';\nimport { ParticleComponent, ParticleComponentType } from '../components/ParticleComponent';\n\n@injectable()\nexport class MovementSystem extends BaseSystem {\n  public worldContainer: Container | null = null;\n\n  readonly requiredComponents = [\n    TransformComponentType,\n    VisualComponentType,\n    IsometricMovementComponentType,\n    GridPositionComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService\n  ) {\n    super();\n  }\n\n  public setApp(app: Application): void {\n    super.setApp(app);\n    if (app) {\n      this.initializeWorldContainer();\n    }\n  }\n\n  private initializeWorldContainer(): void {\n    if (!this.app) return;\n    \n    // Create a world container that will be moved around\n    this.worldContainer = new Container();\n    this.app.stage.addChild(this.worldContainer);\n    this.worldContainer.position.set(0, 0);\n  }\n\n  public cleanup(): void {\n    if (this.worldContainer && this.app) {\n      this.app.stage.removeChild(this.worldContainer);\n      this.worldContainer.destroy();\n      this.worldContainer = null;\n    }\n  }\n\n  public reinitialize(): void {\n    this.cleanup();\n    this.initializeWorldContainer();\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.worldContainer || !this.app) return;\n\n    for (const entity of entities) {\n      const transform = entity.getComponent<TransformComponent>(TransformComponentType);\n      const movement = entity.getComponent<IsometricMovementComponent>(IsometricMovementComponentType);\n      const gridPos = entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n      const visual = entity.getComponent<VisualComponent>(VisualComponentType);\n      const particleComponent = entity.getComponent<ParticleComponent>(ParticleComponentType);\n      \n      if (transform && movement && gridPos && visual) {\n        // Only set new target position if we're not already moving\n        if (!gridPos.isMoving && movement.targetDirection !== Direction.None) {\n          const nextPosition = this.gridService.getNextGridPosition(\n            gridPos.gridX,\n            gridPos.gridY,\n            movement.targetDirection\n          );\n\n          gridPos.setTargetPosition(nextPosition.x, nextPosition.y);\n          movement.currentDirection = movement.targetDirection;\n          movement.isMoving = true;\n          gridPos.isMoving = true;\n\n          // Update particle direction when starting movement\n          if (particleComponent) {\n            const direction = this.getDirectionVector(movement.targetDirection);\n            particleComponent.lastDirection = direction;\n            particleComponent.isActive = true;\n          }\n        }\n\n        if (gridPos.isMoving) {\n          // Calculate current and target positions in world space\n          const targetWorldPos = this.gridService.gridToWorld(gridPos.targetGridX, gridPos.targetGridY);\n          \n          // Calculate direction and distance to target\n          const dx = targetWorldPos.x - transform.x;\n          const dy = targetWorldPos.y - transform.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n\n          if (distance < 1) {\n            // Reached target grid position\n            transform.x = targetWorldPos.x;\n            transform.y = targetWorldPos.y;\n            gridPos.gridX = gridPos.targetGridX;\n            gridPos.gridY = gridPos.targetGridY;\n            gridPos.isMoving = false;\n            movement.isMoving = false;\n            movement.currentDirection = Direction.None;\n\n            // Stop particles when movement ends\n            if (particleComponent) {\n              particleComponent.isActive = false;\n            }\n          } else {\n            // Move towards target using the movement component's speed\n            const moveDistance = movement.speed * deltaTime;\n            const ratio = Math.min(moveDistance / distance, 1);\n\n            transform.x += dx * ratio;\n            transform.y += dy * ratio;\n          }\n\n          // Update visual position\n          visual.container.position.set(transform.x, transform.y);\n\n          // Center camera on character immediately without smoothing\n          if (this.worldContainer && this.app) {\n            // Calculate the position that will center the character on screen\n            const screenCenterX = 0;\n            const screenCenterY = 0;\n            \n            // Move the world container to center the character\n            this.worldContainer.position.x = screenCenterX - transform.x;\n            this.worldContainer.position.y = screenCenterY - transform.y;\n          }\n        } else {\n          // Even when not moving, ensure the character is centered\n          if (this.worldContainer && this.app) {\n            const screenCenterX = 0;\n            const screenCenterY = 0;\n            \n            this.worldContainer.position.x = screenCenterX - transform.x;\n            this.worldContainer.position.y = screenCenterY - transform.y;\n          }\n        }\n      }\n    }\n  }\n\n  private getDirectionVector(direction: Direction): { x: number, y: number } {\n    switch (direction) {\n      case Direction.TopRight:\n        return { x: 1, y: -1 };\n      case Direction.TopLeft:\n        return { x: -1, y: -1 };\n      case Direction.DownRight:\n        return { x: 1, y: 1 };\n      case Direction.DownLeft:\n        return { x: -1, y: 1 };\n      default:\n        return { x: 0, y: 0 };\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { IsometricMovementComponent, IsometricMovementComponentType, Direction } from '../components/IsometricMovementComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { Application } from 'pixi.js';\n\n@injectable()\nexport class InputSystem extends BaseSystem {\n  private queuedDirectionChange = false;\n  private isMovingDownRight = true; // Start with down-right direction\n  private needsFlip = false; // Track if we need to flip the sprite\n\n  readonly requiredComponents = [\n    IsometricMovementComponentType,\n    VisualComponentType,\n    GridPositionComponentType\n  ];\n\n  public reset(): void {\n    // Reset input state\n    this.queuedDirectionChange = false;\n    this.isMovingDownRight = true; // Reset to initial direction (down-right)\n    this.needsFlip = false;\n  }\n\n  setApp(app: Application): void {\n    super.setApp(app);\n    if (app.canvas) {\n      app.canvas.addEventListener('click', () => this.handleTap());\n      app.canvas.addEventListener('touchstart', () => this.handleTap());\n    }\n  }\n\n  private handleTap() {\n    // Only accept new input if we're not already processing a direction change\n    if (!this.queuedDirectionChange) {\n      this.queuedDirectionChange = true;\n      this.needsFlip = true;\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.queuedDirectionChange && !this.needsFlip) return;\n\n    for (const entity of entities) {\n      const movement = entity.getComponent<IsometricMovementComponent>(IsometricMovementComponentType);\n      const gridPos = entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n      const visual = entity.getComponent<VisualComponent>(VisualComponentType);\n      \n      if (movement && gridPos && visual) {\n        // Handle sprite flipping immediately on input\n        if (this.needsFlip) {\n          visual.flipX();\n          this.needsFlip = false;\n        }\n\n        // Handle movement direction change when reaching tile center\n        if (this.queuedDirectionChange && !gridPos.isMoving) {\n          this.isMovingDownRight = !this.isMovingDownRight;\n          movement.targetDirection = this.isMovingDownRight ? Direction.DownRight : Direction.DownLeft;\n          this.queuedDirectionChange = false;\n        }\n      }\n    }\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { Application, Graphics, Container } from 'pixi.js';\nimport { GridService } from '../services/GridService';\nimport { TransformComponentType } from '../components/TransformComponent';\nimport { World, GameState } from '../core/World';\nimport { MovementSystem } from '../systems/MovementSystem';\n\ninterface GridTile {\n  graphics: Graphics;\n  isInUse: boolean;\n  gridX: number;\n  gridY: number;\n}\n\n@injectable()\nexport class GridRenderSystem extends BaseSystem {\n  private gridContainer: Container;\n  private tilePool: GridTile[] = [];\n  private activeTiles: Map<string, GridTile> = new Map();\n  private readonly VISIBLE_RADIUS = 12;\n  private readonly POOL_SIZE = 600;\n  private lastCenterX = 0;\n  private lastCenterY = 0;\n  private isInitialized = false;\n\n  readonly requiredComponents = [\n    TransformComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService\n  ) {\n    super();\n    this.gridContainer = new Container();\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.GameOver) {\n      // Stop processing updates (handled by World)\n    } else if (newState === GameState.Starting) {\n      this.initialize();\n    }\n  }\n\n  public initialize(): void {\n    if (!this.world || !this.app?.stage) return;\n\n    this.initializeTilePool();\n    \n    // Center the grid container on screen\n    this.gridContainer.position.set(0, 0);\n    // Add to world container instead of stage\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (movementSystem && movementSystem.worldContainer) {\n      movementSystem.worldContainer.addChildAt(this.gridContainer, 0);\n    }\n    this.tilePool.forEach(tile => this.gridContainer.addChild(tile.graphics));\n    \n    // Show initial grid\n    this.updateVisibleTiles(0, 0);\n    this.isInitialized = true;\n  }\n\n  public reset(): void {\n    // Return all tiles to the pool\n    for (const [key, tile] of this.activeTiles) {\n      this.recycleTile(tile);\n    }\n\n    // Clear active tiles map\n    this.activeTiles.clear();\n\n    // Reset the visible area tracking\n    this.lastCenterX = 0;\n    this.lastCenterY = 0;\n  }\n\n  private initializeTilePool(): void {\n    for (let i = 0; i < this.POOL_SIZE; i++) {\n      const graphics = new Graphics();\n      this.createTileGraphics(graphics);\n      graphics.visible = false;\n      \n      this.tilePool.push({\n        graphics,\n        isInUse: false,\n        gridX: 0,\n        gridY: 0\n      });\n    }\n  }\n\n  private createTileGraphics(graphics: Graphics): void {\n    const { width, height } = this.gridService.getTileDimensions();\n    graphics.clear();\n    \n    // Draw filled shape\n    graphics\n      .setFillStyle({\n        color: 0xffffff,\n        alpha: 1\n      })\n      .moveTo(0, -height/2)\n      .lineTo(width/2, 0)\n      .lineTo(0, height/2)\n      .lineTo(-width/2, 0)\n      .lineTo(0, -height/2)\n      .fill();\n\n    // Draw outline\n    graphics\n      .setStrokeStyle({\n        width: 1,\n        color: 0xCCCCCC,\n        alpha: 1\n      })\n      .moveTo(0, -height/2)\n      .lineTo(width/2, 0)\n      .lineTo(0, height/2)\n      .lineTo(-width/2, 0)\n      .lineTo(0, -height/2)\n      .stroke();\n  }\n\n  private getTileKey(x: number, y: number): string {\n    return `${x},${y}`;\n  }\n\n  private getFreeTile(): GridTile | null {\n    return this.tilePool.find(tile => !tile.isInUse) || null;\n  }\n\n  private placeTile(gridX: number, gridY: number, centerX: number, centerY: number): void {\n    if (!this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    const key = this.getTileKey(gridX, gridY);\n    if (this.activeTiles.has(key)) return;\n\n    const tile = this.getFreeTile();\n    if (!tile) return;\n\n    // Use GridService for consistent world position calculation\n    const worldPos = this.gridService.worldToGrid(centerX, centerY);\n    \n    this.createTileGraphics(tile.graphics);\n    const tileWorldPos = this.gridService.gridToWorld(gridX, gridY);\n    tile.graphics.position.set(tileWorldPos.x, tileWorldPos.y);\n    tile.graphics.visible = true;\n    tile.isInUse = true;\n    tile.gridX = gridX;\n    tile.gridY = gridY;\n    \n    this.activeTiles.set(key, tile);\n\n    // Emit an event for tile creation that TreeSystem can listen to\n    if (this.world) {\n      this.world.emit('tileCreated', { gridX, gridY });\n    }\n  }\n\n  private recycleTile(tile: GridTile): void {\n    const key = this.getTileKey(tile.gridX, tile.gridY);\n    tile.graphics.visible = false;\n    tile.isInUse = false;\n    this.activeTiles.delete(key);\n  }\n\n  private updateVisibleTiles(centerX: number, centerY: number): void {\n    if (!this.app || !this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      // If the world container isn't ready yet, just return\n      return;\n    }\n\n    // Use the world container's position to determine the center\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n    \n    // Calculate the center in world coordinates\n    const centerWorldX = -worldContainerPos.x;\n    const centerWorldY = -worldContainerPos.y;\n\n    const worldPos = this.gridService.worldToGrid(centerWorldX, centerWorldY);\n    const gridCenterX = Math.floor(worldPos.x);\n    const gridCenterY = Math.floor(worldPos.y);\n\n    // Calculate visible area bounds\n    const minX = gridCenterX - this.VISIBLE_RADIUS;\n    const maxX = gridCenterX + this.VISIBLE_RADIUS;\n    const minY = gridCenterY - this.VISIBLE_RADIUS;\n    const maxY = gridCenterY + this.VISIBLE_RADIUS;\n\n    // Calculate which tiles should be visible\n    const neededTiles = new Set<string>();\n    \n    // Use symmetric bounds for tile placement\n    for (let gridX = minX; gridX <= maxX; gridX++) {\n      for (let gridY = minY; gridY <= maxY; gridY++) {\n        // Calculate Manhattan distance to center to create a more circular visible area\n        const distance = Math.abs(gridX - gridCenterX) + Math.abs(gridY - gridCenterY);\n        if (distance <= this.VISIBLE_RADIUS * 1.5) {\n          const key = this.getTileKey(gridX, gridY);\n          neededTiles.add(key);\n\n          // Place new tiles if needed\n          if (!this.activeTiles.has(key)) {\n            this.placeTile(gridX, gridY, centerWorldX, centerWorldY);\n          }\n        }\n      }\n    }\n\n    // Recycle tiles that are no longer visible\n    for (const [key, tile] of this.activeTiles) {\n      if (!neededTiles.has(key)) {\n        this.recycleTile(tile);\n      }\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage || !this.isInitialized) return;\n    if (!this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      // If the world container isn't ready yet, just return\n      return;\n    }\n\n    // Use the world container's position\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n\n    this.updateVisibleTiles(worldContainerPos.x, worldContainerPos.y);\n  }\n}","import { Component, Entity } from './Component';\n\nexport class BaseEntity implements Entity {\n  private static nextId = 0;\n  public readonly id: number;\n  public components: Map<symbol, Component>;\n\n  constructor() {\n    this.id = BaseEntity.nextId++;\n    this.components = new Map();\n  }\n\n  public addComponent(component: Component): void {\n    this.components.set(component.type, component);\n    component.entity = this;\n  }\n\n  public removeComponent(componentType: symbol): void {\n    const component = this.components.get(componentType);\n    if (component) {\n      component.entity = null;\n      this.components.delete(componentType);\n    }\n  }\n\n  public getComponent<T extends Component>(componentType: symbol): T | undefined {\n    return this.components.get(componentType) as T;\n  }\n\n  public hasComponent(componentType: symbol): boolean {\n    return this.components.has(componentType);\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const TreeComponentType = Symbol('TreeComponent');\n\nexport class TreeComponent implements Component {\n  readonly type = TreeComponentType;\n  entity: Entity | null = null;\n\n  constructor() {}\n} ","import { Component, Entity } from '../core/Component';\nimport { VisualComponent } from './VisualComponent';\nimport { GridPositionComponent } from './GridPositionComponent';\n\nexport const ZIndexComponentType = Symbol('ZIndexComponent');\n\nexport class ZIndexComponent implements Component {\n  public readonly type = ZIndexComponentType;\n  public entity: Entity | null = null;\n  \n  // Base Z-index for different types of entities\n  // This allows us to group entities and ensure certain types are always above others\n  public baseZ: number;\n\n  // UI z-index constants\n  static readonly UI = {\n    VIGNETTE: 1000,\n    COIN_COUNTER: 2000\n  };\n\n  constructor(baseZ: number = 0) {\n    this.baseZ = baseZ;\n  }\n\n  // Calculate final Z-index based on grid position\n  // Objects lower on the screen (higher Y) should appear in front\n  public calculateZ(gridPos: GridPositionComponent): number {\n    // Use Y position as main factor, higher Y means higher Z-index (appears in front)\n    // Use X position as secondary factor to maintain consistent ordering for objects on same Y\n    return this.baseZ + (gridPos.gridY * 1000) + gridPos.gridX;\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const PlayerComponentType = Symbol('PlayerComponent');\n\nexport class PlayerComponent implements Component {\n  public readonly type = PlayerComponentType;\n  public entity: Entity | null = null;\n\n  constructor() {}\n} ","import { injectable } from 'inversify';\n\nexport enum OccupancyType {\n  Tree = 'tree',\n  Coin = 'coin',\n  Character = 'character'\n}\n\n@injectable()\nexport class GridOccupancyService {\n  private occupiedCells: Map<string, Set<OccupancyType>> = new Map();\n\n  private getKey(x: number, y: number): string {\n    return `${x},${y}`;\n  }\n\n  public isOccupied(x: number, y: number, type?: OccupancyType): boolean {\n    const key = this.getKey(x, y);\n    const cell = this.occupiedCells.get(key);\n    \n    if (!cell) return false;\n    if (!type) return cell.size > 0;\n    return cell.has(type);\n  }\n\n  public occupy(x: number, y: number, type: OccupancyType): void {\n    const key = this.getKey(x, y);\n    if (!this.occupiedCells.has(key)) {\n      this.occupiedCells.set(key, new Set());\n    }\n    const cell = this.occupiedCells.get(key)!;\n    if (cell.has(type)) {\n      return;\n    }\n    cell.add(type);\n  }\n\n  public free(x: number, y: number, type: OccupancyType): void {\n    const key = this.getKey(x, y);\n    const cell = this.occupiedCells.get(key);\n    if (cell) {\n      if (!cell.has(type)) {\n        return;\n      }\n      cell.delete(type);\n      if (cell.size === 0) {\n        this.occupiedCells.delete(key);\n      }\n    } else {\n      console.warn(`[GridOccupancyService] Attempting to free non-existent cell at ${x},${y} with type ${type}`);\n    }\n  }\n\n  public reset(): void {\n    this.occupiedCells.clear();\n  }\n\n  public getOccupancyTypes(x: number, y: number): Set<OccupancyType> | undefined {\n    const key = this.getKey(x, y);\n    return this.occupiedCells.get(key);\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { BaseEntity } from '../core/BaseEntity';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { TreeComponent, TreeComponentType } from '../components/TreeComponent';\nimport { ZIndexComponent, ZIndexComponentType } from '../components/ZIndexComponent';\nimport { PlayerComponent, PlayerComponentType } from '../components/PlayerComponent';\nimport { GridService } from '../services/GridService';\nimport { GridOccupancyService, OccupancyType } from '../services/GridOccupancyService';\nimport { World, GameState } from '../core/World';\nimport { Application, Assets } from 'pixi.js';\nimport { MovementSystem } from '../systems/MovementSystem';\n\n// Z-index base values for different entity types\nconst Z_INDEX = {\n  TREE: 100\n};\n\ninterface PooledTree {\n  entity: Entity;\n  isInUse: boolean;\n  gridX: number;\n  gridY: number;\n}\n\n@injectable()\nexport class TreeSystem extends BaseSystem {\n  private readonly TREE_DENSITY = 0.05; // 5% chance of a tree on each tile\n  private readonly VISIBLE_RADIUS = 12; // Match GridRenderSystem's visible radius\n  private readonly POOL_SIZE = 100; // Maximum number of trees that can exist at once\n  \n  private treePool: PooledTree[] = [];\n  private activeTreePositions: Map<string, PooledTree> = new Map();\n  private pendingTileEvents: { gridX: number, gridY: number }[] = [];\n  private isInitialized = false;\n\n  readonly requiredComponents = [\n    GridPositionComponentType,\n    TreeComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService,\n    @inject(GridOccupancyService) private gridOccupancyService: GridOccupancyService\n  ) {\n    super();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n    // Listen for tile creation events\n    this.world.on('tileCreated', (data: { gridX: number, gridY: number }) => {\n      if (!this.isInitialized) {\n        this.pendingTileEvents.push(data);\n      } else {\n        this.trySpawnTreeAt(data.gridX, data.gridY);\n      }\n    });\n\n    // Initialize tree pool if app is already set\n    if (this.app) {\n      const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n      if (movementSystem?.worldContainer) {\n        this.initializeTreePool();\n      }\n    }\n  }\n\n  public setApp(app: Application): void {\n    this.app = app;\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.GameOver) {\n      this.reset();\n    } else if (newState === GameState.Starting) {\n      this.initialize();\n    }\n  }\n\n  public initialize(): void {\n    if (!this.world || !this.app?.stage) {\n      return;\n    }\n  }\n\n  public reset(): void {\n    // First remove all active trees from the stage and grid\n    for (const [key, tree] of this.activeTreePositions.entries()) {\n      const visual = tree.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual && visual.container.parent) {\n        visual.container.parent.removeChild(visual.container);\n      }\n      if (this.world) {\n        this.world.removeEntity(tree.entity);\n      }\n      this.gridOccupancyService.free(tree.gridX, tree.gridY, OccupancyType.Tree);\n    }\n\n    // Clear active positions map\n    this.activeTreePositions.clear();\n\n    // Clean up the pool\n    for (const tree of this.treePool) {\n      if (this.world) {\n        this.world.removeEntity(tree.entity);\n      }\n    }\n    this.treePool = [];\n    this.isInitialized = false;\n\n    // Reinitialize the pool\n    if (this.app && this.world) {\n      const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n      if (movementSystem?.worldContainer) {\n        this.initializeTreePool();\n      }\n    }\n  }\n\n  private async initializeTreePool(): Promise<void> {\n    if (!this.world || !this.app?.stage) return;\n    \n    // Get the movement system first\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      console.warn('[TreeSystem] Movement system not ready, delaying pool initialization');\n      return;\n    }\n\n    // Ensure assets are loaded\n    await Assets.load(['tree.png']);\n    \n    for (let i = 0; i < this.POOL_SIZE; i++) {\n      const tree = new BaseEntity();\n      const transform = new TransformComponent(0, 0);\n      const gridPos = new GridPositionComponent(0, 0);\n      const visual = new VisualComponent({\n        spritePath: 'tree.png',\n      });\n      const treeComponent = new TreeComponent();\n      const zIndex = new ZIndexComponent(Z_INDEX.TREE);\n\n      tree.addComponent(transform);\n      tree.addComponent(gridPos);\n      tree.addComponent(visual);\n      tree.addComponent(treeComponent);\n      tree.addComponent(zIndex);\n\n      this.world.addEntity(tree);\n      \n      // Add to world container\n      movementSystem.worldContainer.addChild(visual.container);\n      visual.container.visible = false;\n\n      this.treePool.push({\n        entity: tree,\n        isInUse: false,\n        gridX: 0,\n        gridY: 0\n      });\n    }\n    \n    // Mark as initialized and process any pending tile events\n    this.isInitialized = true;\n    this.processPendingTileEvents();\n  }\n\n  private processPendingTileEvents(): void {\n    if (!this.isInitialized) return;\n    \n    // Process all pending tile events\n    for (const event of this.pendingTileEvents) {\n      this.trySpawnTreeAt(event.gridX, event.gridY);\n    }\n    this.pendingTileEvents = [];\n  }\n\n  private removeTree(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    const tree = this.activeTreePositions.get(key);\n    \n    if (tree) {\n      const visual = tree.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual) {\n        visual.container.visible = false;\n      }\n      \n      // Mark the tree as not in use in the pool\n      tree.isInUse = false;\n      tree.gridX = 0;\n      tree.gridY = 0;\n      \n      this.gridOccupancyService.free(gridX, gridY, OccupancyType.Tree);\n      this.activeTreePositions.delete(key);\n    }\n  }\n\n  public spawnTree(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    if (this.activeTreePositions.has(key)) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    // Find an unused tree from the pool\n    const unusedTreeIndex = this.treePool.findIndex(tree => !tree.isInUse);\n    if (unusedTreeIndex === -1) {\n      console.warn('[TreeSystem] Tree pool exhausted. Active trees:', this.activeTreePositions.size);\n      return;\n    }\n\n    const unusedTree = this.treePool[unusedTreeIndex];\n    const worldPos = this.gridService.gridToWorld(gridX, gridY);\n    \n    // Update the tree's components\n    const transform = unusedTree.entity.getComponent<TransformComponent>(TransformComponentType);\n    const gridPos = unusedTree.entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n    const visual = unusedTree.entity.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (!transform || !gridPos || !visual) {\n      console.warn('[TreeSystem] Missing required components for tree');\n      return;\n    }\n\n    // Get the movement system and world container\n    const movementSystem = this.world?.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      console.warn('[TreeSystem] Movement system or world container not ready');\n      return;\n    }\n\n    // Update transform and position\n    transform.x = worldPos.x;\n    transform.y = worldPos.y;\n    gridPos.gridX = gridX;\n    gridPos.gridY = gridY;\n    visual.container.visible = true;\n    visual.container.position.set(transform.x, transform.y);\n\n    // Ensure the visual container is in the world container\n    if (!visual.container.parent) {\n      movementSystem.worldContainer.addChild(visual.container);\n    }\n\n    // Mark the tree as in use in the pool\n    unusedTree.isInUse = true;\n    unusedTree.gridX = gridX;\n    unusedTree.gridY = gridY;\n    \n    this.activeTreePositions.set(key, unusedTree);\n    this.gridOccupancyService.occupy(gridX, gridY, OccupancyType.Tree);\n  }\n\n  public trySpawnTreeAt(gridX: number, gridY: number): void {\n    if (!this.world) return;\n    if (this.world.getCurrentState() !== GameState.Playing) return;\n\n    const distanceFromStart = Math.abs(gridX) + Math.abs(gridY);\n    \n    if (distanceFromStart < 20) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    const roll = Math.random();\n    if (roll < this.TREE_DENSITY) {\n      this.spawnTree(gridX, gridY);\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage || this.world?.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      return;\n    }\n\n    // Update positions of all trees\n    for (const tree of this.activeTreePositions.values()) {\n      this.updateTreePosition(tree.entity);\n    }\n\n    // Check for collisions with players\n    const players = this.world?.getEntities().filter(entity => \n      entity.hasComponent(PlayerComponentType) &&\n      entity.hasComponent(GridPositionComponentType)\n    );\n\n    if (players) {\n      for (const player of players) {\n        const playerGridPos = player.getComponent<GridPositionComponent>(GridPositionComponentType);\n        if (playerGridPos) {\n          // First check grid occupancy service\n          if (this.gridOccupancyService.isOccupied(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Tree)) {\n            // Verify against active trees to ensure the tree still exists\n            const key = `${playerGridPos.gridX},${playerGridPos.gridY}`;\n            if (this.activeTreePositions.has(key)) {\n              this.world?.setGameState(GameState.GameOver);\n              return;\n            } else {\n              // If we found an occupancy but no active tree, clean up the occupancy\n              this.gridOccupancyService.free(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Tree);\n            }\n          }\n        }\n      }\n    }\n\n    // Clean up trees that are too far from the center\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n\n    const centerWorldX = -worldContainerPos.x;\n    const centerWorldY = -worldContainerPos.y;\n\n    const worldPos = this.gridService.worldToGrid(centerWorldX, centerWorldY);\n    const gridCenterX = Math.floor(worldPos.x);\n    const gridCenterY = Math.floor(worldPos.y);\n\n    // Remove trees that are too far from view\n    for (const [key, tree] of this.activeTreePositions.entries()) {\n      const gridPos = tree.entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n      if (gridPos) {\n        const distance = Math.abs(gridPos.gridX - gridCenterX) + Math.abs(gridPos.gridY - gridCenterY);\n        if (distance > this.VISIBLE_RADIUS * 1.5) {\n          this.removeTree(gridPos.gridX, gridPos.gridY);\n        }\n      }\n    }\n  }\n\n  private updateTreePosition(tree: Entity): void {\n    const transform = tree.getComponent<TransformComponent>(TransformComponentType);\n    const visual = tree.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (transform && visual) {\n      visual.container.position.set(transform.x, transform.y);\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { ZIndexComponent, ZIndexComponentType } from '../components/ZIndexComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\n\n@injectable()\nexport class ZIndexSystem extends BaseSystem {\n  readonly requiredComponents = [\n    ZIndexComponentType,\n    GridPositionComponentType,\n    VisualComponentType\n  ];\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage) return;\n\n    // Sort entities by their Z-index\n    const sortedEntities = [...entities].sort((a, b) => {\n      const aZIndex = this.getEntityZIndex(a);\n      const bZIndex = this.getEntityZIndex(b);\n      return aZIndex - bZIndex;\n    });\n\n    // Update display object z-index (which is determined by the order in the container's children array)\n    sortedEntities.forEach(entity => {\n      const visual = entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual?.container) {\n        // Remove and re-add to update position in children array\n        const parent = visual.container.parent;\n        if (parent) {\n          parent.removeChild(visual.container);\n          parent.addChild(visual.container);\n        }\n      }\n    });\n  }\n\n  private getEntityZIndex(entity: Entity): number {\n    const zIndex = entity.getComponent<ZIndexComponent>(ZIndexComponentType);\n    const gridPos = entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n    \n    if (!zIndex || !gridPos) return 0;\n    return zIndex.calculateZ(gridPos);\n  }\n} ","import { Component, Entity } from '../core/Component';\n\nexport const CoinComponentType = Symbol('CoinComponent');\n\nexport class CoinComponent implements Component {\n  public readonly type = CoinComponentType;\n  public entity: Entity | null = null;\n} ","import { Component } from '../core/Component';\nimport { Entity } from '../core/Component';\n\nexport const CoinCounterComponentType = Symbol('CoinCounterComponent');\n\nexport class CoinCounterComponent implements Component {\n  public readonly type = CoinCounterComponentType;\n  public entity: Entity | null = null;\n  private count: number = 0;\n  private highscore: number = 0;\n\n  constructor() {\n    // Load highscore from localStorage\n    const savedHighscore = localStorage.getItem('coinHighscore');\n    if (savedHighscore) {\n      this.highscore = parseInt(savedHighscore, 10);\n    }\n  }\n\n  public increment(): void {\n    this.count++;\n    // Update highscore if current count is higher\n    if (this.count > this.highscore) {\n      this.highscore = this.count;\n      localStorage.setItem('coinHighscore', this.highscore.toString());\n    }\n  }\n\n  public getCount(): number {\n    return this.count;\n  }\n\n  public getHighscore(): number {\n    return this.highscore;\n  }\n\n  public reset(): void {\n    this.count = 0;\n  }\n} ","import { Component } from '../core/Component';\n\nexport const SpeedBoostComponentType = Symbol('SpeedBoostComponent');\n\nexport class SpeedBoostComponent implements Component {\n  readonly type = SpeedBoostComponentType;\n  entity: Component['entity'] = null;\n  private speedMultiplier: number = 1.0;\n  private readonly BOOST_PER_COIN = 0.1; // 10% speed increase per coin\n  private readonly MAX_MULTIPLIER = Infinity; // Maximum 2x speed\n\n  public addBoost(): void {\n    this.speedMultiplier = Math.min(this.speedMultiplier + this.BOOST_PER_COIN, this.MAX_MULTIPLIER);\n  }\n\n  public getSpeedMultiplier(): number {\n    return this.speedMultiplier;\n  }\n\n  public reset(): void {\n    this.speedMultiplier = 1.0;\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { BaseEntity } from '../core/BaseEntity';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { GridPositionComponent, GridPositionComponentType } from '../components/GridPositionComponent';\nimport { CoinComponent, CoinComponentType } from '../components/CoinComponent';\nimport { ZIndexComponent, ZIndexComponentType } from '../components/ZIndexComponent';\nimport { PlayerComponentType } from '../components/PlayerComponent';\nimport { GridService } from '../services/GridService';\nimport { GridOccupancyService, OccupancyType } from '../services/GridOccupancyService';\nimport { World, GameState } from '../core/World';\nimport { MovementSystem } from '../systems/MovementSystem';\nimport { CoinCounterComponent, CoinCounterComponentType } from '../components/CoinCounterComponent';\nimport { SpeedBoostComponent, SpeedBoostComponentType } from '../components/SpeedBoostComponent';\nimport { Application } from 'pixi.js';\n\nconst Z_INDEX = {\n  COIN: 50 // Between tiles and trees\n};\n\ninterface PooledCoin {\n  entity: Entity;\n  isInUse: boolean;\n  gridX: number;\n  gridY: number;\n}\n\n@injectable()\nexport class CoinSystem extends BaseSystem {\n  private readonly COIN_DENSITY = 0.01; // 1% chance of a coin on each tile\n  private readonly VISIBLE_RADIUS = 12; // Match GridRenderSystem's visible radius\n  private readonly POOL_SIZE = 50; // Maximum number of coins that can exist at once\n  \n  private coinPool: PooledCoin[] = [];\n  private activeCoinPositions: Map<string, PooledCoin> = new Map();\n\n  readonly requiredComponents = [\n    GridPositionComponentType,\n    CoinComponentType\n  ];\n\n  constructor(\n    @inject(GridService) private gridService: GridService,\n    @inject(GridOccupancyService) private gridOccupancyService: GridOccupancyService\n  ) {\n    super();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n    // Listen for tile creation events\n    this.world.on('tileCreated', (data: { gridX: number, gridY: number }) => {\n      this.trySpawnCoinAt(data.gridX, data.gridY);\n    });\n\n    // Initialize coin pool if app is already set\n    if (this.app) {\n      this.initializeCoinPool();\n    }\n  }\n\n  public setApp(app: Application): void {\n    this.app = app;\n  }\n\n  private initializeCoinPool(): void {\n    if (!this.world || !this.app?.stage) return;\n    \n    for (let i = 0; i < this.POOL_SIZE; i++) {\n      const coin = new BaseEntity();\n      const transform = new TransformComponent(0, 0);\n      const gridPos = new GridPositionComponent(0, 0);\n      const visual = new VisualComponent({\n        spritePath: 'coin.png',\n      });\n      const coinComponent = new CoinComponent();\n      const zIndex = new ZIndexComponent(Z_INDEX.COIN);\n\n      coin.addComponent(transform);\n      coin.addComponent(gridPos);\n      coin.addComponent(visual);\n      coin.addComponent(coinComponent);\n      coin.addComponent(zIndex);\n\n      this.world.addEntity(coin);\n      // Add to world container instead of stage\n      const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n      if (movementSystem && movementSystem.worldContainer) {\n        movementSystem.worldContainer.addChild(visual.container);\n      }\n      visual.container.visible = false;\n\n      this.coinPool.push({\n        entity: coin,\n        isInUse: false,\n        gridX: 0,\n        gridY: 0\n      });\n    }\n  }\n\n  private removeCoin(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    const coin = this.activeCoinPositions.get(key);\n    \n    if (coin) {\n      const visual = coin.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual) {\n        visual.container.visible = false;\n      }\n      \n      // Mark the coin as not in use in the pool\n      coin.isInUse = false;\n      coin.gridX = 0;\n      coin.gridY = 0;\n      \n      this.gridOccupancyService.free(gridX, gridY, OccupancyType.Coin);\n      this.activeCoinPositions.delete(key);\n    }\n  }\n\n  public spawnCoin(gridX: number, gridY: number): void {\n    const key = `${gridX},${gridY}`;\n    if (this.activeCoinPositions.has(key)) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    // Find an unused coin from the pool\n    const unusedCoinIndex = this.coinPool.findIndex(coin => !coin.isInUse);\n    if (unusedCoinIndex === -1) {\n      console.warn('[CoinSystem] Coin pool exhausted. Active coins:', this.activeCoinPositions.size);\n      return;\n    }\n\n    const unusedCoin = this.coinPool[unusedCoinIndex];\n    const worldPos = this.gridService.gridToWorld(gridX, gridY);\n    \n    // Update the coin's components\n    const transform = unusedCoin.entity.getComponent<TransformComponent>(TransformComponentType);\n    const gridPos = unusedCoin.entity.getComponent<GridPositionComponent>(GridPositionComponentType);\n    const visual = unusedCoin.entity.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (!transform || !gridPos || !visual) {\n      console.warn('[CoinSystem] Missing required components for coin');\n      return;\n    }\n\n    // Get the movement system and world container\n    const movementSystem = this.world?.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      console.warn('[CoinSystem] Movement system or world container not ready');\n      return;\n    }\n\n    // Update transform and position\n    transform.x = worldPos.x;\n    transform.y = worldPos.y;\n    gridPos.gridX = gridX;\n    gridPos.gridY = gridY;\n    visual.container.visible = true;\n    visual.container.position.set(transform.x, transform.y);\n\n    // Ensure the visual container is in the world container\n    if (!visual.container.parent) {\n      movementSystem.worldContainer.addChild(visual.container);\n    }\n\n    // Mark the coin as in use in the pool\n    unusedCoin.isInUse = true;\n    unusedCoin.gridX = gridX;\n    unusedCoin.gridY = gridY;\n    \n    this.activeCoinPositions.set(key, unusedCoin);\n    this.gridOccupancyService.occupy(gridX, gridY, OccupancyType.Coin);\n  }\n\n  public trySpawnCoinAt(gridX: number, gridY: number): void {\n    if (!this.world) return;\n    if (this.world.getCurrentState() !== GameState.Playing) return;\n\n    const distanceFromStart = Math.abs(gridX) + Math.abs(gridY);\n    \n    if (distanceFromStart < 20) {\n      return;\n    }\n\n    if (this.gridOccupancyService.isOccupied(gridX, gridY)) {\n      return;\n    }\n\n    const roll = Math.random();\n    if (roll < this.COIN_DENSITY) {\n      this.spawnCoin(gridX, gridY);\n    }\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.GameOver) {\n      this.reset();\n    } else if (newState === GameState.Starting) {\n      this.initialize();\n    }\n  }\n\n  public initialize(): void {\n    if (!this.world || !this.app?.stage) {\n      return;\n    }\n  }\n\n  public reset(): void {\n    // First remove all active coins from the stage and grid\n    for (const [key, coin] of this.activeCoinPositions.entries()) {\n      const visual = coin.entity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual && visual.container.parent) {\n        visual.container.parent.removeChild(visual.container);\n      }\n      if (this.world) {\n        this.world.removeEntity(coin.entity);\n      }\n      this.gridOccupancyService.free(coin.gridX, coin.gridY, OccupancyType.Coin);\n    }\n\n    // Clear active positions map\n    this.activeCoinPositions.clear();\n\n    // Clean up the pool\n    for (const coin of this.coinPool) {\n      if (this.world) {\n        this.world.removeEntity(coin.entity);\n      }\n    }\n    this.coinPool = [];\n\n    // Reinitialize the pool\n    if (this.app && this.world) {\n      this.initializeCoinPool();\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app?.stage || !this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    // Get the movement system to access the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (!movementSystem?.worldContainer) {\n      return;\n    }\n\n    // Update positions of all coins\n    for (const coin of this.activeCoinPositions.values()) {\n      this.updateCoinPosition(coin.entity);\n    }\n\n    // Check for collisions with players\n    const players = this.world.getEntities().filter(entity => \n      entity.hasComponent(PlayerComponentType) &&\n      entity.hasComponent(GridPositionComponentType)\n    );\n\n    for (const player of players) {\n      const playerGridPos = player.getComponent<GridPositionComponent>(GridPositionComponentType);\n      if (playerGridPos) {\n        // First check grid occupancy service\n        if (this.gridOccupancyService.isOccupied(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Coin)) {\n          // Verify against active coins to ensure the coin still exists\n          const key = `${playerGridPos.gridX},${playerGridPos.gridY}`;\n          if (this.activeCoinPositions.has(key)) {\n            const coin = this.activeCoinPositions.get(key);\n            if (coin) {\n              this.handleCoinCollection(coin.entity);\n              this.removeCoin(playerGridPos.gridX, playerGridPos.gridY);\n            }\n          } else {\n            // If we found an occupancy but no active coin, clean up the occupancy\n            this.gridOccupancyService.free(playerGridPos.gridX, playerGridPos.gridY, OccupancyType.Coin);\n          }\n        }\n      }\n    }\n\n    // Clean up coins that are too far from the center\n    const worldContainerPos = movementSystem.worldContainer.position;\n    if (!worldContainerPos) {\n      return;\n    }\n\n    const centerWorldX = -worldContainerPos.x;\n    const centerWorldY = -worldContainerPos.y;\n\n    const worldPos = this.gridService.worldToGrid(centerWorldX, centerWorldY);\n    const gridCenterX = Math.floor(worldPos.x);\n    const gridCenterY = Math.floor(worldPos.y);\n\n    // Remove coins that are too far from view\n    for (const [key, coin] of this.activeCoinPositions.entries()) {\n      const distance = Math.abs(coin.gridX - gridCenterX) + Math.abs(coin.gridY - gridCenterY);\n      if (distance > this.VISIBLE_RADIUS * 1.5) {\n        this.removeCoin(coin.gridX, coin.gridY);\n      }\n    }\n  }\n\n  private updateCoinPosition(coin: Entity): void {\n    const transform = coin.getComponent<TransformComponent>(TransformComponentType);\n    const visual = coin.getComponent<VisualComponent>(VisualComponentType);\n    \n    if (transform && visual) {\n      visual.container.position.set(transform.x, transform.y);\n    }\n  }\n\n  private handleCoinCollection(coinEntity: Entity): void {\n    // Find the coin counter entity\n    const entities = this.world?.getEntities() || [];\n    const counterEntity = entities.find(entity => entity.hasComponent(CoinCounterComponentType));\n    \n    if (counterEntity) {\n      const counter = counterEntity.getComponent<CoinCounterComponent>(CoinCounterComponentType);\n      if (counter) {\n        counter.increment();\n      }\n    }\n\n    // Add speed boost to the player\n    const player = entities.find(entity => entity.hasComponent(PlayerComponentType));\n    if (player) {\n      const speedBoost = player.getComponent<SpeedBoostComponent>(SpeedBoostComponentType);\n      if (speedBoost) {\n        speedBoost.addBoost();\n      }\n    }\n\n    // Remove the coin from the pool and world\n    const poolItem = this.coinPool.find(item => item.entity === coinEntity);\n    if (poolItem) {\n      poolItem.isInUse = false;\n      const visual = coinEntity.getComponent<VisualComponent>(VisualComponentType);\n      if (visual) {\n        visual.container.visible = false;\n      }\n    }\n  }\n} ","import { Component } from '../core/Component';\nimport { Container, Text, TextStyle, TextStyleAlign } from 'pixi.js';\nimport { Entity } from '../core/Component';\n\nexport const UIComponentType = Symbol('UIComponent');\n\nexport interface UIConfig {\n  text?: string;\n  x?: number;\n  y?: number;\n  style?: Partial<TextStyle>;\n  align?: TextStyleAlign;\n}\n\nexport class UIComponent implements Component {\n  public readonly type = UIComponentType;\n  public container: Container;\n  public text: Text;\n  public entity: Entity | null = null;\n\n  constructor(config: UIConfig = {}) {\n    this.container = new Container();\n    \n    // Create text with default style\n    const style: Partial<TextStyle> = {\n      fontFamily: 'Arial',\n      fontSize: 24,\n      fill: 0xFFFFFF,\n      stroke: {\n        color: 0x000000,\n        width: 4\n      },\n      align: 'center',\n      ...config.style\n    };\n\n    // Use new Text constructor syntax for PixiJS v8\n    this.text = new Text({\n      text: config.text || '',\n      style\n    });\n    this.container.addChild(this.text);\n\n    // Set position if provided\n    if (config.x !== undefined) this.container.x = config.x;\n    if (config.y !== undefined) this.container.y = config.y;\n\n    // Center the text within its container\n    this.text.anchor.set(0.5);\n  }\n\n  public setText(text: string): void {\n    this.text.text = text;\n  }\n\n  public setPosition(x: number, y: number): void {\n    this.container.x = x;\n    this.container.y = y;\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { UIComponent, UIComponentType } from '../components/UIComponent';\nimport { Application, Container } from 'pixi.js';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\n\n@injectable()\nexport class UIRenderSystem extends BaseSystem {\n  private uiContainer: Container;\n  readonly requiredComponents = [UIComponentType];\n\n  constructor() {\n    super();\n    this.uiContainer = new Container();\n    // Set a very high z-index to ensure UI is always on top\n    this.uiContainer.zIndex = 10000;\n  }\n\n  public setApp(app: Application): void {\n    super.setApp(app);\n    if (app) {\n      app.stage.addChild(this.uiContainer);\n    }\n  }\n\n  public cleanup(): void {\n    if (this.uiContainer && this.app) {\n      this.app.stage.removeChild(this.uiContainer);\n      this.uiContainer.destroy();\n      this.uiContainer = new Container();\n      this.uiContainer.zIndex = 10000;\n    }\n  }\n\n  public reinitialize(): void {\n    this.cleanup();\n    if (this.app) {\n      this.app.stage.addChild(this.uiContainer);\n    }\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app) return;\n\n    for (const entity of entities) {\n      const ui = entity.getComponent<UIComponent>(UIComponentType);\n      if (ui && !this.uiContainer.children.includes(ui.container)) {\n        this.uiContainer.addChild(ui.container);\n      }\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { CoinCounterComponent, CoinCounterComponentType } from '../components/CoinCounterComponent';\nimport { UIComponent, UIComponentType } from '../components/UIComponent';\nimport { GameState } from '../core/World';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\n\n@injectable()\nexport class CoinCounterSystem extends BaseSystem {\n  readonly requiredComponents = [CoinCounterComponentType, UIComponentType];\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    for (const entity of entities) {\n      const counter = entity.getComponent<CoinCounterComponent>(CoinCounterComponentType);\n      const ui = entity.getComponent<UIComponent>(UIComponentType);\n      \n      if (counter && ui) {\n        const newText = `Coins: ${counter.getCount()} (High: ${counter.getHighscore()})`;\n        if (ui.text.text !== newText) {\n          ui.setText(newText);\n        }\n        // Ensure proper z-index\n        ui.container.zIndex = ZIndexComponent.UI.COIN_COUNTER;\n      }\n    }\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.Starting) {\n      // Reset counter when game restarts\n      const entities = this.world?.getEntities() || [];\n      for (const entity of entities) {\n        const counter = entity.getComponent<CoinCounterComponent>(CoinCounterComponentType);\n        if (counter) {\n          counter.reset();\n          // Force UI update after reset\n          const ui = entity.getComponent<UIComponent>(UIComponentType);\n          if (ui) {\n            ui.setText(`Coins: ${counter.getCount()} (High: ${counter.getHighscore()})`);\n            // Ensure proper z-index\n            ui.container.zIndex = ZIndexComponent.UI.COIN_COUNTER;\n          }\n        }\n      }\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { ParticleComponent, ParticleComponentType, ParticleData } from '../components/ParticleComponent';\nimport { TransformComponent, TransformComponentType } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { World, GameState } from '../core/World';\nimport { Application, Graphics } from 'pixi.js';\nimport { MovementSystem } from './MovementSystem';\n\n@injectable()\nexport class ParticleSystem extends BaseSystem {\n  private readonly PARTICLE_LIFETIME = 1; // seconds\n  private readonly PARTICLE_SPAWN_RATE = 0.05; // seconds - more frequent spawning\n  private readonly PARTICLE_SIZE = 4; // Increased size\n  private readonly PARTICLE_COLOR = 0x777777;\n  private readonly PARTICLE_ALPHA = 0.5; // Increased alpha\n  private readonly PARTICLE_INITIAL_SPEED = 300; // Increased initial speed\n  private readonly PARTICLE_DRAG = 0.98; // Reduced drag for longer trails\n\n  private particleContainer: Graphics | null = null;\n  private timeSinceLastSpawn: number = 0;\n\n  readonly requiredComponents = [\n    ParticleComponentType,\n    TransformComponentType,\n    VisualComponentType\n  ];\n\n  constructor() {\n    super();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n  }\n\n  public setApp(app: Application): void {\n    super.setApp(app);\n    this.initializeParticleContainer();\n  }\n\n  private initializeParticleContainer(): void {\n    if (!this.app?.stage) return;\n    \n    // Clean up existing container if it exists\n    if (this.particleContainer) {\n      this.particleContainer.destroy();\n      this.particleContainer = null;\n    }\n\n    // Create new container\n    this.particleContainer = new Graphics();\n    \n    // Add to world container instead of stage\n    const movementSystem = this.world?.getSystem<MovementSystem>(MovementSystem);\n    if (movementSystem?.worldContainer) {\n      movementSystem.worldContainer.addChild(this.particleContainer);\n    }\n  }\n\n  public cleanup(): void {\n    if (this.particleContainer) {\n      this.particleContainer.destroy();\n      this.particleContainer = null;\n    }\n  }\n\n  public reinitialize(): void {\n    this.cleanup();\n    this.initializeParticleContainer();\n  }\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.app || !this.particleContainer) return;\n\n    // Clear previous frame's particles\n    this.particleContainer.clear();\n\n    for (const entity of entities) {\n      const particleComponent = entity.getComponent<ParticleComponent>(ParticleComponentType);\n      if (particleComponent) {\n        const transform = entity.getComponent<TransformComponent>(TransformComponentType);\n        if (transform && particleComponent.isActive) {\n          // Spawn new particles\n          this.timeSinceLastSpawn += deltaTime;\n          if (this.timeSinceLastSpawn >= this.PARTICLE_SPAWN_RATE) {\n            this.spawnParticles(particleComponent, transform);\n            this.timeSinceLastSpawn = 0;\n          }\n        }\n        this.updateParticles(particleComponent, deltaTime);\n      }\n    }\n  }\n\n  private updateParticles(particleComponent: ParticleComponent, deltaTime: number): void {\n    const transform = particleComponent.entity?.getComponent<TransformComponent>(TransformComponentType);\n    if (!transform || !this.particleContainer) return;\n\n    // Update and draw each particle\n    for (let i = particleComponent.particles.length - 1; i >= 0; i--) {\n      const particle = particleComponent.particles[i];\n      particle.lifetime -= deltaTime;\n\n      if (particle.lifetime <= 0) {\n        particleComponent.particles.splice(i, 1);\n        continue;\n      }\n\n      // Update position\n      const progress = 1 - (particle.lifetime / this.PARTICLE_LIFETIME);\n      const alpha = this.PARTICLE_ALPHA * (1 - progress);\n      const size = particle.size * (1 - progress);\n      \n      // Calculate world position\n      const worldX = transform.x + particle.velocityX * progress;\n      const worldY = transform.y + particle.velocityY * progress;\n      \n      // Draw particle using new v8 API\n      this.particleContainer\n        .circle(worldX, worldY, size)\n        .fill({ color: particle.color, alpha: alpha });\n    }\n  }\n\n  private spawnParticles(particleComponent: ParticleComponent, transform: TransformComponent): void {\n    // Spawn particles in the opposite direction of movement\n    const direction = particleComponent.lastDirection;\n    const angle = Math.atan2(direction.y, direction.x);\n    \n    // Spawn 2-3 particles\n    const count = Math.floor(Math.random() * 2) + 2;\n    \n    for (let i = 0; i < count; i++) {\n      const spread = (Math.random() - 0.5) * Math.PI / 4; // Random spread\n      const particleAngle = angle + Math.PI + spread;\n      \n      const particle: ParticleData = {\n        color: this.PARTICLE_COLOR,\n        size: this.PARTICLE_SIZE,\n        lifetime: this.PARTICLE_LIFETIME,\n        alpha: this.PARTICLE_ALPHA,\n        velocityX: Math.cos(particleAngle) * this.PARTICLE_INITIAL_SPEED,\n        velocityY: Math.sin(particleAngle) * this.PARTICLE_INITIAL_SPEED\n      };\n      \n      particleComponent.particles.push(particle);\n    }\n  }\n} ","import { injectable } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Entity } from '../core/Component';\nimport { SpeedBoostComponent, SpeedBoostComponentType } from '../components/SpeedBoostComponent';\nimport { IsometricMovementComponent, IsometricMovementComponentType } from '../components/IsometricMovementComponent';\nimport { World, GameState } from '../core/World';\n\n@injectable()\nexport class SpeedBoostSystem extends BaseSystem {\n  readonly requiredComponents = [\n    SpeedBoostComponentType,\n    IsometricMovementComponentType\n  ];\n\n  protected updateRelevantEntities(entities: Entity[], deltaTime: number): void {\n    if (!this.world || this.world.getCurrentState() !== GameState.Playing) return;\n\n    for (const entity of entities) {\n      const speedBoost = entity.getComponent<SpeedBoostComponent>(SpeedBoostComponentType);\n      const movement = entity.getComponent<IsometricMovementComponent>(IsometricMovementComponentType);\n      \n      if (speedBoost && movement) {\n        // Apply the speed multiplier to the movement speed\n        movement.speed = movement.baseSpeed * speedBoost.getSpeedMultiplier();\n      }\n    }\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.Starting) {\n      // Reset speed boosts when game restarts\n      const entities = this.world?.getEntities() || [];\n      for (const entity of entities) {\n        const speedBoost = entity.getComponent<SpeedBoostComponent>(SpeedBoostComponentType);\n        if (speedBoost) {\n          speedBoost.reset();\n        }\n      }\n    }\n  }\n} ","import { injectable, inject } from 'inversify';\nimport { BaseSystem } from '../core/System';\nimport { Application, Sprite, Assets } from 'pixi.js';\nimport { GridService } from '../services/GridService';\nimport { World, GameState } from '../core/World';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\n\n@injectable()\nexport class VignetteSystem extends BaseSystem {\n  private vignetteSprite: Sprite | null = null;\n  readonly requiredComponents: symbol[] = []; // No required components for this system\n\n  constructor(\n    @inject(GridService) private gridService: GridService\n  ) {\n    super();\n  }\n\n  public setApp(app: Application): void {\n    this.app = app;\n    this.initializeVignette();\n  }\n\n  public setWorld(world: World): void {\n    this.world = world;\n  }\n\n  protected onGameStateChanged(oldState: GameState, newState: GameState): void {\n    if (newState === GameState.Starting || newState === GameState.Playing) {\n      this.initializeVignette();\n      this.updateVignetteScale();\n    }\n  }\n\n  private async initializeVignette(): Promise<void> {\n    if (!this.app || !this.world) {\n      console.log('[VignetteSystem] Waiting for app and world to be ready');\n      return;\n    }\n\n    console.log('[VignetteSystem] Initializing vignette');\n    \n    // Remove old vignette if it exists\n    if (this.vignetteSprite && this.vignetteSprite.parent) {\n      this.vignetteSprite.parent.removeChild(this.vignetteSprite);\n    }\n\n    // Ensure assets are loaded\n    await Assets.load(['vignette3.png']);\n    \n    // Create vignette sprite\n    const texture = Assets.get('vignette3.png');\n    this.vignetteSprite = new Sprite(texture);\n    \n    // Center the sprite\n    this.vignetteSprite.anchor.set(0.5);\n    \n    // Set z-index\n    this.vignetteSprite.zIndex = ZIndexComponent.UI.VIGNETTE;\n    \n    // Make it invisible until properly scaled\n    this.vignetteSprite.visible = false;\n    \n    // Add to stage\n    this.app.stage.addChild(this.vignetteSprite);\n    console.log('[VignetteSystem] Added vignette to stage');\n  }\n\n  private updateVignetteScale(): void {\n    if (!this.app || !this.vignetteSprite || !this.world) return;\n\n    // Calculate visible area based on grid dimensions\n    const { width: tileWidth, height: tileHeight } = this.gridService.getTileDimensions();\n    const visibleRadius = 10; // Match GridRenderSystem's visible radius\n    \n    // Calculate the actual visible area in world coordinates\n    const visibleWidth = tileWidth * visibleRadius * 2;\n    const visibleHeight = tileHeight * visibleRadius * 2;\n    \n    // Scale to match the visible grid area exactly\n    const scale = Math.max(visibleWidth, visibleHeight) / 512;\n    \n    this.vignetteSprite.scale.set(scale);\n    this.vignetteSprite.visible = true;\n  }\n\n  protected updateRelevantEntities(entities: any[], deltaTime: number): void {\n    // Update scale whenever we have a vignette and the world is ready\n    if (this.vignetteSprite && this.world && this.app && this.gridService) {\n      this.updateVignetteScale();\n    }\n  }\n} ","import { Application, Assets } from 'pixi.js';\nimport { injectable, inject } from 'inversify';\nimport { World, GameState } from './World';\nimport { MovementSystem } from '../systems/MovementSystem';\nimport { InputSystem } from '../systems/InputSystem';\nimport { GridRenderSystem } from '../systems/GridRenderSystem';\nimport { TreeSystem } from '../systems/TreeSystem';\nimport { ZIndexSystem } from '../systems/ZIndexSystem';\nimport { CoinSystem } from '../systems/CoinSystem';\nimport { BaseEntity } from './BaseEntity';\nimport { TransformComponent } from '../components/TransformComponent';\nimport { VisualComponent, VisualComponentType } from '../components/VisualComponent';\nimport { IsometricMovementComponent, Direction } from '../components/IsometricMovementComponent';\nimport { GridPositionComponent } from '../components/GridPositionComponent';\nimport { ZIndexComponent } from '../components/ZIndexComponent';\nimport { PlayerComponent } from '../components/PlayerComponent';\nimport { GridOccupancyService } from '../services/GridOccupancyService';\nimport { UIRenderSystem } from '../systems/UIRenderSystem';\nimport { CoinCounterSystem } from '../systems/CoinCounterSystem';\nimport { UIComponent, UIComponentType } from '../components/UIComponent';\nimport { CoinCounterComponent } from '../components/CoinCounterComponent';\nimport { ParticleSystem } from '../systems/ParticleSystem';\nimport { ParticleComponent } from '../components/ParticleComponent';\nimport { SpeedBoostComponent } from '../components/SpeedBoostComponent';\nimport { SpeedBoostSystem } from '../systems/SpeedBoostSystem';\nimport { VignetteSystem } from '../systems/VignetteSystem';\n\n// Z-index base values for different entity types\nconst Z_INDEX = {\n  TILE: 0,\n  TREE: 100,\n  CHARACTER: 200\n};\n\n@injectable()\nexport class Game {\n  private app!: Application;\n  private world: World;\n  private lastTime: number;\n  private readonly TILE_WIDTH = 128;\n  private readonly TILE_HEIGHT = 64;\n  private character: BaseEntity | null = null;\n  private gridOccupancyService: GridOccupancyService | null = null;\n  private coinCounter: BaseEntity | null = null;\n\n  constructor(\n    @inject(World) worldFactory: () => World,\n    @inject(MovementSystem) private movementSystem: MovementSystem,\n    @inject(InputSystem) private inputSystem: InputSystem,\n    @inject(GridRenderSystem) private gridRenderSystem: GridRenderSystem,\n    @inject(TreeSystem) private treeSystem: TreeSystem,\n    @inject(ZIndexSystem) private zIndexSystem: ZIndexSystem,\n    @inject(CoinSystem) private coinSystem: CoinSystem,\n    @inject(UIRenderSystem) private uiRenderSystem: UIRenderSystem,\n    @inject(CoinCounterSystem) private coinCounterSystem: CoinCounterSystem,\n    @inject(ParticleSystem) private particleSystem: ParticleSystem,\n    @inject(SpeedBoostSystem) private speedBoostSystem: SpeedBoostSystem,\n    @inject(VignetteSystem) private vignetteSystem: VignetteSystem\n  ) {\n    this.world = worldFactory();\n    this.world.addSystem(gridRenderSystem);\n    this.world.addSystem(movementSystem);\n    this.world.addSystem(inputSystem);\n    this.world.addSystem(treeSystem);\n    this.world.addSystem(zIndexSystem);\n    this.world.addSystem(coinSystem);\n    this.world.addSystem(uiRenderSystem);\n    this.world.addSystem(coinCounterSystem);\n    this.world.addSystem(particleSystem);\n    this.world.addSystem(speedBoostSystem);\n    this.world.addSystem(vignetteSystem);\n    this.lastTime = performance.now();\n    this.gameLoop = this.gameLoop.bind(this);\n\n    // Listen for game over event\n    this.world.on('gameOver', () => {\n      setTimeout(() => {\n        this.restart();\n      }, 1000);\n    });\n\n    // Listen for character creation events\n    this.world.on('createCharacter', () => {\n      this.createCharacter();\n    });\n  }\n\n  private async initializeSystems(): Promise<void> {\n    // Get fresh instances of all systems from the container\n    const container = this.world.container;\n    this.movementSystem = container.get<MovementSystem>(MovementSystem);\n    this.inputSystem = container.get<InputSystem>(InputSystem);\n    this.gridRenderSystem = container.get<GridRenderSystem>(GridRenderSystem);\n    this.treeSystem = container.get<TreeSystem>(TreeSystem);\n    this.zIndexSystem = container.get<ZIndexSystem>(ZIndexSystem);\n    this.coinSystem = container.get<CoinSystem>(CoinSystem);\n    this.uiRenderSystem = container.get<UIRenderSystem>(UIRenderSystem);\n    this.coinCounterSystem = container.get<CoinCounterSystem>(CoinCounterSystem);\n    this.particleSystem = container.get<ParticleSystem>(ParticleSystem);\n    this.speedBoostSystem = container.get<SpeedBoostSystem>(SpeedBoostSystem);\n    this.vignetteSystem = container.get<VignetteSystem>(VignetteSystem);\n\n    // Get a new world instance using the factory\n    const worldFactory = container.get<() => World>(World);\n    this.world = worldFactory();\n\n    // Set up app references first\n    this.movementSystem.setApp(this.app);\n    this.inputSystem.setApp(this.app);\n    this.gridRenderSystem.setApp(this.app);\n    this.treeSystem.setApp(this.app);\n    this.zIndexSystem.setApp(this.app);\n    this.coinSystem.setApp(this.app);\n    this.uiRenderSystem.setApp(this.app);\n    this.particleSystem.setApp(this.app);\n    this.speedBoostSystem.setApp(this.app);\n    this.vignetteSystem.setApp(this.app);\n\n    // Then set up the world references\n    this.treeSystem.setWorld(this.world);\n    this.coinSystem.setWorld(this.world);\n    this.coinCounterSystem.setWorld(this.world);\n    this.particleSystem.setWorld(this.world);\n    this.speedBoostSystem.setWorld(this.world);\n    this.vignetteSystem.setWorld(this.world);\n\n    // Finally add systems to the world\n    this.world.addSystem(this.gridRenderSystem);\n    this.world.addSystem(this.movementSystem);\n    this.world.addSystem(this.inputSystem);\n    this.world.addSystem(this.treeSystem);\n    this.world.addSystem(this.zIndexSystem);\n    this.world.addSystem(this.coinSystem);\n    this.world.addSystem(this.uiRenderSystem);\n    this.world.addSystem(this.coinCounterSystem);\n    this.world.addSystem(this.particleSystem);\n    this.world.addSystem(this.speedBoostSystem);\n    this.world.addSystem(this.vignetteSystem);\n\n    // Reinitialize all systems\n    this.movementSystem.reinitialize();\n    this.inputSystem.reinitialize();\n    this.gridRenderSystem.reinitialize();\n    this.treeSystem.reinitialize();\n    this.zIndexSystem.reinitialize();\n    this.coinSystem.reinitialize();\n    this.uiRenderSystem.reinitialize();\n    this.coinCounterSystem.reinitialize();\n    this.particleSystem.reinitialize();\n    this.speedBoostSystem.reinitialize();\n    this.vignetteSystem.reinitialize();\n\n    // Set up event listeners\n    this.world.on('gameOver', () => {\n      setTimeout(() => {\n        this.restart();\n      }, 1000);\n    });\n\n    // Create initial entities\n    this.createCharacter();\n    this.createCoinCounter();\n\n    // Start the game\n    this.world.setGameState(GameState.Starting);\n  }\n\n  public async start(): Promise<void> {\n    // Clean up any existing app instance\n    if (this.app) {\n      this.app.destroy(true);\n    }\n\n    // Calculate target resolution (720p)\n    const targetWidth = 1280;\n    const targetHeight = 720;\n\n    // Calculate scale to fit the window while maintaining aspect ratio\n    const scale = Math.min(\n      window.innerWidth / targetWidth,\n      window.innerHeight / targetHeight\n    );\n\n    // Calculate actual dimensions\n    const width = Math.floor(targetWidth * scale);\n    const height = Math.floor(targetHeight * scale);\n\n    this.app = new Application();\n    await this.app.init({\n      width,\n      height,\n      backgroundColor: 0xffffff, // Sky blue background\n      resolution: Math.min(window.devicePixelRatio || 1, 2), // Cap resolution at 2x\n      autoDensity: true, // Enable auto density for crisp rendering\n      resizeTo: window, // Make canvas resize to window\n    });\n\n    // Remove any existing canvas\n    const existingCanvas = document.querySelector('canvas');\n    if (existingCanvas) {\n      existingCanvas.remove();\n    }\n\n    document.body.appendChild(this.app.canvas);\n\n    // Load assets first\n    await Assets.load([\n      'character.png',\n      'tree.png',\n      'coin.png',\n      'vignette.png',\n      'vignette2.png',\n      'vignette3.png'\n    ]);\n    \n    // Reset stage position to center\n    this.app.stage.position.set(\n      this.app.screen.width / 2,\n      this.app.screen.height / 2\n    );\n\n    // Initialize systems and start the game\n    await this.initializeSystems();\n\n    // Start the game loop\n    this.app.ticker.add(this.gameLoop);\n\n    // Add window resize handler\n    window.addEventListener('resize', () => {\n      const newScale = Math.min(\n        window.innerWidth / targetWidth,\n        window.innerHeight / targetHeight\n      );\n      const newWidth = Math.floor(targetWidth * newScale);\n      const newHeight = Math.floor(targetHeight * newScale);\n      \n      this.app.renderer.resize(newWidth, newHeight);\n      this.app.stage.position.set(\n        this.app.screen.width / 2,\n        this.app.screen.height / 2\n      );\n    });\n  }\n\n  private async createCharacter(): Promise<void> {\n    // Remove old character if it exists\n    if (this.character) {\n      const visual = this.character.getComponent<VisualComponent>(VisualComponentType);\n      if (visual && visual.container.parent) {\n        visual.container.parent.removeChild(visual.container);\n      }\n      this.world.removeEntity(this.character);\n    }\n\n    // Create new character\n    this.character = new BaseEntity();\n    \n    // Calculate initial world position from grid position (0,0)\n    const initialGridPos = { x: 0, y: 0 };\n    const worldPos = this.gridToWorld(initialGridPos.x, initialGridPos.y);\n    const gridPos = new GridPositionComponent(initialGridPos.x, initialGridPos.y);\n\n    // Set transform to the world position\n    const transform = new TransformComponent(worldPos.x, worldPos.y);\n    const visual = new VisualComponent({ spritePath: 'character.png' });\n    const movement = new IsometricMovementComponent(150);\n    movement.targetDirection = Direction.DownRight; // Start moving down-right\n    const zIndex = new ZIndexComponent(Z_INDEX.CHARACTER);\n    const player = new PlayerComponent();\n    const particle = new ParticleComponent();\n    const speedBoost = new SpeedBoostComponent();\n\n    this.character.addComponent(gridPos);\n    this.character.addComponent(transform);\n    this.character.addComponent(visual);\n    this.character.addComponent(movement);\n    this.character.addComponent(zIndex);\n    this.character.addComponent(player);\n    this.character.addComponent(particle);\n    this.character.addComponent(speedBoost);\n    this.world.addEntity(this.character);\n\n    // Add the visual to the world container\n    const movementSystem = this.world.getSystem<MovementSystem>(MovementSystem);\n    if (movementSystem && movementSystem.worldContainer) {\n      movementSystem.worldContainer.addChild(visual.container);\n    }\n    \n    // Set the visual position to match the transform\n    visual.container.position.set(worldPos.x, worldPos.y);\n  }\n\n  private createCoinCounter(): void {\n    // Remove old counter if it exists\n    if (this.coinCounter) {\n      const ui = this.coinCounter.getComponent<UIComponent>(UIComponentType);\n      if (ui && ui.container.parent) {\n        ui.container.parent.removeChild(ui.container);\n      }\n      this.world.removeEntity(this.coinCounter);\n    }\n\n    // Create new counter\n    this.coinCounter = new BaseEntity();\n    \n    const counter = new CoinCounterComponent();\n    const ui = new UIComponent({\n      text: 'Coins: 0',\n      style: {\n        fontSize: 32,\n        fill: 0xFFD700, // Gold color\n        stroke: {\n          color: 0x000000,\n          width: 4\n        }\n      }\n    });\n\n    this.coinCounter.addComponent(counter);\n    this.coinCounter.addComponent(ui);\n    this.world.addEntity(this.coinCounter);\n\n    // Position at top center of screen, accounting for centered stage\n    if (this.app) {\n      // Since stage is centered at (0,0), we need to position relative to that\n      ui.setPosition(0, -this.app.screen.height / 2 + 40);\n    }\n  }\n\n  private gridToWorld(gridX: number, gridY: number): { x: number, y: number } {\n    const isoX = (gridX - gridY) * (this.TILE_WIDTH / 2);\n    const isoY = (gridX + gridY) * (this.TILE_HEIGHT / 2);\n    return { x: isoX, y: isoY };\n  }\n\n  public async restart(): Promise<void> {\n    console.log('[Game] Starting game restart');\n\n    // Cleanup current world\n    this.world.cleanup();\n\n    // Clear the stage\n    while (this.app.stage.children.length > 0) {\n      const child = this.app.stage.children[0];\n      child.destroy();\n      this.app.stage.removeChild(child);\n    }\n\n    // Reset stage position\n    this.app.stage.position.set(\n      this.app.screen.width / 2,\n      this.app.screen.height / 2\n    );\n\n    // Initialize systems and start the game\n    await this.initializeSystems();\n  }\n\n  private gameLoop(): void {\n    const currentTime = performance.now();\n    const deltaTime = (currentTime - this.lastTime) / 1000;\n    this.lastTime = currentTime;\n\n    this.world.update(deltaTime);\n  }\n\n  public get pixiApp(): Application {\n    return this.app;\n  }\n} ","import { Container } from 'inversify';\nimport { World } from '../core/World';\nimport { Game } from '../core/Game';\nimport { MovementSystem } from '../systems/MovementSystem';\nimport { InputSystem } from '../systems/InputSystem';\nimport { GridRenderSystem } from '../systems/GridRenderSystem';\nimport { TreeSystem } from '../systems/TreeSystem';\nimport { ZIndexSystem } from '../systems/ZIndexSystem';\nimport { CoinSystem } from '../systems/CoinSystem';\nimport { GridService } from '../services/GridService';\nimport { GridOccupancyService } from '../services/GridOccupancyService';\nimport { UIRenderSystem } from '../systems/UIRenderSystem';\nimport { CoinCounterSystem } from '../systems/CoinCounterSystem';\nimport { ParticleSystem } from '../systems/ParticleSystem';\nimport { SpeedBoostSystem } from '../systems/SpeedBoostSystem';\nimport { VignetteSystem } from '../systems/VignetteSystem';\n\nexport function createContainer(): Container {\n  const container = new Container();\n\n  // Create a factory function for World that takes the container\n  const worldFactory = (c: Container) => {\n    return new World(c);\n  };\n\n  // Bind World as a factory to ensure fresh instances\n  container.bind<World>(World).toFactory<World>((context) => {\n    return () => worldFactory(container);\n  });\n\n  // Bind Game as a singleton\n  container.bind<Game>(Game).toSelf().inSingletonScope();\n\n  // Bind all systems as singletons\n  container.bind<MovementSystem>(MovementSystem).toSelf().inSingletonScope();\n  container.bind<InputSystem>(InputSystem).toSelf().inSingletonScope();\n  container.bind<GridRenderSystem>(GridRenderSystem).toSelf().inSingletonScope();\n  container.bind<TreeSystem>(TreeSystem).toSelf().inSingletonScope();\n  container.bind<ZIndexSystem>(ZIndexSystem).toSelf().inSingletonScope();\n  container.bind<CoinSystem>(CoinSystem).toSelf().inSingletonScope();\n  container.bind<UIRenderSystem>(UIRenderSystem).toSelf().inSingletonScope();\n  container.bind<CoinCounterSystem>(CoinCounterSystem).toSelf().inSingletonScope();\n  container.bind<ParticleSystem>(ParticleSystem).toSelf().inSingletonScope();\n  container.bind<SpeedBoostSystem>(SpeedBoostSystem).toSelf().inSingletonScope();\n  container.bind<VignetteSystem>(VignetteSystem).toSelf().inSingletonScope();\n\n  // Bind services as singletons\n  container.bind<GridService>(GridService).toSelf().inSingletonScope();\n  container.bind<GridOccupancyService>(GridOccupancyService).toSelf().inSingletonScope();\n\n  return container;\n} ","import 'reflect-metadata';\nimport { createContainer } from './di/container';\nimport { Game } from './core/Game';\n\n// Create container and get the game instance\nconst container = createContainer();\nconst game = container.get<Game>(Game);\n\n// Start the game\ngame.start(); "],"names":["EventEmitter","constructor","__publicField","this","Map","on","event","callback","events","has","set","get","push","emit","args","callbacks","forEach","off","index","indexOf","splice","length","delete","GameState","World","container","Set","_container","addSystem","system","systems","setWorld","addEntity","entity","entities","add","removeEntity","clearEntities","clear","getEntities","Array","from","getSystem","systemType","find","clearSystems","cleanup","reset","currentState","getCurrentState","setGameState","newState","oldState","setTimeout","update","deltaTime","__decorateClass","injectable","BaseSystem","setApp","app","world","onGameStateChanged","initialize","reinitialize","relevantEntities","filter","requiredComponents","every","hasComponent","componentType","updateRelevantEntities","TransformComponentType","Symbol","TransformComponent","x","y","rotation","VisualComponentType","VisualComponent","options","Container","spritePath","texture","Assets","sprite","Sprite","anchor","scale","Math","max","width","height","abs","addChild","error","console","warn","graphics","Graphics","circle","fill","color","radius","flipX","IsometricMovementComponentType","Direction","IsometricMovementComponent","speed","baseSpeed","GridPositionComponentType","GridPositionComponent","gridX","gridY","targetGridX","targetGridY","isMoving","setTargetPosition","reachedTarget","GridService","gridToWorld","TILE_WIDTH","TILE_HEIGHT","worldToGrid","worldX","worldY","round","getTileDimensions","getNextGridPosition","currentX","currentY","direction","DownRight","DownLeft","TopRight","TopLeft","isValidGridPosition","ParticleComponentType","ParticleComponent","MovementSystem","gridService","super","initializeWorldContainer","worldContainer","stage","position","removeChild","destroy","transform","getComponent","movement","gridPos","visual","particleComponent","targetDirection","None","nextPosition","currentDirection","getDirectionVector","lastDirection","isActive","targetWorldPos","dx","dy","distance","sqrt","moveDistance","ratio","min","screenCenterX","screenCenterY","InputSystem","arguments","queuedDirectionChange","isMovingDownRight","needsFlip","canvas","addEventListener","handleTap","GridRenderSystem","gridContainer","GameOver","Starting","_a","initializeTilePool","movementSystem","addChildAt","tilePool","tile","updateVisibleTiles","isInitialized","key","activeTiles","recycleTile","lastCenterX","lastCenterY","i","POOL_SIZE","createTileGraphics","visible","isInUse","setFillStyle","alpha","moveTo","lineTo","setStrokeStyle","stroke","getTileKey","getFreeTile","placeTile","centerX","centerY","Playing","tileWorldPos","worldContainerPos","centerWorldX","centerWorldY","worldPos","gridCenterX","floor","gridCenterY","minX","VISIBLE_RADIUS","maxX","minY","maxY","neededTiles","__decorateParam","_BaseEntity","id","nextId","components","addComponent","component","type","removeComponent","BaseEntity","TreeComponentType","TreeComponent","ZIndexComponentType","ZIndexComponent","baseZ","calculateZ","VIGNETTE","COIN_COUNTER","PlayerComponentType","PlayerComponent","OccupancyType","GridOccupancyService","getKey","isOccupied","cell","occupiedCells","size","occupy","free","getOccupancyTypes","Z_INDEX","TreeSystem","gridOccupancyService","data","trySpawnTreeAt","pendingTileEvents","initializeTreePool","tree","activeTreePositions","entries","parent","Tree","treePool","load","treeComponent","zIndex","processPendingTileEvents","removeTree","spawnTree","unusedTreeIndex","findIndex","unusedTree","random","TREE_DENSITY","_b","values","updateTreePosition","players","_c","player","playerGridPos","_d","ZIndexSystem","sort","a","b","getEntityZIndex","CoinComponentType","CoinComponent","CoinCounterComponentType","CoinCounterComponent","savedHighscore","localStorage","getItem","highscore","parseInt","increment","count","setItem","toString","getCount","getHighscore","SpeedBoostComponentType","SpeedBoostComponent","Infinity","addBoost","speedMultiplier","BOOST_PER_COIN","MAX_MULTIPLIER","getSpeedMultiplier","CoinSystem","trySpawnCoinAt","initializeCoinPool","coin","coinComponent","coinPool","removeCoin","activeCoinPositions","Coin","spawnCoin","unusedCoinIndex","unusedCoin","COIN_DENSITY","updateCoinPosition","handleCoinCollection","coinEntity","counterEntity","counter","speedBoost","poolItem","item","UIComponentType","UIComponent","config","style","fontFamily","fontSize","align","text","Text","setText","setPosition","UIRenderSystem","uiContainer","ui","children","includes","CoinCounterSystem","newText","UI","ParticleSystem","initializeParticleContainer","particleContainer","timeSinceLastSpawn","PARTICLE_SPAWN_RATE","spawnParticles","updateParticles","particles","particle","lifetime","progress","PARTICLE_LIFETIME","PARTICLE_ALPHA","velocityX","velocityY","angle","atan2","spread","PI","particleAngle","PARTICLE_COLOR","PARTICLE_SIZE","cos","PARTICLE_INITIAL_SPEED","sin","SpeedBoostSystem","VignetteSystem","initializeVignette","updateVignetteScale","log","vignetteSprite","tileWidth","tileHeight","visibleWidth","visibleHeight","Game","worldFactory","inputSystem","gridRenderSystem","treeSystem","zIndexSystem","coinSystem","uiRenderSystem","coinCounterSystem","particleSystem","speedBoostSystem","vignetteSystem","lastTime","performance","now","gameLoop","bind","restart","createCharacter","initializeSystems","createCoinCounter","start","targetWidth","targetHeight","window","innerWidth","innerHeight","Application","init","backgroundColor","resolution","devicePixelRatio","autoDensity","resizeTo","existingCanvas","document","querySelector","remove","body","appendChild","screen","ticker","newScale","newWidth","newHeight","renderer","resize","character","initialGridPos","coinCounter","child","currentTime","pixiApp","toFactory","context","toSelf","inSingletonScope","createContainer"],"mappings":"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"}