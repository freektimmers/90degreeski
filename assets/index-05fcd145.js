var t=Object.defineProperty,e=(e,i,s)=>(((e,i,s)=>{i in e?t(e,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[i]=s})(e,"symbol"!=typeof i?i+"":i,s),s);import{K as i,C as s,b as n,S as o,G as r,Y as a,T as h,c,P as l}from"./vendor-e923da98.js";!function(){const t=document.createElement("link").relList;if(!(t&&t.supports&&t.supports("modulepreload"))){for(const t of document.querySelectorAll('link[rel="modulepreload"]'))e(t);new MutationObserver((t=>{for(const i of t)if("childList"===i.type)for(const t of i.addedNodes)"LINK"===t.tagName&&"modulepreload"===t.rel&&e(t)})).observe(document,{childList:!0,subtree:!0})}function e(t){if(t.ep)return;t.ep=!0;const e=function(t){const e={};return t.integrity&&(e.integrity=t.integrity),t.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),"use-credentials"===t.crossOrigin?e.credentials="include":"anonymous"===t.crossOrigin?e.credentials="omit":e.credentials="same-origin",e}(t);fetch(t.href,e)}}();class d{constructor(){e(this,"events",new Map)}on(t,e){this.events.has(t)||this.events.set(t,[]),this.events.get(t).push(e)}emit(t,...e){const i=this.events.get(t);i&&i.forEach((t=>t(...e)))}off(t,e){const i=this.events.get(t);if(i){const s=i.indexOf(e);-1!==s&&i.splice(s,1),0===i.length&&this.events.delete(t)}}}var p=Object.defineProperty,g=Object.getOwnPropertyDescriptor,u=(t=>(t.Playing="Playing",t.GameOver="GameOver",t.Starting="Starting",t))(u||{});let y=class extends d{constructor(t){super(),e(this,"systems",[]),e(this,"entities",new Set),e(this,"currentState","Starting"),e(this,"_container"),this._container=t}addSystem(t){this.systems.push(t),t.setWorld(this)}addEntity(t){this.entities.add(t)}removeEntity(t){this.entities.delete(t)}clearEntities(){this.entities.clear()}getEntities(){return Array.from(this.entities)}getSystem(t){return this.systems.find((e=>e instanceof t))}clearSystems(){this.systems=[]}cleanup(){this.clearEntities();for(const t of this.systems)t.reset();this.clearSystems(),this.currentState="Starting"}getCurrentState(){return this.currentState}setGameState(t){const e=this.currentState;this.currentState=t,this.emit("gameStateChanged",{oldState:e,newState:t}),"GameOver"===t?this.emit("gameOver"):"Starting"===t&&setTimeout((()=>{this.setGameState("Playing")}),100)}update(t){if("Playing"!==this.currentState)return;const e=Array.from(this.entities);for(const i of this.systems)i.update(e,t)}get container(){return this._container}};y=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?g(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&p(e,i,o),o})([i()],y);class m{constructor(){e(this,"app",null),e(this,"world",null)}setApp(t){this.app=t}setWorld(t){this.world=t,t.on("gameStateChanged",(({oldState:t,newState:e})=>{this.onGameStateChanged(t,e)}))}onGameStateChanged(t,e){}reset(){}initialize(){}cleanup(){}reinitialize(){this.cleanup(),this.reset(),this.initialize()}update(t,e){const i=t.filter((t=>this.requiredComponents.every((e=>t.hasComponent(e)))));this.updateRelevantEntities(i,e)}}const C=Symbol("TransformComponent");class S{constructor(t=0,i=0,s=0){e(this,"type",C),e(this,"entity",null),this.x=t,this.y=i,this.rotation=s}}const v=Symbol("VisualComponent");class w{constructor(t={}){e(this,"type",v),e(this,"entity",null),e(this,"container"),e(this,"sprite",null),e(this,"graphics",null),this.container=new s;if(t.spritePath){const e=n.get(t.spritePath);this.sprite=new o(e),this.sprite.anchor.set(.5);const i=128/Math.max(this.sprite.width,this.sprite.height);this.sprite.scale.set(i),this.sprite.scale.x=-Math.abs(this.sprite.scale.x),this.sprite.y+=-32,this.container.addChild(this.sprite)}else this.graphics=(new r).circle(0,0,t.radius||5).fill({color:t.color||16711680}),this.container.addChild(this.graphics)}flipX(){this.sprite&&(this.sprite.scale.x=-this.sprite.scale.x)}}const f=Symbol("IsometricMovementComponent");var T=(t=>(t.None="none",t.TopRight="topRight",t.TopLeft="topLeft",t.DownRight="downRight",t.DownLeft="downLeft",t))(T||{});class I{constructor(t=this.baseSpeed){e(this,"type",f),e(this,"entity",null),e(this,"currentDirection","none"),e(this,"targetDirection","none"),e(this,"isMoving",!1),e(this,"baseSpeed",200),this.speed=t}}const P=Symbol("GridPositionComponent");class E{constructor(t=0,i=0,s=0,n=0,o=!1){e(this,"type",P),e(this,"entity",null),this.gridX=t,this.gridY=i,this.targetGridX=s,this.targetGridY=n,this.isMoving=o,this.targetGridX=t,this.targetGridY=i}setTargetPosition(t,e){this.targetGridX=t,this.targetGridY=e,this.isMoving=!0}reachedTarget(){return this.gridX===this.targetGridX&&this.gridY===this.targetGridY}}var O=Object.defineProperty,x=Object.getOwnPropertyDescriptor;let b=class{constructor(){e(this,"TILE_WIDTH",128),e(this,"TILE_HEIGHT",64)}gridToWorld(t,e){return{x:(t-e)*(this.TILE_WIDTH/2),y:(t+e)*(this.TILE_HEIGHT/2)}}worldToGrid(t,e){const i=t/this.TILE_WIDTH+e/this.TILE_HEIGHT,s=e/this.TILE_HEIGHT-t/this.TILE_WIDTH;return{x:Math.round(i),y:Math.round(s)}}getTileDimensions(){return{width:this.TILE_WIDTH,height:this.TILE_HEIGHT}}getNextGridPosition(t,e,i){switch(i){case T.DownRight:return{x:t+1,y:e};case T.DownLeft:return{x:t,y:e+1};case T.TopRight:return{x:t,y:e-1};case T.TopLeft:return{x:t-1,y:e};default:return{x:t,y:e}}}isValidGridPosition(t,e){return!0}};b=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?x(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&O(e,i,o),o})([i()],b);const L=Symbol("ParticleComponent");class A{constructor(){e(this,"type",L),e(this,"particles",[]),e(this,"isActive",!1),e(this,"lastDirection",{x:0,y:0}),e(this,"entity",null)}}var M=Object.defineProperty,D=Object.getOwnPropertyDescriptor;let R=class extends m{constructor(t){super(),e(this,"worldContainer",null),e(this,"requiredComponents",[C,v,f,P]),this.gridService=t}setApp(t){super.setApp(t),t&&this.initializeWorldContainer()}initializeWorldContainer(){this.app&&(this.worldContainer=new s,this.app.stage.addChild(this.worldContainer),this.worldContainer.position.set(0,0))}cleanup(){this.worldContainer&&this.app&&(this.app.stage.removeChild(this.worldContainer),this.worldContainer.destroy(),this.worldContainer=null)}reinitialize(){this.cleanup(),this.initializeWorldContainer()}updateRelevantEntities(t,e){if(this.worldContainer&&this.app)for(const i of t){const t=i.getComponent(C),s=i.getComponent(f),n=i.getComponent(P),o=i.getComponent(v),r=i.getComponent(L);if(t&&s&&n&&o){if(!n.isMoving&&s.targetDirection!==T.None){const t=this.gridService.getNextGridPosition(n.gridX,n.gridY,s.targetDirection);if(n.setTargetPosition(t.x,t.y),s.currentDirection=s.targetDirection,s.isMoving=!0,n.isMoving=!0,r){const t=this.getDirectionVector(s.targetDirection);r.lastDirection=t,r.isActive=!0}}if(n.isMoving){const i=this.gridService.gridToWorld(n.targetGridX,n.targetGridY),a=i.x-t.x,h=i.y-t.y,c=Math.sqrt(a*a+h*h);if(c<1)t.x=i.x,t.y=i.y,n.gridX=n.targetGridX,n.gridY=n.targetGridY,n.isMoving=!1,s.isMoving=!1,s.currentDirection=T.None,r&&(r.isActive=!1);else{const i=s.speed*e,n=Math.min(i/c,1);t.x+=a*n,t.y+=h*n}if(o.container.position.set(t.x,t.y),this.worldContainer&&this.app){const e=0,i=0;this.worldContainer.position.x=e-t.x,this.worldContainer.position.y=i-t.y}}else if(this.worldContainer&&this.app){const e=0,i=0;this.worldContainer.position.x=e-t.x,this.worldContainer.position.y=i-t.y}}}}getDirectionVector(t){switch(t){case T.TopRight:return{x:1,y:-1};case T.TopLeft:return{x:-1,y:-1};case T.DownRight:return{x:1,y:1};case T.DownLeft:return{x:-1,y:1};default:return{x:0,y:0}}}};var z,_;R=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?D(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&M(e,i,o),o})([i(),(z=0,_=a(b),(t,e)=>_(t,e,z))],R);var G=Object.defineProperty,Y=Object.getOwnPropertyDescriptor;let X=class extends m{constructor(){super(...arguments),e(this,"queuedDirectionChange",!1),e(this,"isMovingDownRight",!0),e(this,"needsFlip",!1),e(this,"requiredComponents",[f,v,P])}reset(){this.queuedDirectionChange=!1,this.isMovingDownRight=!0,this.needsFlip=!1}setApp(t){super.setApp(t),t.canvas&&(t.canvas.addEventListener("click",(()=>this.handleTap())),t.canvas.addEventListener("touchstart",(()=>this.handleTap())))}handleTap(){this.queuedDirectionChange||(this.queuedDirectionChange=!0,this.needsFlip=!0)}updateRelevantEntities(t,e){if(this.queuedDirectionChange||this.needsFlip)for(const i of t){const t=i.getComponent(f),e=i.getComponent(P),s=i.getComponent(v);t&&e&&s&&(this.needsFlip&&(s.flipX(),this.needsFlip=!1),this.queuedDirectionChange&&!e.isMoving&&(this.isMovingDownRight=!this.isMovingDownRight,t.targetDirection=this.isMovingDownRight?T.DownRight:T.DownLeft,this.queuedDirectionChange=!1))}}};X=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?Y(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&G(e,i,o),o})([i()],X);var W=Object.defineProperty,H=Object.getOwnPropertyDescriptor;let U=class extends m{constructor(t){super(),e(this,"gridContainer"),e(this,"tilePool",[]),e(this,"activeTiles",new Map),e(this,"VISIBLE_RADIUS",12),e(this,"POOL_SIZE",600),e(this,"lastCenterX",0),e(this,"lastCenterY",0),e(this,"isInitialized",!1),e(this,"requiredComponents",[C]),this.gridService=t,this.gridContainer=new s}onGameStateChanged(t,e){e===u.GameOver||e===u.Starting&&this.initialize()}initialize(){var t;if(!this.world||!(null==(t=this.app)?void 0:t.stage))return;this.initializeTilePool(),this.gridContainer.position.set(0,0);const e=this.world.getSystem(R);e&&e.worldContainer&&e.worldContainer.addChildAt(this.gridContainer,0),this.tilePool.forEach((t=>this.gridContainer.addChild(t.graphics))),this.updateVisibleTiles(0,0),this.isInitialized=!0}reset(){for(const[t,e]of this.activeTiles)this.recycleTile(e);this.activeTiles.clear(),this.lastCenterX=0,this.lastCenterY=0}initializeTilePool(){for(let t=0;t<this.POOL_SIZE;t++){const t=new r;this.createTileGraphics(t),t.visible=!1,this.tilePool.push({graphics:t,isInUse:!1,gridX:0,gridY:0})}}createTileGraphics(t){const{width:e,height:i}=this.gridService.getTileDimensions();t.clear(),t.setFillStyle({color:16777215,alpha:1}).moveTo(0,-i/2).lineTo(e/2,0).lineTo(0,i/2).lineTo(-e/2,0).lineTo(0,-i/2).fill(),t.setStrokeStyle({width:1,color:13421772,alpha:1}).moveTo(0,-i/2).lineTo(e/2,0).lineTo(0,i/2).lineTo(-e/2,0).lineTo(0,-i/2).stroke()}getTileKey(t,e){return`${t},${e}`}getFreeTile(){return this.tilePool.find((t=>!t.isInUse))||null}placeTile(t,e,i,s){if(!this.world||this.world.getCurrentState()!==u.Playing)return;const n=this.getTileKey(t,e);if(this.activeTiles.has(n))return;const o=this.getFreeTile();if(!o)return;this.gridService.worldToGrid(i,s),this.createTileGraphics(o.graphics);const r=this.gridService.gridToWorld(t,e);o.graphics.position.set(r.x,r.y),o.graphics.visible=!0,o.isInUse=!0,o.gridX=t,o.gridY=e,this.activeTiles.set(n,o),this.world&&this.world.emit("tileCreated",{gridX:t,gridY:e})}recycleTile(t){const e=this.getTileKey(t.gridX,t.gridY);t.graphics.visible=!1,t.isInUse=!1,this.activeTiles.delete(e)}updateVisibleTiles(t,e){if(!this.app||!this.world||this.world.getCurrentState()!==u.Playing)return;const i=this.world.getSystem(R);if(!(null==i?void 0:i.worldContainer))return;const s=i.worldContainer.position;if(!s)return;const n=-s.x,o=-s.y,r=this.gridService.worldToGrid(n,o),a=Math.floor(r.x),h=Math.floor(r.y),c=a-this.VISIBLE_RADIUS,l=a+this.VISIBLE_RADIUS,d=h-this.VISIBLE_RADIUS,p=h+this.VISIBLE_RADIUS,g=new Set;for(let u=c;u<=l;u++)for(let t=d;t<=p;t++){if(Math.abs(u-a)+Math.abs(t-h)<=1.5*this.VISIBLE_RADIUS){const e=this.getTileKey(u,t);g.add(e),this.activeTiles.has(e)||this.placeTile(u,t,n,o)}}for(const[u,y]of this.activeTiles)g.has(u)||this.recycleTile(y)}updateRelevantEntities(t,e){var i;if(!(null==(i=this.app)?void 0:i.stage)||!this.isInitialized)return;if(!this.world||this.world.getCurrentState()!==u.Playing)return;const s=this.world.getSystem(R);if(!(null==s?void 0:s.worldContainer))return;const n=s.worldContainer.position;n&&this.updateVisibleTiles(n.x,n.y)}};U=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?H(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&W(e,i,o),o})([i(),((t,e)=>(i,s)=>e(i,s,t))(0,a(b))],U);const j=class t{constructor(){e(this,"id"),e(this,"components"),this.id=t.nextId++,this.components=new Map}addComponent(t){this.components.set(t.type,t),t.entity=this}removeComponent(t){const e=this.components.get(t);e&&(e.entity=null,this.components.delete(t))}getComponent(t){return this.components.get(t)}hasComponent(t){return this.components.has(t)}};e(j,"nextId",0);let N=j;const V=Symbol("TreeComponent");class q{constructor(){e(this,"type",V),e(this,"entity",null)}}const $=Symbol("ZIndexComponent");class B{constructor(t=0){e(this,"type",$),e(this,"entity",null),e(this,"baseZ"),this.baseZ=t}calculateZ(t){return this.baseZ+1e3*t.gridY+t.gridX}}e(B,"UI",{VIGNETTE:1e3,COIN_COUNTER:2e3});const Z=Symbol("PlayerComponent");class F{constructor(){e(this,"type",Z),e(this,"entity",null)}}var K=Object.defineProperty,k=Object.getOwnPropertyDescriptor,J=(t=>(t.Tree="tree",t.Coin="coin",t.Character="character",t))(J||{});let Q=class{constructor(){e(this,"occupiedCells",new Map)}getKey(t,e){return`${t},${e}`}isOccupied(t,e,i){const s=this.getKey(t,e),n=this.occupiedCells.get(s);return!!n&&(i?n.has(i):n.size>0)}occupy(t,e,i){const s=this.getKey(t,e);this.occupiedCells.has(s)||this.occupiedCells.set(s,new Set);const n=this.occupiedCells.get(s);n.has(i)||n.add(i)}free(t,e,i){const s=this.getKey(t,e),n=this.occupiedCells.get(s);if(n){if(!n.has(i))return;n.delete(i),0===n.size&&this.occupiedCells.delete(s)}else console.warn(`[GridOccupancyService] Attempting to free non-existent cell at ${t},${e} with type ${i}`)}reset(){this.occupiedCells.clear()}getOccupancyTypes(t,e){const i=this.getKey(t,e);return this.occupiedCells.get(i)}};Q=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?k(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&K(e,i,o),o})([i()],Q);var tt=Object.defineProperty,et=Object.getOwnPropertyDescriptor,it=(t,e)=>(i,s)=>e(i,s,t);const st=100;let nt=class extends m{constructor(t,i){super(),e(this,"TREE_DENSITY",.05),e(this,"VISIBLE_RADIUS",12),e(this,"POOL_SIZE",100),e(this,"treePool",[]),e(this,"activeTreePositions",new Map),e(this,"pendingTileEvents",[]),e(this,"isInitialized",!1),e(this,"requiredComponents",[P,V]),this.gridService=t,this.gridOccupancyService=i}setWorld(t){if(this.world=t,this.world.on("tileCreated",(t=>{this.isInitialized?this.trySpawnTreeAt(t.gridX,t.gridY):this.pendingTileEvents.push(t)})),this.app){const t=this.world.getSystem(R);(null==t?void 0:t.worldContainer)&&this.initializeTreePool()}}setApp(t){this.app=t}onGameStateChanged(t,e){e===u.GameOver?this.reset():e===u.Starting&&this.initialize()}initialize(){var t;this.world&&(null==(t=this.app)||t.stage)}reset(){for(const[t,e]of this.activeTreePositions.entries()){const t=e.entity.getComponent(v);t&&t.container.parent&&t.container.parent.removeChild(t.container),this.world&&this.world.removeEntity(e.entity),this.gridOccupancyService.free(e.gridX,e.gridY,J.Tree)}this.activeTreePositions.clear();for(const t of this.treePool)this.world&&this.world.removeEntity(t.entity);if(this.treePool=[],this.isInitialized=!1,this.app&&this.world){const t=this.world.getSystem(R);(null==t?void 0:t.worldContainer)&&this.initializeTreePool()}}initializeTreePool(){var t;if(!this.world||!(null==(t=this.app)?void 0:t.stage))return;const e=this.world.getSystem(R);if(null==e?void 0:e.worldContainer){for(let t=0;t<this.POOL_SIZE;t++){const t=new N,i=new S(0,0),s=new E(0,0),n=new w({spritePath:"/tree.png"}),o=new q,r=new B(st);t.addComponent(i),t.addComponent(s),t.addComponent(n),t.addComponent(o),t.addComponent(r),this.world.addEntity(t),e.worldContainer.addChild(n.container),n.container.visible=!1,this.treePool.push({entity:t,isInUse:!1,gridX:0,gridY:0})}this.isInitialized=!0,this.processPendingTileEvents()}else console.warn("[TreeSystem] Movement system not ready, delaying pool initialization")}processPendingTileEvents(){if(this.isInitialized){for(const t of this.pendingTileEvents)this.trySpawnTreeAt(t.gridX,t.gridY);this.pendingTileEvents=[]}}removeTree(t,e){const i=`${t},${e}`,s=this.activeTreePositions.get(i);if(s){const n=s.entity.getComponent(v);n&&(n.container.visible=!1),s.isInUse=!1,s.gridX=0,s.gridY=0,this.gridOccupancyService.free(t,e,J.Tree),this.activeTreePositions.delete(i)}}spawnTree(t,e){var i;const s=`${t},${e}`;if(this.activeTreePositions.has(s))return;if(this.gridOccupancyService.isOccupied(t,e))return;const n=this.treePool.findIndex((t=>!t.isInUse));if(-1===n)return void console.warn("[TreeSystem] Tree pool exhausted. Active trees:",this.activeTreePositions.size);const o=this.treePool[n],r=this.gridService.gridToWorld(t,e),a=o.entity.getComponent(C),h=o.entity.getComponent(P),c=o.entity.getComponent(v);if(!a||!h||!c)return void console.warn("[TreeSystem] Missing required components for tree");const l=null==(i=this.world)?void 0:i.getSystem(R);(null==l?void 0:l.worldContainer)?(a.x=r.x,a.y=r.y,h.gridX=t,h.gridY=e,c.container.visible=!0,c.container.position.set(a.x,a.y),c.container.parent||l.worldContainer.addChild(c.container),o.isInUse=!0,o.gridX=t,o.gridY=e,this.activeTreePositions.set(s,o),this.gridOccupancyService.occupy(t,e,J.Tree)):console.warn("[TreeSystem] Movement system or world container not ready")}trySpawnTreeAt(t,e){if(!this.world)return;if(this.world.getCurrentState()!==u.Playing)return;if(Math.abs(t)+Math.abs(e)<20)return;if(this.gridOccupancyService.isOccupied(t,e))return;Math.random()<this.TREE_DENSITY&&this.spawnTree(t,e)}updateRelevantEntities(t,e){var i,s,n,o;if(!(null==(i=this.app)?void 0:i.stage)||(null==(s=this.world)?void 0:s.getCurrentState())!==u.Playing)return;const r=this.world.getSystem(R);if(!(null==r?void 0:r.worldContainer))return;for(const u of this.activeTreePositions.values())this.updateTreePosition(u.entity);const a=null==(n=this.world)?void 0:n.getEntities().filter((t=>t.hasComponent(Z)&&t.hasComponent(P)));if(a)for(const y of a){const t=y.getComponent(P);if(t&&this.gridOccupancyService.isOccupied(t.gridX,t.gridY,J.Tree)){const e=`${t.gridX},${t.gridY}`;if(this.activeTreePositions.has(e))return void(null==(o=this.world)||o.setGameState(u.GameOver));this.gridOccupancyService.free(t.gridX,t.gridY,J.Tree)}}const h=r.worldContainer.position;if(!h)return;const c=-h.x,l=-h.y,d=this.gridService.worldToGrid(c,l),p=Math.floor(d.x),g=Math.floor(d.y);for(const[u,y]of this.activeTreePositions.entries()){const t=y.entity.getComponent(P);if(t){Math.abs(t.gridX-p)+Math.abs(t.gridY-g)>1.5*this.VISIBLE_RADIUS&&this.removeTree(t.gridX,t.gridY)}}}updateTreePosition(t){const e=t.getComponent(C),i=t.getComponent(v);e&&i&&i.container.position.set(e.x,e.y)}};nt=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?et(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&tt(e,i,o),o})([i(),it(0,a(b)),it(1,a(Q))],nt);var ot=Object.defineProperty,rt=Object.getOwnPropertyDescriptor;let at=class extends m{constructor(){super(...arguments),e(this,"requiredComponents",[$,P,v])}updateRelevantEntities(t,e){var i;if(!(null==(i=this.app)?void 0:i.stage))return;[...t].sort(((t,e)=>this.getEntityZIndex(t)-this.getEntityZIndex(e))).forEach((t=>{const e=t.getComponent(v);if(null==e?void 0:e.container){const t=e.container.parent;t&&(t.removeChild(e.container),t.addChild(e.container))}}))}getEntityZIndex(t){const e=t.getComponent($),i=t.getComponent(P);return e&&i?e.calculateZ(i):0}};at=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?rt(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&ot(e,i,o),o})([i()],at);const ht=Symbol("CoinComponent");class ct{constructor(){e(this,"type",ht),e(this,"entity",null)}}const lt=Symbol("CoinCounterComponent");class dt{constructor(){e(this,"type",lt),e(this,"entity",null),e(this,"count",0),e(this,"highscore",0);const t=localStorage.getItem("coinHighscore");t&&(this.highscore=parseInt(t,10))}increment(){this.count++,this.count>this.highscore&&(this.highscore=this.count,localStorage.setItem("coinHighscore",this.highscore.toString()))}getCount(){return this.count}getHighscore(){return this.highscore}reset(){this.count=0}}const pt=Symbol("SpeedBoostComponent");class gt{constructor(){e(this,"type",pt),e(this,"entity",null),e(this,"speedMultiplier",1),e(this,"BOOST_PER_COIN",.1),e(this,"MAX_MULTIPLIER",1/0)}addBoost(){this.speedMultiplier=Math.min(this.speedMultiplier+this.BOOST_PER_COIN,this.MAX_MULTIPLIER)}getSpeedMultiplier(){return this.speedMultiplier}reset(){this.speedMultiplier=1}}var ut=Object.defineProperty,yt=Object.getOwnPropertyDescriptor,mt=(t,e)=>(i,s)=>e(i,s,t);const Ct=50;let St=class extends m{constructor(t,i){super(),e(this,"COIN_DENSITY",.01),e(this,"VISIBLE_RADIUS",12),e(this,"POOL_SIZE",50),e(this,"coinPool",[]),e(this,"activeCoinPositions",new Map),e(this,"requiredComponents",[P,ht]),this.gridService=t,this.gridOccupancyService=i}setWorld(t){this.world=t,this.world.on("tileCreated",(t=>{this.trySpawnCoinAt(t.gridX,t.gridY)})),this.app&&this.initializeCoinPool()}setApp(t){this.app=t}initializeCoinPool(){var t;if(this.world&&(null==(t=this.app)?void 0:t.stage))for(let e=0;e<this.POOL_SIZE;e++){const t=new N,e=new S(0,0),i=new E(0,0),s=new w({spritePath:"/coin.png"}),n=new ct,o=new B(Ct);t.addComponent(e),t.addComponent(i),t.addComponent(s),t.addComponent(n),t.addComponent(o),this.world.addEntity(t);const r=this.world.getSystem(R);r&&r.worldContainer&&r.worldContainer.addChild(s.container),s.container.visible=!1,this.coinPool.push({entity:t,isInUse:!1,gridX:0,gridY:0})}}removeCoin(t,e){const i=`${t},${e}`,s=this.activeCoinPositions.get(i);if(s){const n=s.entity.getComponent(v);n&&(n.container.visible=!1),s.isInUse=!1,s.gridX=0,s.gridY=0,this.gridOccupancyService.free(t,e,J.Coin),this.activeCoinPositions.delete(i)}}spawnCoin(t,e){var i;const s=`${t},${e}`;if(this.activeCoinPositions.has(s))return;if(this.gridOccupancyService.isOccupied(t,e))return;const n=this.coinPool.findIndex((t=>!t.isInUse));if(-1===n)return void console.warn("[CoinSystem] Coin pool exhausted. Active coins:",this.activeCoinPositions.size);const o=this.coinPool[n],r=this.gridService.gridToWorld(t,e),a=o.entity.getComponent(C),h=o.entity.getComponent(P),c=o.entity.getComponent(v);if(!a||!h||!c)return void console.warn("[CoinSystem] Missing required components for coin");const l=null==(i=this.world)?void 0:i.getSystem(R);(null==l?void 0:l.worldContainer)?(a.x=r.x,a.y=r.y,h.gridX=t,h.gridY=e,c.container.visible=!0,c.container.position.set(a.x,a.y),c.container.parent||l.worldContainer.addChild(c.container),o.isInUse=!0,o.gridX=t,o.gridY=e,this.activeCoinPositions.set(s,o),this.gridOccupancyService.occupy(t,e,J.Coin)):console.warn("[CoinSystem] Movement system or world container not ready")}trySpawnCoinAt(t,e){if(!this.world)return;if(this.world.getCurrentState()!==u.Playing)return;if(Math.abs(t)+Math.abs(e)<20)return;if(this.gridOccupancyService.isOccupied(t,e))return;Math.random()<this.COIN_DENSITY&&this.spawnCoin(t,e)}onGameStateChanged(t,e){e===u.GameOver?this.reset():e===u.Starting&&this.initialize()}initialize(){var t;this.world&&(null==(t=this.app)||t.stage)}reset(){for(const[t,e]of this.activeCoinPositions.entries()){const t=e.entity.getComponent(v);t&&t.container.parent&&t.container.parent.removeChild(t.container),this.world&&this.world.removeEntity(e.entity),this.gridOccupancyService.free(e.gridX,e.gridY,J.Coin)}this.activeCoinPositions.clear();for(const t of this.coinPool)this.world&&this.world.removeEntity(t.entity);this.coinPool=[],this.app&&this.world&&this.initializeCoinPool()}updateRelevantEntities(t,e){var i;if(!(null==(i=this.app)?void 0:i.stage)||!this.world||this.world.getCurrentState()!==u.Playing)return;const s=this.world.getSystem(R);if(!(null==s?void 0:s.worldContainer))return;for(const d of this.activeCoinPositions.values())this.updateCoinPosition(d.entity);const n=this.world.getEntities().filter((t=>t.hasComponent(Z)&&t.hasComponent(P)));for(const d of n){const t=d.getComponent(P);if(t&&this.gridOccupancyService.isOccupied(t.gridX,t.gridY,J.Coin)){const e=`${t.gridX},${t.gridY}`;if(this.activeCoinPositions.has(e)){const i=this.activeCoinPositions.get(e);i&&(this.handleCoinCollection(i.entity),this.removeCoin(t.gridX,t.gridY))}else this.gridOccupancyService.free(t.gridX,t.gridY,J.Coin)}}const o=s.worldContainer.position;if(!o)return;const r=-o.x,a=-o.y,h=this.gridService.worldToGrid(r,a),c=Math.floor(h.x),l=Math.floor(h.y);for(const[d,p]of this.activeCoinPositions.entries()){Math.abs(p.gridX-c)+Math.abs(p.gridY-l)>1.5*this.VISIBLE_RADIUS&&this.removeCoin(p.gridX,p.gridY)}}updateCoinPosition(t){const e=t.getComponent(C),i=t.getComponent(v);e&&i&&i.container.position.set(e.x,e.y)}handleCoinCollection(t){var e;const i=(null==(e=this.world)?void 0:e.getEntities())||[],s=i.find((t=>t.hasComponent(lt)));if(s){const t=s.getComponent(lt);t&&t.increment()}const n=i.find((t=>t.hasComponent(Z)));if(n){const t=n.getComponent(pt);t&&t.addBoost()}const o=this.coinPool.find((e=>e.entity===t));if(o){o.isInUse=!1;const e=t.getComponent(v);e&&(e.container.visible=!1)}}};St=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?yt(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&ut(e,i,o),o})([i(),mt(0,a(b)),mt(1,a(Q))],St);const vt=Symbol("UIComponent");class wt{constructor(t={}){e(this,"type",vt),e(this,"container"),e(this,"text"),e(this,"entity",null),this.container=new s;const i={fontFamily:"Arial",fontSize:24,fill:16777215,stroke:{color:0,width:4},align:"center",...t.style};this.text=new h({text:t.text||"",style:i}),this.container.addChild(this.text),void 0!==t.x&&(this.container.x=t.x),void 0!==t.y&&(this.container.y=t.y),this.text.anchor.set(.5)}setText(t){this.text.text=t}setPosition(t,e){this.container.x=t,this.container.y=e}}var ft=Object.defineProperty,Tt=Object.getOwnPropertyDescriptor;let It=class extends m{constructor(){super(),e(this,"uiContainer"),e(this,"requiredComponents",[vt]),this.uiContainer=new s,this.uiContainer.zIndex=1e4}setApp(t){super.setApp(t),t&&t.stage.addChild(this.uiContainer)}cleanup(){this.uiContainer&&this.app&&(this.app.stage.removeChild(this.uiContainer),this.uiContainer.destroy(),this.uiContainer=new s,this.uiContainer.zIndex=1e4)}reinitialize(){this.cleanup(),this.app&&this.app.stage.addChild(this.uiContainer)}updateRelevantEntities(t,e){if(this.app)for(const i of t){const t=i.getComponent(vt);t&&!this.uiContainer.children.includes(t.container)&&this.uiContainer.addChild(t.container)}}};It=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?Tt(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&ft(e,i,o),o})([i()],It);var Pt=Object.defineProperty,Et=Object.getOwnPropertyDescriptor;let Ot=class extends m{constructor(){super(...arguments),e(this,"requiredComponents",[lt,vt])}updateRelevantEntities(t,e){for(const i of t){const t=i.getComponent(lt),e=i.getComponent(vt);if(t&&e){const i=`Coins: ${t.getCount()} (High: ${t.getHighscore()})`;e.text.text!==i&&e.setText(i),e.container.zIndex=B.UI.COIN_COUNTER}}}onGameStateChanged(t,e){var i;if(e===u.Starting){const t=(null==(i=this.world)?void 0:i.getEntities())||[];for(const e of t){const t=e.getComponent(lt);if(t){t.reset();const i=e.getComponent(vt);i&&(i.setText(`Coins: ${t.getCount()} (High: ${t.getHighscore()})`),i.container.zIndex=B.UI.COIN_COUNTER)}}}}};Ot=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?Et(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&Pt(e,i,o),o})([i()],Ot);var xt=Object.defineProperty,bt=Object.getOwnPropertyDescriptor;let Lt=class extends m{constructor(){super(),e(this,"PARTICLE_LIFETIME",1),e(this,"PARTICLE_SPAWN_RATE",.05),e(this,"PARTICLE_SIZE",4),e(this,"PARTICLE_COLOR",7829367),e(this,"PARTICLE_ALPHA",.5),e(this,"PARTICLE_INITIAL_SPEED",300),e(this,"PARTICLE_DRAG",.98),e(this,"particleContainer",null),e(this,"timeSinceLastSpawn",0),e(this,"requiredComponents",[L,C,v])}setWorld(t){this.world=t}setApp(t){super.setApp(t),this.initializeParticleContainer()}initializeParticleContainer(){var t,e;if(!(null==(t=this.app)?void 0:t.stage))return;this.particleContainer&&(this.particleContainer.destroy(),this.particleContainer=null),this.particleContainer=new r;const i=null==(e=this.world)?void 0:e.getSystem(R);(null==i?void 0:i.worldContainer)&&i.worldContainer.addChild(this.particleContainer)}cleanup(){this.particleContainer&&(this.particleContainer.destroy(),this.particleContainer=null)}reinitialize(){this.cleanup(),this.initializeParticleContainer()}updateRelevantEntities(t,e){if(this.app&&this.particleContainer){this.particleContainer.clear();for(const i of t){const t=i.getComponent(L);if(t){const s=i.getComponent(C);s&&t.isActive&&(this.timeSinceLastSpawn+=e,this.timeSinceLastSpawn>=this.PARTICLE_SPAWN_RATE&&(this.spawnParticles(t,s),this.timeSinceLastSpawn=0)),this.updateParticles(t,e)}}}}updateParticles(t,e){var i;const s=null==(i=t.entity)?void 0:i.getComponent(C);if(s&&this.particleContainer)for(let n=t.particles.length-1;n>=0;n--){const i=t.particles[n];if(i.lifetime-=e,i.lifetime<=0){t.particles.splice(n,1);continue}const o=1-i.lifetime/this.PARTICLE_LIFETIME,r=this.PARTICLE_ALPHA*(1-o),a=i.size*(1-o),h=s.x+i.velocityX*o,c=s.y+i.velocityY*o;this.particleContainer.circle(h,c,a).fill({color:i.color,alpha:r})}}spawnParticles(t,e){const i=t.lastDirection,s=Math.atan2(i.y,i.x),n=Math.floor(2*Math.random())+2;for(let o=0;o<n;o++){const e=(Math.random()-.5)*Math.PI/4,i=s+Math.PI+e,n={color:this.PARTICLE_COLOR,size:this.PARTICLE_SIZE,lifetime:this.PARTICLE_LIFETIME,alpha:this.PARTICLE_ALPHA,velocityX:Math.cos(i)*this.PARTICLE_INITIAL_SPEED,velocityY:Math.sin(i)*this.PARTICLE_INITIAL_SPEED};t.particles.push(n)}}};Lt=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?bt(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&xt(e,i,o),o})([i()],Lt);var At=Object.defineProperty,Mt=Object.getOwnPropertyDescriptor;let Dt=class extends m{constructor(){super(...arguments),e(this,"requiredComponents",[pt,f])}updateRelevantEntities(t,e){if(this.world&&this.world.getCurrentState()===u.Playing)for(const i of t){const t=i.getComponent(pt),e=i.getComponent(f);t&&e&&(e.speed=e.baseSpeed*t.getSpeedMultiplier())}}onGameStateChanged(t,e){var i;if(e===u.Starting){const t=(null==(i=this.world)?void 0:i.getEntities())||[];for(const e of t){const t=e.getComponent(pt);t&&t.reset()}}}};Dt=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?Mt(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&At(e,i,o),o})([i()],Dt);var Rt=Object.defineProperty,zt=Object.getOwnPropertyDescriptor;let _t=class extends m{constructor(t){super(),e(this,"vignetteSprite",null),e(this,"requiredComponents",[]),this.gridService=t}setApp(t){this.app=t,this.initializeVignette()}setWorld(t){this.world=t}onGameStateChanged(t,e){e!==u.Starting&&e!==u.Playing||(this.initializeVignette(),this.updateVignetteScale())}initializeVignette(){if(!this.app||!this.world)return void console.log("[VignetteSystem] Waiting for app and world to be ready");console.log("[VignetteSystem] Initializing vignette"),this.vignetteSprite&&this.vignetteSprite.parent&&this.vignetteSprite.parent.removeChild(this.vignetteSprite);const t=n.get("/vignette3.png");this.vignetteSprite=new o(t),this.vignetteSprite.anchor.set(.5),this.vignetteSprite.zIndex=B.UI.VIGNETTE,this.vignetteSprite.visible=!1,this.app.stage.addChild(this.vignetteSprite),console.log("[VignetteSystem] Added vignette to stage")}updateVignetteScale(){if(!this.app||!this.vignetteSprite||!this.world)return;const{width:t,height:e}=this.gridService.getTileDimensions(),i=10*t*2,s=10*e*2,n=Math.max(i,s)/512;this.vignetteSprite.scale.set(n),this.vignetteSprite.visible=!0}updateRelevantEntities(t,e){this.vignetteSprite&&this.world&&this.app&&this.gridService&&this.updateVignetteScale()}};_t=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?zt(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&Rt(e,i,o),o})([i(),((t,e)=>(i,s)=>e(i,s,t))(0,a(b))],_t);var Gt=Object.defineProperty,Yt=Object.getOwnPropertyDescriptor,Xt=(t,e)=>(i,s)=>e(i,s,t);const Wt=200;let Ht=class{constructor(t,i,s,n,o,r,a,h,c,l,d,p){e(this,"app"),e(this,"world"),e(this,"lastTime"),e(this,"TILE_WIDTH",128),e(this,"TILE_HEIGHT",64),e(this,"character",null),e(this,"gridOccupancyService",null),e(this,"coinCounter",null),this.movementSystem=i,this.inputSystem=s,this.gridRenderSystem=n,this.treeSystem=o,this.zIndexSystem=r,this.coinSystem=a,this.uiRenderSystem=h,this.coinCounterSystem=c,this.particleSystem=l,this.speedBoostSystem=d,this.vignetteSystem=p,this.world=t(),this.world.addSystem(n),this.world.addSystem(i),this.world.addSystem(s),this.world.addSystem(o),this.world.addSystem(r),this.world.addSystem(a),this.world.addSystem(h),this.world.addSystem(c),this.world.addSystem(l),this.world.addSystem(d),this.world.addSystem(p),this.lastTime=performance.now(),this.gameLoop=this.gameLoop.bind(this),this.world.on("gameOver",(()=>{setTimeout((()=>{this.restart()}),1e3)})),this.world.on("createCharacter",(()=>{this.createCharacter()}))}async initializeSystems(){const t=this.world.container;this.movementSystem=t.get(R),this.inputSystem=t.get(X),this.gridRenderSystem=t.get(U),this.treeSystem=t.get(nt),this.zIndexSystem=t.get(at),this.coinSystem=t.get(St),this.uiRenderSystem=t.get(It),this.coinCounterSystem=t.get(Ot),this.particleSystem=t.get(Lt),this.speedBoostSystem=t.get(Dt),this.vignetteSystem=t.get(_t);const e=t.get(y);this.world=e(),this.movementSystem.setApp(this.app),this.inputSystem.setApp(this.app),this.gridRenderSystem.setApp(this.app),this.treeSystem.setApp(this.app),this.zIndexSystem.setApp(this.app),this.coinSystem.setApp(this.app),this.uiRenderSystem.setApp(this.app),this.particleSystem.setApp(this.app),this.speedBoostSystem.setApp(this.app),this.vignetteSystem.setApp(this.app),this.treeSystem.setWorld(this.world),this.coinSystem.setWorld(this.world),this.coinCounterSystem.setWorld(this.world),this.particleSystem.setWorld(this.world),this.speedBoostSystem.setWorld(this.world),this.vignetteSystem.setWorld(this.world),this.world.addSystem(this.gridRenderSystem),this.world.addSystem(this.movementSystem),this.world.addSystem(this.inputSystem),this.world.addSystem(this.treeSystem),this.world.addSystem(this.zIndexSystem),this.world.addSystem(this.coinSystem),this.world.addSystem(this.uiRenderSystem),this.world.addSystem(this.coinCounterSystem),this.world.addSystem(this.particleSystem),this.world.addSystem(this.speedBoostSystem),this.world.addSystem(this.vignetteSystem),this.movementSystem.reinitialize(),this.inputSystem.reinitialize(),this.gridRenderSystem.reinitialize(),this.treeSystem.reinitialize(),this.zIndexSystem.reinitialize(),this.coinSystem.reinitialize(),this.uiRenderSystem.reinitialize(),this.coinCounterSystem.reinitialize(),this.particleSystem.reinitialize(),this.speedBoostSystem.reinitialize(),this.vignetteSystem.reinitialize(),this.world.on("gameOver",(()=>{setTimeout((()=>{this.restart()}),1e3)})),this.createCharacter(),this.createCoinCounter(),this.world.setGameState(u.Starting)}async start(){this.app&&this.app.destroy(!0);const t=1280,e=720,i=Math.min(window.innerWidth/t,window.innerHeight/e),s=Math.floor(t*i),o=Math.floor(e*i);this.app=new c,await this.app.init({width:s,height:o,backgroundColor:16777215,resolution:Math.min(window.devicePixelRatio||1,2),autoDensity:!0,resizeTo:window});const r=document.querySelector("canvas");r&&r.remove(),document.body.appendChild(this.app.canvas),await n.load(["/character.png","/tree.png","/coin.png","/vignette.png","/vignette2.png","/vignette3.png"]),this.app.stage.position.set(this.app.screen.width/2,this.app.screen.height/2),await this.initializeSystems(),this.app.ticker.add(this.gameLoop),window.addEventListener("resize",(()=>{const i=Math.min(window.innerWidth/t,window.innerHeight/e),s=Math.floor(t*i),n=Math.floor(e*i);this.app.renderer.resize(s,n),this.app.stage.position.set(this.app.screen.width/2,this.app.screen.height/2)}))}async createCharacter(){if(this.character){const t=this.character.getComponent(v);t&&t.container.parent&&t.container.parent.removeChild(t.container),this.world.removeEntity(this.character)}this.character=new N;const t=0,e=0,i=this.gridToWorld(t,e),s=new E(t,e),n=new S(i.x,i.y),o=new w({spritePath:"/character.png"}),r=new I(150);r.targetDirection=T.DownRight;const a=new B(Wt),h=new F,c=new A,l=new gt;this.character.addComponent(s),this.character.addComponent(n),this.character.addComponent(o),this.character.addComponent(r),this.character.addComponent(a),this.character.addComponent(h),this.character.addComponent(c),this.character.addComponent(l),this.world.addEntity(this.character);const d=this.world.getSystem(R);d&&d.worldContainer&&d.worldContainer.addChild(o.container),o.container.position.set(i.x,i.y)}createCoinCounter(){if(this.coinCounter){const t=this.coinCounter.getComponent(vt);t&&t.container.parent&&t.container.parent.removeChild(t.container),this.world.removeEntity(this.coinCounter)}this.coinCounter=new N;const t=new dt,e=new wt({text:"Coins: 0",style:{fontSize:32,fill:16766720,stroke:{color:0,width:4}}});this.coinCounter.addComponent(t),this.coinCounter.addComponent(e),this.world.addEntity(this.coinCounter),this.app&&e.setPosition(0,-this.app.screen.height/2+40)}gridToWorld(t,e){return{x:(t-e)*(this.TILE_WIDTH/2),y:(t+e)*(this.TILE_HEIGHT/2)}}async restart(){for(console.log("[Game] Starting game restart"),this.world.cleanup();this.app.stage.children.length>0;){const t=this.app.stage.children[0];t.destroy(),this.app.stage.removeChild(t)}this.app.stage.position.set(this.app.screen.width/2,this.app.screen.height/2),await this.initializeSystems()}gameLoop(){const t=performance.now(),e=(t-this.lastTime)/1e3;this.lastTime=t,this.world.update(e)}get pixiApp(){return this.app}};Ht=((t,e,i,s)=>{for(var n,o=s>1?void 0:s?Yt(e,i):e,r=t.length-1;r>=0;r--)(n=t[r])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&Gt(e,i,o),o})([i(),Xt(0,a(y)),Xt(1,a(R)),Xt(2,a(X)),Xt(3,a(U)),Xt(4,a(nt)),Xt(5,a(at)),Xt(6,a(St)),Xt(7,a(It)),Xt(8,a(Ot)),Xt(9,a(Lt)),Xt(10,a(Dt)),Xt(11,a(_t))],Ht);(function(){const t=new l;return t.bind(y).toFactory((e=>()=>new y(t))),t.bind(Ht).toSelf().inSingletonScope(),t.bind(R).toSelf().inSingletonScope(),t.bind(X).toSelf().inSingletonScope(),t.bind(U).toSelf().inSingletonScope(),t.bind(nt).toSelf().inSingletonScope(),t.bind(at).toSelf().inSingletonScope(),t.bind(St).toSelf().inSingletonScope(),t.bind(It).toSelf().inSingletonScope(),t.bind(Ot).toSelf().inSingletonScope(),t.bind(Lt).toSelf().inSingletonScope(),t.bind(Dt).toSelf().inSingletonScope(),t.bind(_t).toSelf().inSingletonScope(),t.bind(b).toSelf().inSingletonScope(),t.bind(Q).toSelf().inSingletonScope(),t})().get(Ht).start();
//# sourceMappingURL=index-05fcd145.js.map
